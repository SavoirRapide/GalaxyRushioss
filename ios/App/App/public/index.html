<!DOCTYPE html>
<html lang="fr">
<head>
<link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap" rel="stylesheet">
  <meta charset="UTF-8" />

  <title>GALAXY RUSH</title>

  <!-- VIEWPORT (CRITIQUE MOBILE) -->
<meta name="viewport" 
      content="width=device-width, 
               height=device-height, 
               initial-scale=1.0, 
               maximum-scale=1.0, 
               minimum-scale=1.0, 
               user-scalable=no, 
               viewport-fit=cover">

  <!-- ===== PWA ===== -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#05060a">

  <!-- ===== iOS (OBLIGATOIRE) ===== -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Jetpack Runner">

  <!-- IC√îNES -->
  <link rel="icon" href="icon-192.png">
  <link rel="apple-touch-icon" href="icon-192.png">

  <!-- STYLE -->
  <style>

/* =========================================================================
   üåå JETPACK RUNNER ‚Äî STYLE SHEET FINAL (CLEAN V8 - SCALABLE UI FIX)
========================================================================= */

/* 1. VARIABLES & RESET */
:root {
  --font-title: 'Orbitron', sans-serif;
  --font-tech:  'Rajdhani', sans-serif;
  --col-gold:   #ffd700;
  --col-glass:  rgba(0, 0, 0, 0.6);
  
  --col-common:    #b0bec5;
  --col-rare:      #29b6f6;
  --col-epic:      #ab47bc;
  --col-legendary: #ffca28;
  
  /* Valeur par d√©faut si le JS ne charge pas tout de suite */
  --ui-scale: 1;
}

* { margin:0; padding:0; box-sizing:border-box; }

html, body {
  width:100%; height:100%;
  background:#05060a; color:#fff;
  font-family: var(--font-tech);
  overflow:hidden;
  touch-action:none; overscroll-behavior:none;
}

body { position:fixed; inset:0; display:block; }

/* =========================================================================
   üéÆ GAME CONTAINER & CANVAS
========================================================================= */
#gameContainer {
  position: absolute !important;
  inset: 0 !important;
  width: 100vw !important;
  height: 100vh !important;
  overflow: hidden;
  background: #000;
  z-index: 0;
  transition: opacity 0.05s linear;
}

canvas#game {
  display: block;
  width: 100%; height: 100%;
  image-rendering: auto; 
}

/* INPUT ZONE */
#touchZone {
  position:absolute; inset:0; z-index:10;
  touch-action: none; -webkit-touch-callout: none; user-select: none;
}

/* =========================================================================
   üëÄ HUD IN-GAME (ADAPTIVE SCALE)
========================================================================= */

/* Conteneur Global (Invisible) */
#uiLayer {
  position: absolute; inset: 0;
  pointer-events: none; z-index: 100;
  background: transparent !important;
  /* On n'applique PAS le scale ici pour garder le plein √©cran */
  display: flex; flex-direction: column; justify-content: space-between;
}
#uiLayer.allow-input { pointer-events: auto; }

/* SCORE */
#ui {
  position: absolute; 
  /* Gestion Safe Area pour les encoches */
  top: max(5%, env(safe-area-inset-top)); 
  left: 50%; 
  text-align: center; width: 100%; pointer-events: none;
  
  /* üî• SCALE FIX: Zoom intelligent */
  transform: translateX(-50%) scale(var(--ui-scale, 1));
  transform-origin: top center;
}

#uiScore {
  font-family: var(--font-title);
  font-size: 60px; font-weight: 900; font-style: italic;
  background: linear-gradient(180deg, #ffffff 20%, #b0c4de 100%);
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  filter: drop-shadow(0 4px 0px rgba(0,0,0,0.5));
  will-change: transform;
}

/* PI√àCES */
#uiCoins {
  position: absolute; 
  top: max(20px, env(safe-area-inset-top)); 
  left: max(20px, env(safe-area-inset-left));
  
  display: flex; align-items: center; gap: 8px;
  background: transparent !important;
  
  /* üî• SCALE FIX: Ancre en haut √† gauche */
  transform: scale(var(--ui-scale, 1));
  transform-origin: top left;
}

#uiCoins .coinIcon {
  width: 24px; height: 24px;
  background: radial-gradient(circle at 30% 30%, #fff6c7, #ffb400 60%, #ff7a00);
  border-radius: 50%; box-shadow: 0 0 10px #ffd700;
}

#coinCount {
  font-family: var(--font-title); font-size: 20px; font-weight: 700;
  color: #ffd700; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
}

/* OVERDRIVE & COMBO */
#overdriveMeter {
  position: absolute; 
  right: max(32px, env(safe-area-inset-right)); 
  top: 60%; 
  /* On combine le centrage Y et le scale */
  transform: translateY(-50%) scale(var(--ui-scale, 1));
  transform-origin: center right;
  
  width: 18px; height: 200px; z-index: 20; pointer-events: none;
}
#overdriveLabel { 
    position: absolute; top: -20px; width: 100%; text-align: center; 
    font-size: 10px; font-weight: 900; color: #40c4ff; 
}
#overdriveBarOuter {
  position: relative; width: 100%; height: 100%;
  border-radius: 4px; background: rgba(10, 15, 30, 0.6);
  border: 1px solid rgba(100, 180, 255, 0.3); overflow: hidden;
}
#overdriveBarInner {
  position: absolute; bottom: 0; width: 100%; height: 0%; border-radius: 2px;
  background: linear-gradient(180deg, #ffffff, #40c4ff, #2962ff);
  box-shadow: 0 0 20px rgba(41, 98, 255, 0.6); transition: height 0.1s linear;
}
body.overdriveActive #overdriveBarInner { animation: overdrivePulse 0.8s ease-in-out infinite alternate; }

#combo {
  position: absolute; 
  right: max(60px, env(safe-area-inset-right)); 
  top: 50%; 
  
  /* üî• SCALE FIX: On applique le scale de base */
  transform: translateY(-50%) scale(var(--ui-scale, 1));
  transform-origin: center right;
  
  font-family: var(--font-title); font-size: 24px; font-weight: 900; font-style: italic;
  opacity: 0; color: #fff; text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
  transition: opacity 0.2s ease, transform 0.1s;
}

/* Lors du pop, on multiplie le scale de base par 1.1 */
body.comboActive #combo { 
  opacity: 1; 
  /* calc() permet de garder la proportion relative √† l'UI globale */
  transform: translateY(-50%) scale(calc(var(--ui-scale, 1) * 1.3)); 
}
#combo span { color: #ffeb3b; }

@keyframes scorePulse { 
  0%   { transform: scale(1); } 
  50%  { transform: scale(1.15); } /* Boost√© l√©g√®rement */
  100% { transform: scale(1); } 
}
@keyframes overdrivePulse { from{filter:brightness(1);} to{filter:brightness(1.3);} }

/* =========================================================================
   üè† MENU PRINCIPAL & INTRO
========================================================================= */
#menuOverlay { 
  position: absolute; inset: 0; z-index: 26; 
  overflow: hidden; display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  width: 100vw; height: 100vh;
  /* ‚ö†Ô∏è PAS DE TRANSFORM ICI : Sinon le fond r√©tr√©cit ! */
}

/* Correction du fond vid√©o pour qu'il ne soit pas "trop zoom√©" 
   mais qu'il couvre quand m√™me tout l'√©cran */
#menuVideo { 
  position: absolute; top: 50%; left: 50%; 
  transform: translate(-50%, -50%);
  /* Force la taille √©cran exacte */
  width: 100vw; height: 100vh; 
  /* "cover" coupe ce qui d√©passe sans d√©former, parfait pour le ratio */
  object-fit: cover; 
  z-index: 0;
}

#galaxyBG, .menuParticles { position: absolute; inset: 0; pointer-events: none; }

/* BOUTONS MENU (C'est ici qu'on applique le SCALE) */
#menuButtons {
  position: relative; display: flex; flex-direction: column; gap: 12px; 
  z-index: 10; margin-top: 15vh;

  /* üî• SCALE FIX: Adapte la taille des boutons */
  transform: scale(var(--ui-scale, 1));
  transform-origin: center center;
}

.menuBtn {
  min-width: 220px; padding: 14px 0;
  font-family: var(--font-title); font-size: 14px; font-weight: 900; 
  letter-spacing: 3px; text-transform: uppercase;
  color: #fff; background: rgba(6, 10, 20, 0.85);
  border: 1px solid rgba(100, 200, 255, 0.3); backdrop-filter: blur(8px);
  clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
  cursor: pointer; transition: all 0.2s; box-shadow: 0 5px 20px rgba(0,0,0,0.5);
}
.menuBtn:hover {
  background: rgba(100, 200, 255, 0.1); border-color: #fff; transform: scale(1.05);
  box-shadow: 0 0 30px rgba(100, 200, 255, 0.2);
}
/* BOUTON ROULETTE (STYLE PREMIUM GOLD) */
.roulette-btn {
  background: linear-gradient(135deg, rgba(255, 215, 0, 0.15), rgba(255, 140, 0, 0.15));
  border-color: #ffd700;
  color: #ffd700;
  box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
  margin-top: 15px; /* L'√©carte un peu des autres boutons */
}
.roulette-btn:hover {
  background: linear-gradient(135deg, rgba(255, 215, 0, 0.4), rgba(255, 140, 0, 0.4));
  box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
  color: #fff;
  border-color: #fff;
}
#btnPlay { 
  background: #fff; color: #000; font-size: 18px; padding: 18px 0; 
  box-shadow: 0 0 20px rgba(255,255,255,0.25); 
}
#btnPlay:hover { 
  background: #d4eeff; transform: scale(1.05); box-shadow: 0 0 50px rgba(200, 230, 255, 0.6); 
}

/* STATS MENU (On applique aussi le SCALE ici) */
#menuStats {
  position: absolute; 
  /* Protection encoche (notch) */
  top: max(20px, env(safe-area-inset-top)); 
  right: max(5%, env(safe-area-inset-right));

  display: flex; gap: 12px; z-index: 12; pointer-events: none;

  /* üî• SCALE FIX: Ancr√© en haut √† droite */
  transform: scale(var(--ui-scale, 1));
  transform-origin: top right;
}

.statBox {
  background: linear-gradient(180deg, rgba(20,30,50,0.9), rgba(5,10,20,0.95));
  border: 1px solid rgba(100,180,255,0.2); border-radius: 8px; 
  padding: 6px 12px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);
}
.statBox.coins { border-color: rgba(255, 215, 0, 0.3); }
.statLabel { font-family: var(--font-tech); font-weight: 700; font-size: 10px; opacity: 0.7; }
.statValue { font-family: var(--font-title); font-weight: 700; font-size: 18px; color: #fff; }
.statBox.coins .statValue { color: var(--col-gold); text-shadow: 0 0 10px rgba(255, 180, 0, 0.4); }

/* =========================================================================
   üéÅ DAILY GIFT POPUP (VERSION SLIM & MOBILE SAFE & SCALABLE)
========================================================================= */

#menuAdPopup {
  position: absolute; 
  /* Position de d√©part : cach√© en bas */
  bottom: -150px; 
  left: 50%; 
  
  /* üî• SCALE FIX : On combine le centrage X et le Scale UI */
  transform: translateX(-50%) scale(var(--ui-scale, 1));
  /* On ancre l'√©chelle en bas au centre pour que √ßa ne "flotte" pas */
  transform-origin: bottom center;
  
  /* Largeur adaptative mais max√©e pour ne pas √™tre √©norme */
  width: 90%; 
  max-width: 320px; 
  
  /* üî• R√âDUCTION DU PADDING (Plus fin) */
  padding: 8px 12px;
  z-index: 2000;
  
  background: rgba(10, 16, 28, 0.95); 
  backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 215, 0, 0.3);
  border-radius: 8px; 
  box-shadow: 0 5px 20px rgba(0,0,0,0.6);
  
  display: flex; flex-direction: row; 
  align-items: center; justify-content: space-between; 
  gap: 10px; 
  
  transition: bottom 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); 
}

/* Position Visible : Tr√®s bas pour √©viter le menu */
#menuAdPopup.visible { 
    /* Utilise env() pour √©viter la barre blanche des iPhones */
    bottom: max(15px, env(safe-area-inset-bottom)); 
}

/* Contenu gauche */
.daily-left { 
    display: flex; flex-direction: column; align-items: flex-start; 
    justify-content: center;
}

.daily-header {
  font-family: var(--font-title); 
  font-size: 10px; 
  font-weight: 900;
  color: #ffd700; 
  letter-spacing: 0.5px; 
  text-transform: uppercase;
  display: flex; align-items: center; gap: 4px; 
  margin-bottom: 0px; 
  line-height: 1.2;
}

.daily-sub { 
    font-family: var(--font-tech); 
    font-size: 9px; 
    color: #94a3b8; 
    line-height: 1.2;
}

/* Bouton Droite (Action) - VERSION COMPACTE */
.daily-claim-btn {
  padding: 6px 12px; 
  border: none; border-radius: 4px;
  
  background: linear-gradient(135deg, #ffd700 0%, #ff8c00 100%);
  color: #3a1d00; 
  
  font-family: var(--font-title); 
  font-weight: 900; 
  font-size: 11px; 
  letter-spacing: 0.5px;
  
  cursor: pointer; 
  box-shadow: 0 2px 8px rgba(255, 160, 0, 0.2);
  transition: transform 0.1s; white-space: nowrap;
  position: relative; overflow: hidden;
}

.daily-claim-btn:active { transform: scale(0.95); }

/* Animation brillance */
.daily-claim-btn::after {
  content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shineGift 3s infinite;
}

.daily-claim-btn:hover { filter: brightness(1.1); }

/* On cache les vieux √©l√©ments */
.daily-content, .daily-coin-display, .daily-amount, .daily-info { display: none; }
.daily-stock { display: none; }

@keyframes shineGift { 0%{left:-100%} 20%{left:100%} 100%{left:100%} }
/* =========================================================================
   üõçÔ∏è SHOP SYSTEM V8 (HARDCORE & HOLOGRAPHIC & SCALABLE)
========================================================================= */
#shopPanel {
  position: absolute; inset: 0; width: 100vw; height: 100vh; z-index: 500;
  
  /* Le fond reste en plein √©cran SANS scale */
  background: 
    linear-gradient(180deg, rgba(2,6,12,1) 0%, rgba(10,20,40,0.9) 100%),
    repeating-linear-gradient(90deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px),
    repeating-linear-gradient(0deg, rgba(255,255,255,0.03) 0px, rgba(255,255,255,0.03) 1px, transparent 1px, transparent 40px);
  background-position: center bottom;
  background-size: 100% 100%, 100% 50vh, 100% 50vh; 
  background-repeat: no-repeat;
  
  display: none; opacity: 0; pointer-events: none; overflow: hidden;
  transition: opacity 0.3s ease;
}
#shopPanel.visible { display: block !important; opacity: 1; pointer-events: auto; }

/* ZONE CENTRALE (PRESENTOIR) - C'est ici qu'on applique le SCALE */
.shopContentZone {
  position: absolute; top: 0; bottom: 0; width: 100%;
  display: flex; flex-direction: column; align-items: center; justify-content: center;
  perspective: 1000px; 
  
  /* üî• SCALE FIX: Tout le contenu (Perso + Infos) est scal√© ensemble */
  transform: scale(var(--ui-scale, 1));
  transform-origin: center center;
}

/* CERCLE SOL (SOCLE) */
.skinCard {
  position: relative; width: 100%; display: flex; justify-content: center; align-items: center;
  background: radial-gradient(ellipse at center, rgba(0, 150, 255, 0.15) 0%, transparent 60%);
  background-size: 80% 20%; background-position: center 80%; background-repeat: no-repeat;
}

#shopHeroCanvas {
  height: 60vh; width: auto; max-width: 90vw;
  object-fit: contain; 
  filter: drop-shadow(0 0 30px rgba(0, 150, 255, 0.2)); 
  animation: holoFloat 4s ease-in-out infinite;
}

@keyframes holoFloat { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-15px)} }

/* ZONE D'INFOS (BAS) */
.skinInfoZone {
  position: absolute; bottom: 40px; left: 0; right: 0;
  display: flex; flex-direction: column; align-items: center; z-index: 20;
  gap: 8px;
  /* Pas besoin de scale ici car c'est dans .shopContentZone */
}

/* NOM DU SKIN */
.skinName {
  font-family: var(--font-title); font-size: 42px; font-weight: 900; 
  text-transform: uppercase; letter-spacing: 4px;
  color: #fff;
  text-shadow: 0 0 10px rgba(0, 200, 255, 0.8), 0 0 30px rgba(0, 100, 255, 0.4);
  margin-bottom: 5px;
}

/* PRIX */
.skinPrice {
  font-family: var(--font-tech); font-size: 18px; color: #a0c4ff;
  background: rgba(0, 20, 40, 0.6); padding: 4px 12px; border-radius: 4px;
  border: 1px solid rgba(100, 200, 255, 0.2); margin-bottom: 15px;
  letter-spacing: 1px;
}

/* BOUTON D'ACTION */
.skinButton {
  min-width: 260px; padding: 18px 0; border: none; cursor: pointer;
  font-family: var(--font-title); font-size: 18px; font-weight: 900; text-transform: uppercase;
  letter-spacing: 1px; color: #000;
  clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
  transition: transform 0.1s, filter 0.1s;
  box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}
.skinButton:active { transform: scale(0.96); }

/* VARIANTES BOUTON */
.skinButton.common    { background: linear-gradient(135deg, #e0e0e0, #ffffff); }
.skinButton.rare      { background: linear-gradient(135deg, #4facfe, #00f2fe); box-shadow: 0 0 20px rgba(0, 242, 254, 0.4); }
.skinButton.epic      { background: linear-gradient(135deg, #b721ff, #21d4fd); box-shadow: 0 0 20px rgba(183, 33, 255, 0.4); }
.skinButton.legendary { background: linear-gradient(135deg, #f093fb, #f5576c); box-shadow: 0 0 20px rgba(245, 87, 108, 0.4); }

/* HEADER SHOP */
#shopBackBtn {
  position: absolute; 
  top: max(20px, env(safe-area-inset-top)); 
  left: max(20px, env(safe-area-inset-left));
  
  z-index: 600; cursor: pointer;
  font-family: var(--font-tech); font-weight: 700; color: rgba(255,255,255,0.7);
  padding: 8px 16px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
  clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
  
  /* üî• SCALE FIX: Ancre Top Left */
  transform: scale(var(--ui-scale, 1));
  transform-origin: top left;
}

#shopBalanceDisplay {
  position: absolute; 
  top: max(20px, env(safe-area-inset-top));
  left: 50%; 
  
  /* üî• SCALE FIX: On combine translate X et Scale */
  transform: translateX(-50%) scale(var(--ui-scale, 1));
  transform-origin: top center;
  
  z-index: 600;
  display: flex; align-items: center; gap: 8px;
  padding: 8px 20px; background: rgba(0,0,0,0.8); border: 1px solid rgba(255, 215, 0, 0.3); border-radius: 30px;
}
#shopTotalCoins { font-family: var(--font-title); font-size: 24px; font-weight: 900; color: #ffd700; }
#shopBalanceDisplay .coinIcon { width: 20px; height: 20px; background: #ffd700; border-radius: 50%; box-shadow: 0 0 8px #ffd700; }

/* === SHOP LOOT BUTTON === */
#shopAdBlock {
  position: absolute; 
  top: max(20px, env(safe-area-inset-top));
  right: max(20px, env(safe-area-inset-right));
  
  z-index: 600;
  display: flex; align-items: center; gap: 12px;
  background: rgba(0, 30, 15, 0.95); 
  border: 1px solid #00e676;
  padding: 10px 18px; border-radius: 12px; 
  cursor: pointer;
  box-shadow: 0 0 20px rgba(0, 230, 118, 0.2);
  transition: transform 0.2s, background 0.2s;
  animation: pulseLoot 3s infinite;
  
  /* üî• SCALE FIX: Ancre Top Right */
  transform: scale(var(--ui-scale, 1));
  transform-origin: top right;
}

/* L'animation hover doit respecter le scale de base ! */
#shopAdBlock:hover { 
  /* calc() pour combiner le scale de l'UI et le zoom au survol */
  transform: scale(calc(var(--ui-scale, 1) * 1.05)); 
  background: rgba(0, 50, 25, 1); 
  box-shadow: 0 0 30px rgba(0, 230, 118, 0.4);
}

.loot-icon { font-size: 28px; line-height: 1; filter: drop-shadow(0 0 5px #00e676); }
.loot-info { display: flex; flex-direction: column; align-items: flex-end; line-height: 1.2; }
.loot-title { font-family: var(--font-tech); font-size: 10px; color: #b9f6ca; font-weight: 700; letter-spacing: 1px; }
.loot-action { font-family: var(--font-title); font-size: 14px; color: #fff; font-weight: 900; text-shadow: 0 0 10px rgba(0,255,100,0.5); }
@keyframes pulseLoot { 0%,100%{border-color:#00e676;} 50%{border-color:#88ffbb;} }

/* FL√àCHES DE NAVIGATION (On ne les scale pas pour qu'elles restent coll√©es aux bords) */
#shopPanel .navArrow {
  position:absolute; top:50%; transform:translateY(-50%); width:60px; height:100px;
  display:flex; align-items:center; justify-content:center;
  font-size:40px; color:rgba(255,255,255,0.4); cursor:pointer; z-index:100; user-select:none;
  background:linear-gradient(90deg, transparent, rgba(255,255,255,0.05), transparent);
  transition:all 0.2s;
}
#shopPanel .navArrow:hover { color:#fff; background:rgba(255,255,255,0.1); transform:translateY(-50%) scale(1.1); }
#shopPanel .navArrow.left { left:max(10px, env(safe-area-inset-left)); }
#shopPanel .navArrow.right { right:max(10px, env(safe-area-inset-right)); }
/* =========================================
   üîì ANIMATION D√âBLOCAGE SHOP (CORRIG√â & FINAL)
========================================= */

@keyframes unlockPulse {
  0% { 
    transform: scale(1); 
    /* On retire tout filtre gris pour r√©v√©ler les vraies couleurs */
    filter: brightness(1) grayscale(0%) drop-shadow(0 0 0 rgba(0,255,255,0));
  }
  30% { 
    transform: scale(1.15); 
    /* Flash lumineux intense cyan + Glow externe */
    filter: brightness(1.5) grayscale(0%) drop-shadow(0 0 30px rgba(0, 255, 255, 0.8));
  }
  100% { 
    transform: scale(1); 
    filter: brightness(1) grayscale(0%) drop-shadow(0 0 0 rgba(0,255,255,0));
  }
}

/* Classe ajout√©e par le JS lors de l'achat */
.unlock-success {
  /* IMPORTANT : Overwrite l'animation "holoFloat" (le flottement) */
  animation: unlockPulse 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards !important;
  
  /* Force le GPU pour √©viter le lag pendant le flash */
  will-change: transform, filter;
  z-index: 100; /* Passe devant le reste pendant l'anim */
}

/* Petit effet sur le prix pour montrer que c'est pay√© */
.price-paid {
  color: #00ff00 !important; /* Vert Hacker */
  font-weight: 900;
  
  /* On combine le scale UI du parent avec ce scale local, c'est safe ici */
  transform: scale(1.2);
  
  text-shadow: 0 0 15px rgba(0, 255, 0, 0.6); 
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}
/* =========================================================================
   1. L'√âCRAN D'INTRO (TAP TO START)
========================================================================= */
#overlayIntro {
  position: fixed; inset: 0; 
  /* Force la taille √©cran pour √©viter les soucis de barre d'adresse */
  width: 100vw; height: 100vh;
  
  z-index: 10000; 
  background: #000;
  display: flex; align-items: center; justify-content: center;
  pointer-events: auto !important; 
  transition: opacity 0.3s ease-out; 
  
  /* ‚ö†Ô∏è PAS DE TRANSFORM ICI : On veut que le fond couvre tout l'√©cran */
}

/* Le Logo/Image de fond : Doit remplir l'√©cran (COVER) sans √™tre d√©form√© */
#overlayIntro #introLogo { 
  position: absolute; inset: 0; 
  width: 100vw; height: 100vh;
  pointer-events: none; z-index: 1; 
}
#overlayIntro #introLogo img { 
  display: block; width: 100%; height: 100%; 
  object-fit: cover; /* Garantit le plein √©cran sur S24 et iPhone */
}

/* Le Texte "TAP TO START" : Lui, on doit le scaler pour qu'il reste lisible */
#overlayIntro .introHint {
  position: absolute; 
  /* On respecte la Safe Area (pour ne pas √™tre sous la barre home iOS) */
  bottom: max(15%, env(safe-area-inset-bottom) + 20px); 
  left: 0; width: 100%; text-align: center; z-index: 10;
  
  font-family: var(--font-title, sans-serif); font-size: 24px; font-weight: 900; letter-spacing: 4px;
  color: #fff; text-shadow: 0 0 20px rgba(0,200,255,0.8);
  animation: tapPulse 1.5s ease-in-out infinite;

  /* üî• SCALE FIX: On applique l'√©chelle UI ici */
  transform: scale(var(--ui-scale, 1));
  transform-origin: bottom center;
}

@keyframes tapPulse { 
  /* On combine le scale de l'anim avec le scale UI via la cascade CSS ou wrapping */
  /* Simplification : ici l'anim modifie le scale, donc on va l'appliquer sur un SPAN interne si possible,
     ou on modifie l'anim pour inclure la variable. 
     SOLUTION SIMPLE : On laisse l'anim g√©rer son propre scale relatif. */
  0%, 100% { opacity: 0.6; transform: scale(calc(var(--ui-scale, 1) * 0.95)); } 
  50%      { opacity: 1;   transform: scale(calc(var(--ui-scale, 1) * 1.05)); } 
}

/* =========================================================================
   2. LE LOADER SYSTEM (NOUVEAU - SCI-FI)
========================================================================= */
#transitionLoader {
  position: fixed; inset: 0; 
  width: 100vw; height: 100vh;
  z-index: 2147483647; 
  background: #000;
  
  display: none; 
  opacity: 0;
  align-items: center; justify-content: center;
  transition: opacity 0.5s ease;
  pointer-events: none;
}

#transitionLoader.active {
  display: flex !important; 
  opacity: 1 !important;
  pointer-events: auto !important; 
}

/* üî• C'est ici qu'on scale la BO√éTE de chargement compl√®te */
.loader-content { 
  width: 280px; 
  font-family: var(--font-tech); text-align: center; 
  
  /* SCALE FIX : On agrandit/r√©tr√©cit tout le bloc de chargement */
  transform: scale(var(--ui-scale, 1));
  transform-origin: center center;
}

.loader-glitch {
  font-family: var(--font-title); font-size: 20px; color: #fff;
  letter-spacing: 4px; margin-bottom: 15px; 
  text-shadow: 0 0 10px rgba(0, 200, 255, 0.8);
}

.loader-bar-wrap {
  width: 100%; height: 6px; background: #111;
  border: 1px solid #333; margin-bottom: 8px;
  position: relative; overflow: hidden; border-radius: 2px;
}

#transBar {
  width: 0%; height: 100%;
  background: #00f0ff;
  box-shadow: 0 0 20px #00f0ff;
  transition: width 0.1s linear;
}

.loader-data {
  display: flex; justify-content: space-between;
  font-size: 12px; color: #00f0ff; font-weight: 700; letter-spacing: 1px;
}

/* =========================================================================
   3. LE MUR INVISIBLE (S√âCURIT√â ANDROID)
========================================================================= */
#inputBlocker {
  position: fixed; inset: 0; width: 100vw; height: 100vh;
  z-index: 2147483646; 
  background: transparent;
  display: none;
  touch-action: none;
  /* Pas de scale ici, c'est juste un mur fonctionnel */
}
/* =========================================================================
   üíÄ GAME OVER & REVIVE (SCALABLE & SAFE - VERSION COMPACTE)
========================================================================= */

/* Overlay Game Over (Fond Flou) */
#overlayGameOver {
  position: absolute; inset: 0; 
  /* Force le plein √©cran pour le fond */
  width: 100vw; height: 100vh;
  
  display: flex; align-items: center; justify-content: center;
  background: radial-gradient(circle at 50% 40%, rgba(20, 30, 60, 0.4), rgba(0, 0, 0, 0.95));
  backdrop-filter: blur(8px); 
  
  visibility: hidden; opacity: 0; pointer-events: none; z-index: 100;
  transition: opacity 0.35s ease;
  
  /* ‚ö†Ô∏è PAS DE TRANSFORM ICI */
}
#overlayGameOver.visible { visibility: visible; opacity: 1; pointer-events: auto; }

/* Carte de Score (Plus compacte pour laisser la place au bouton) */
.gameOverCard {
  min-width: 260px; /* R√©duit (avant: 300px) */
  padding: 25px;    /* R√©duit (avant: 40px) */
  display: flex; flex-direction: column; align-items: center; gap: 15px; /* R√©duit (avant: 20px) */
  
  background: rgba(10, 15, 30, 0.85); 
  border: 1px solid rgba(100, 180, 255, 0.2);
  /* Coins biseaut√©s affin√©s (15px au lieu de 20px) */
  clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);

  /* üî• SCALE FIX: On redimensionne toute la fen√™tre de fin */
  transform: scale(var(--ui-scale, 1));
  transform-origin: center center;
}

.gameOverTitle {
  font-family: var(--font-title); 
  font-size: 30px; /* R√©duit (avant: 38px) */
  font-weight: 900; margin: 0; text-transform: uppercase;
  background: linear-gradient(180deg, #fff, #ff4081); 
  -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}

.gameOverStats { 
  width: 100%; display: flex; flex-direction: column; 
  gap: 8px; /* R√©duit (avant: 12px) */
  border-top: 1px solid rgba(255,255,255,0.1); 
  padding: 15px 0; /* R√©duit (avant: 20px) */
}

.gameOverStats p { 
  display:flex; justify-content:space-between; 
  font-family:var(--font-tech); 
  font-size:15px; /* R√©duit (avant: 18px) */
  color:#a0b0c0; 
}

.gameOverActions { 
  display: flex; 
  gap: 12px; /* R√©duit (avant: 16px) */
  width: 100%; 
}

.gameOverActions .bigButton {
  flex: 1; 
  padding: 12px 0; /* R√©duit (avant: 16px) */
  font-family: var(--font-title); 
  font-size: 13px; /* Ajout d'une taille de police fixe */
  font-weight: 700; text-transform: uppercase;
  border: 1px solid rgba(255,255,255,0.2); 
  background: rgba(255,255,255,0.05); color: #fff; cursor: pointer;
}

#restartBtn { background: #fff; color: #000; border: none; }
/* === REVIVE POPUP STYLES === */
#continuePopup {
  position: absolute; inset: 0; 
  width: 100vw; height: 100vh; /* Plein √©cran forc√© */
  z-index: 210;
  
  display: none; align-items: center; justify-content: center;
  background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px);
  pointer-events: auto;
  
  /* ‚ö†Ô∏è PAS DE TRANSFORM ICI */
}

/* Carte de Revive (C'est elle qu'on scale aussi) */
.revive-card {
  width: 320px; padding: 25px;
  background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
  border: 1px solid rgba(255, 50, 50, 0.3);
  box-shadow: 0 0 50px rgba(255, 0, 0, 0.15), inset 0 0 20px rgba(0,0,0,0.5);
  clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
  text-align: center; display: flex; flex-direction: column; gap: 15px;
  
  /* L'animation popIn modifie d√©j√† le scale, il faut le combiner ! */
  /* Mais comme c'est une animation Keyframe, on ne peut pas injecter la variable facilement sans JS. */
  /* ASTUCE : On applique le scale sur un wrapper ou on laisse l'animation g√©rer son scale relatif (0.8 -> 1) */
  /* Ici, on va faire simple : on applique le scale UI via la propri√©t√© zoom (non standard mais efficace) ou transform sur le parent si possible. */
  /* MEILLEURE SOLUTION : On modifie l'animation pour inclure la variable CSS */
  
  animation: popInScaled 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}

/* Nouvelle animation qui prend en compte le Scale UI */
@keyframes popInScaled { 
  0%   { opacity: 0; transform: scale(calc(var(--ui-scale, 1) * 0.8)); } 
  100% { opacity: 1; transform: scale(var(--ui-scale, 1)); } 
}

.revive-header {
  font-family: var(--font-title); font-size: 22px; font-weight: 900;
  color: #ff4444; text-transform: uppercase; letter-spacing: 2px;
  text-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
  animation: alertBlink 1s infinite;
}
.revive-sub { font-size: 12px; color: #94a3b8; font-family: var(--font-tech); letter-spacing: 1px; }

/* C≈ìur qui bat */
.revive-visual {
  position: relative; height: 60px; display: flex; align-items: center; justify-content: center; margin: 10px 0;
}
.revive-icon { font-size: 40px; animation: heartBeat 0.8s infinite; z-index: 2; }
.revive-pulse-ring {
  position: absolute; width: 50px; height: 50px; border-radius: 50%;
  border: 2px solid #ff4444; opacity: 0; animation: pulseRing 1.2s infinite;
}

/* Bouton principal */
.revive-btn {
  position: relative; border: none; padding: 16px;
  background: linear-gradient(90deg, #00c6ff, #0072ff);
  font-family: var(--font-title); font-size: 18px; font-weight: 900; color: #fff;
  text-transform: uppercase; letter-spacing: 1px; cursor: pointer;
  clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
  box-shadow: 0 0 20px rgba(0, 198, 255, 0.4);
  transition: transform 0.1s; overflow: hidden;
}
.revive-btn:active { transform: scale(0.96); }
.revive-btn::after {
  content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
  animation: shine 2s infinite;
}

/* Barre de temps */
.revive-timer-track {
  width: 100%; height: 6px; background: #0f172a; border-radius: 3px; overflow: hidden;
  margin-top: 5px; border: 1px solid rgba(255,255,255,0.1);
}
#continueBar {
  width: 100%; height: 100%; background: #ff4444;
  box-shadow: 0 0 10px #ff4444;
  transition: width 0.1s linear; 
}

.revive-skip {
  font-size: 11px; color: #64748b; cursor: pointer; text-decoration: underline; margin-top: 5px;
}
.revive-skip:hover { color: #fff; }

@keyframes alertBlink { 0%,100%{opacity:1} 50%{opacity:0.6} }
@keyframes heartBeat { 0%{transform:scale(1)} 15%{transform:scale(1.3)} 30%{transform:scale(1)} 45%{transform:scale(1.15)} 60%{transform:scale(1)} }
@keyframes pulseRing { 0%{transform:scale(0.5);opacity:1} 100%{transform:scale(2);opacity:0} }
@keyframes shine { 0%{left:-100%} 20%{left:100%} 100%{left:100%} }
@keyframes blink {
    0% { opacity: 1; }
    50% { opacity: 0.3; }
    100% { opacity: 1; }
}

/* =========================================================================
   ‚öôÔ∏è OPTIONS (OptionsPanel)
   (Ajout√© ici pour compl√©ter, m√™me logique)
========================================================================= */
#optionsPanel {
  position:absolute; inset:0; display:none; flex-direction:column; z-index:10000;
  width: 100vw; height: 100vh;
  
  background: radial-gradient(circle at 50% 40%, rgba(0,220,255,.10), rgba(0,0,0,0) 48%), linear-gradient(180deg, rgba(5,10,25,.92), rgba(0,0,0,.75));
  backdrop-filter:blur(10px); align-items:center; justify-content:center; pointer-events:auto;
  
  /* ‚ö†Ô∏è PAS DE TRANSFORM ICI */
}
#optionsPanel .optionsBox {
  width:100%; max-width:440px; padding:42px 38px;
  background:linear-gradient(180deg, rgba(12,20,48,.72), rgba(6,10,26,.62));
  border-radius:20px; border:1px solid rgba(140,200,255,0.18); color:#cfe9ff;
  
  /* üî• SCALE FIX: On scale la bo√Æte d'options */
  transform: scale(var(--ui-scale, 1));
  transform-origin: center center;
}
.optRow { margin-bottom:20px; }
#optBack { width:100%; margin-top:26px; }
/* =========================================================================
   üì± MEDIA QUERIES & FIXES
========================================================================= */
/* Cache le menu quand on joue (CORRIG√â) */
body.playing #menuOverlay,
body.playing #menuVideo,
body.playing #galaxyBG,
body.playing .menuParticles {
    display: none !important; visibility: hidden !important; opacity: 0 !important; pointer-events: none !important;
}

/* Mobile Portrait Shop Fix */
@media (max-width: 600px) {
    .shopContentZone { top: 60px; bottom: 80px; }
    #shopHeroCanvas { max-height: 45vh; max-width: 85vw; }
    .skinName { font-size: 28px; margin-bottom: 4px; }
    .skinPrice { font-size: 16px; margin-bottom: 15px; }
    .skinButton { min-width: 180px; padding: 12px 0; font-size: 14px; }
    #shopPanel .navArrow { width: 60px; font-size: 40px; background: radial-gradient(circle, rgba(0,0,0,0.2), transparent 70%); }
}

/* Mobile Landscape Shop Fix */
@media (max-height: 550px) {
    #shopHeroCanvas { height: 50vh; }
    .shopContentZone { top: 50px; }
    .skinInfoZone { bottom: 10px; padding-top: 10px; padding-bottom: 10px; }
    .skinName { font-size: 24px; }
    .skinButton { padding: 10px 0; min-width: 180px; font-size: 14px; }
}
/* =========================================================================
   üì± TABLET FIX (iPad & Android Tablets)
   Cible les √©crans plus larges que les mobiles mais moins que les PC,
   et surtout avec un ratio plus "carr√©" (4:3 ou 16:10)
========================================================================= */
@media screen and (min-width: 601px) and (max-width: 1180px) {

    /* 1. R√©duire la taille du perso dans le shop pour qu'il ne mange pas tout l'√©cran */
    #shopHeroCanvas {
        height: 45vh !important; /* On passe de 60vh √† 45vh */
        max-width: 60vw;
    }

    /* 2. Remonter la zone de contenu */
    .shopContentZone {
        justify-content: flex-end; /* Pousse vers le bas pour √©viter le header */
        padding-bottom: 140px;     /* Laisse de la place pour les boutons */
    }

    /* 3. Ajuster la taille des textes qui sont souvent trop gros sur tablette */
    .skinName {
        font-size: 32px; /* Au lieu de 42px */
    }
    
    .skinPrice {
        font-size: 16px;
        margin-bottom: 10px;
    }

    /* 4. Le bouton d'action */
    .skinButton {
        min-width: 220px;
        padding: 14px 0;
        font-size: 16px;
    }

    /* 5. Score en jeu un peu plus petit */
    #uiScore {
        font-size: 50px;
        top: 3%;
    }
    
    /* 6. Boutons du menu principal */
    .menuBtn {
        min-width: 200px;
        padding: 12px 0;
        font-size: 13px;
    }
    
    /* 7. Carte Game Over */
    .gameOverCard {
        transform: scale(0.9); /* R√©duit globalement la fen√™tre de fin */
    }
}
/* === ROULETTE CYBERPUNK REACTOR (EXTRA COMPACTE) === */
:root {
    --mw-size: 220px; /* Taille fortement r√©duite */
    --c-x2: #181820;  /* Carbone sombre pour contraster le texte */
    --c-x4: #00ffcc;  /* Cyan Cyber */
    --c-x6: #7d2ae8;  /* Violet Synthwave */
    --c-x8: #ff007c;  /* Rose Fluo */
    --c-x10: #ffaa00; /* Orange √ânergie */
    --c-x15: #ffdf00; /* Or / Jaune pur */
}

/* Encore plus petit pour les tr√®s vieux t√©l√©phones (ex: iPhone SE) */
@media (max-width: 360px) {
    :root { --mw-size: 190px; }
}

#multiplierPopup {
    position: fixed; inset: 0; z-index: 5000;
    background: rgba(4, 6, 12, 0.95);
    backdrop-filter: blur(10px);
    display: flex; align-items: center; justify-content: center;
}

.multi-container {
    display: flex; flex-direction: column; align-items: center;
    width: 100%;
}

/* Texte du haut tr√®s discret */
.multi-title {
    font-family: 'Orbitron', sans-serif; 
    font-size: 16px; /* Taille r√©duite */
    font-weight: 900;
    color: #00ffcc; letter-spacing: 3px; text-align: center;
    text-shadow: 0 0 10px rgba(0, 255, 204, 0.5);
    margin-bottom: 15px; /* Marge r√©duite */
}

/* Le Halo autour de la roue */
.wheel-wrapper-outer {
    position: relative;
    width: var(--mw-size); height: var(--mw-size);
    border-radius: 50%;
    padding: 6px;
    background: #0a0a10;
    box-shadow: 0 0 25px rgba(0, 255, 204, 0.2), inset 0 0 10px #000;
}

/* Le Pointeur (Fl√®che Laser) */
.laser-pointer {
    position: absolute; top: -12px; left: 50%; transform: translateX(-50%);
    width: 0; height: 0; z-index: 100;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-top: 18px solid #fff;
    filter: drop-shadow(0 0 8px #00ffcc);
}

.wheel-wrapper-inner {
    position: relative; width: 100%; height: 100%;
    border-radius: 50%; overflow: hidden;
    border: 3px solid #333;
    box-shadow: inset 0 0 20px #000;
}

.neon-wheel {
    position: absolute; inset: 0;
    transition: transform 5s cubic-bezier(0.15, 0, 0.15, 1);
}

.mw-segments {
    position: absolute; inset: 0;
    background: conic-gradient(
        var(--c-x2)  0deg 180deg,
        var(--c-x4)  180deg 270deg,
        var(--c-x6)  270deg 324deg,
        var(--c-x8)  324deg 349deg,
        var(--c-x10) 349deg 356deg,
        var(--c-x15) 356deg 360deg
    );
}

/* On cache les lignes de s√©paration pour un look ultra lisse (z√©ro moir√©) */
.mw-dividers { display: none; }

.mw-labels { position: absolute; inset: 0; z-index: 10; }

.mw-lbl {
    position: absolute; top: 0; left: 50%; width: 40px; height: 50%;
    margin-left: -20px; padding-top: 8px;
    transform-origin: bottom center;
    display: flex; justify-content: center;
    font-family: 'Orbitron'; font-weight: 900; 
    color: #fff;
    /* Ombre noire hyper agressive pour d√©tourer le texte */
    text-shadow: 0 1px 3px #000, 0 0 8px #000, 0 0 15px #000;
}

/* Tailles de texte calcul√©es pour ne pas se chevaucher */
.l-x2  { transform: rotate(90deg); font-size: 20px; }
.l-x4  { transform: rotate(225deg); font-size: 16px; }
.l-x6  { transform: rotate(297deg); font-size: 14px; }
.l-x8  { transform: rotate(336.5deg); font-size: 12px; }
.l-x10 { transform: rotate(352.5deg); font-size: 10px; color: #fff; }
.l-x15 { transform: rotate(358deg); font-size: 9px; color: #fff; }

/* Le Coeur R√©acteur */
.center-hub {
    position: absolute; top: 50%; left: 50%;
    width: 44px; height: 44px;
    transform: translate(-50%, -50%);
    background: #0a0a10; border-radius: 50%; z-index: 20;
    border: 3px solid #222;
    display: flex; align-items: center; justify-content: center;
    box-shadow: 0 0 20px #000;
}
.hub-inner {
    width: 20px; height: 20px; border-radius: 50%;
    background: #00ffcc;
    box-shadow: 0 0 15px #00ffcc, inset 0 0 5px #fff;
    animation: hubPulse 2s infinite alternate;
}

@keyframes hubPulse { 
    from { transform: scale(0.8); filter: brightness(0.8); } 
    to { transform: scale(1.1); filter: brightness(1.2); } 
}

/* Texte du bas discret */
.multi-result-text {
    margin-top: 15px; /* Tr√®s r√©duit */
    font-family: 'Orbitron'; font-size: 16px; /* Taille r√©duite */
    font-weight: 900; 
    color: #fff; min-height: 20px; text-align: center;
}

/* Flou de rotation uniquement sur le fond, pas sur le texte ! */
.neon-wheel.spinning .mw-segments {
    filter: blur(2px);
    transition: filter 0.5s;
}
.neon-wheel.spinning .mw-labels { filter: none !important; }
</style>

</head>
<body>



<audio id="sfxDeath" src="audio/death.mp3" preload="auto"></audio>
<audio id="sfxIntro" src="audio/intro_burst.mp3" preload="auto"></audio>
<audio id="sfxOverdrive" src="audio/overdrive_start.mp3" preload="auto"></audio>

 <div id="overlayIntro">
    <canvas id="introEmbers"></canvas>
    <div class="introContent">
      <div id="introLogo" class="introHero">
        <img src="./assets/MJLogo.png" alt="Logo"> 
      </div>
      <div class="introHint">TAP TO START</div>
    </div>
  </div>

  <div id="transitionLoader">
    <div class="loader-content">
      <div class="loader-glitch" data-text="SYSTEM BOOT">SYSTEM BOOT</div>
      <div class="loader-bar-wrap">
        <div id="transBar"></div>
      </div>
      <div class="loader-data">
        <span id="transText">INITIALIZING...</span>
        <span id="transPct">0%</span>
      </div>
    </div>
  </div>
  
  <div id="inputBlocker"></div>

  <div id="menuOverlay">
    <canvas id="galaxyBG"></canvas>
    <div class="menuParticles"></div>
    <video id="menuVideo" muted loop playsinline preload="none" data-src="./assets/menu_bg.mp4"></video>

    <div id="menuStats">
      <div class="statBox best">
        <div class="statLabel">BEST</div>
        <div class="statValue" id="menuBest">0</div>
      </div>
      <div class="statBox coins">
        <div class="statLabel">COINS</div>
        <div class="statValue" id="menuCoins">0</div>
      </div>
    </div>

    <div id="menuButtons">
      <button id="btnPlay" class="menuBtn">PLAY</button>
      <button id="btnShop" class="menuBtn">SKIN SHOP</button>
      <button id="btnOptions" class="menuBtn">SETTINGS</button>
      
      <button onclick="openRoulette()" class="menuBtn" style="margin-top:15px; background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,140,0,0.15)); border-color: #ffd700; color: #ffd700; box-shadow: 0 0 20px rgba(255,215,0,0.2);">
        üé∞ LUCKY SPIN <span id="rouletteStatus" style="font-size:10px; opacity:0.8; margin-left:5px;"></span>
      </button>
    </div>

    <div id="shopPanel"></div>

<div id="roulettePopup" style="display:none; position:fixed; inset:0; width:100vw; height:100vh; background:rgba(5, 10, 20, 0.95); z-index:3000; flex-direction:column; align-items:center; justify-content:center; backdrop-filter: blur(8px);">
        
        <div style="display:flex; flex-direction:column; align-items:center; transform: scale(var(--ui-scale, 1)); transform-origin: center center;">
            
            <div style="font-family:Orbitron, sans-serif; font-size:26px; font-weight:900; color:#00f0ff; margin-bottom: 15px; text-shadow:0 0 10px #00f0ff, 0 0 20px #0080ff; letter-spacing: 2px;">LUCKY SPIN</div>
            
            <div style="position:relative; width:200px; height:200px; flex-shrink:0;">
                
                <div style="position:absolute; top:-15px; left:50%; transform:translateX(-50%); z-index:20; filter:drop-shadow(0 0 5px #00f0ff);">
                    <div style="width:0; height:0; border-left:10px solid transparent; border-right:10px solid transparent; border-top:20px solid #fff;"></div>
                    <div style="width:0; height:0; border-left:6px solid transparent; border-right:6px solid transparent; border-top:12px solid #00f0ff; position:absolute; top:-2px; left:4px;"></div>
                </div>

                <div id="wheel" style="position:absolute; inset:0; border-radius:50%; overflow:hidden; border: 4px solid #fff; box-shadow: 0 0 20px rgba(0, 240, 255, 0.5), inset 0 0 15px rgba(0,0,0,0.8); transition: transform 6s cubic-bezier(0.1, 0.85, 0.1, 1); background: conic-gradient(
                    #e74c3c 0deg 60deg,    /* 20 */
                    #95a5a6 60deg 120deg,  /* 40 */
                    #2ecc71 120deg 180deg, /* 80 */
                    #3498db 180deg 240deg, /* 150 */
                    #9b59b6 240deg 300deg, /* 300 */
                    #f1c40f 300deg 360deg  /* 1000 */
                );">
                    
                    <style>
                        .wheel-val {
                            position: absolute; top: 0; left: 50%;
                            width: 60px; height: 50%; margin-left: -30px;
                            transform-origin: bottom center;
                            display: flex; justify-content: center; align-items: flex-start;
                            padding-top: 8px; z-index: 5;
                            font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: 900;
                            color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8);
                        }
                    </style>
                    <div class="wheel-val" style="transform: rotate(30deg);">20</div>
                    <div class="wheel-val" style="transform: rotate(90deg);">40</div>
                    <div class="wheel-val" style="transform: rotate(150deg);">80</div>
                    <div class="wheel-val" style="transform: rotate(210deg);">150</div>
                    <div class="wheel-val" style="transform: rotate(270deg);">300</div>
                    <div class="wheel-val" style="transform: rotate(330deg); color:#ffd700; text-shadow:0 0 8px #ff8c00; font-size:18px;">1000</div>
                    
                    <div style="position:absolute; inset:0; background:radial-gradient(circle at center, transparent 35%, rgba(0,0,0,0.7) 100%); pointer-events:none; z-index:2;"></div>
                </div>

                <div style="position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:40px; height:40px; background:#111; border-radius:50%; border:3px solid #00f0ff; box-shadow: 0 0 10px rgba(0,240,255,0.8); z-index:15; display:flex; align-items:center; justify-content:center;">
                    <div style="width:12px; height:12px; border-radius:50%; background:#fff; box-shadow:0 0 8px #fff;"></div>
                </div>
            </div>

            <div id="rouletteResult" style="margin-top:15px; font-family:Orbitron; font-weight:900; font-size:18px; color:#00f0ff; height:25px; text-shadow: 0 0 10px rgba(0,240,255,0.6);"></div>

            <div style="display:flex; gap:10px; margin-top:15px;">
                <button onclick="closeRoulette()" class="menuBtn" style="min-width:90px; padding:10px 0; background:rgba(255,0,0,0.1); border-color:#ff4444; color:#ff4444; box-shadow:none; font-size:12px;">LEAVE</button>
                <button id="spinBtn" onclick="trySpin()" class="menuBtn" style="min-width:140px; padding:10px 0; background:linear-gradient(135deg, #00f0ff, #0080ff); color:#000; border:none; box-shadow:0 0 15px rgba(0,240,255,0.5); font-size:14px; text-shadow:none;">SPIN</button>
            </div>
        </div>
    </div>
  </div>

  <div id="optionsPanel">
    <div class="optionsBox">
      <h2>SETTINGS</h2>
      <div class="optRow">
        <label>üéµ Music</label>
        <input id="optMusic" type="range" min="0" max="100">
      </div>
      <div class="optRow">
        <label>üîä Effects</label>
        <input id="optSfx" type="range" min="0" max="100">
      </div>
      <div class="optRow">
        <label><input id="optMute" type="checkbox"> üîá Mute</label>
      </div>
      <button id="optBack" class="menuBtn">BACK</button>
    </div>
  </div>

  <div id="gameContainer">
    <canvas id="game" width="720" height="405"></canvas>

    <div id="uiLayer">
      </div>
    <div id="touchZone" style="position:absolute; inset:0; z-index:10;"></div>

    <div id="uiCoins">
      <div class="coinIcon"></div> <div class="coinValue" id="coinCount">0</div>
    </div>

    <div id="ui">
      <div id="uiScore">0</div>
    </div>

    <div id="overdriveMeter">
      <div id="overdriveLabel">BOOST</div>
      <div id="overdriveBarOuter">
        <div id="overdriveBarInner"></div>
      </div>
    </div>

    <div id="combo">x<span id="comboVal">1</span></div>

    <div id="continuePopup">
      <div class="revive-card">
        <div class="revive-header">‚ö†Ô∏è SYSTEM FAILURE ‚ö†Ô∏è</div>
        <div class="revive-sub">WATCH AD STREAM TO REBOOT SYSTEM?</div>
        
        <div class="revive-visual">
          <div class="revive-pulse-ring"></div>
          <div class="revive-icon">‚ù§Ô∏è</div>
        </div>

        <button id="continueAdBtn" class="revive-btn">
          <span class="btn-glitch"></span>
          <span class="btn-txt">üì∫ WATCH AD & REVIVE</span>
        </button>

        <div class="revive-timer-track">
          <div id="continueBar"></div>
        </div>
        
        <div id="btnSkip" class="revive-skip">SKIP</div>
      </div>
    </div>

    <div id="overlayGameOver">
      <div class="gameOverCard">
        <div id="newRecord" style="font-size:48px; font-weight:900; color:#ffd700; text-shadow:0 0 25px #ffea00; opacity:0; transform:scale(0.6); transition:opacity .5s, transform .5s; display:none;">
          NEW RECORD !
        </div>

        <h2 class="gameOverTitle">Game Over !</h2>

        <div class="gameOverStats">
          <p>Score <span id="finalScore">0</span></p>
          <p>Best Score <span id="finalBest">0</span></p>
          <p>Coins <span id="finalCoins">0</span></p>
        </div>

        <style>
            @keyframes multiPulse {
                0% { transform: scale(1); box-shadow: 0 0 10px rgba(255, 60, 0, 0.4); }
                50% { transform: scale(1.05); box-shadow: 0 0 25px rgba(255, 60, 0, 0.8); }
                100% { transform: scale(1); box-shadow: 0 0 10px rgba(255, 60, 0, 0.4); }
            }
        </style>
<button id="multiplyBtn" onclick="startMultiplierSpin()" 
    style="width:100%; padding:8px; margin-bottom:10px; font-family:Orbitron; font-size:14px; font-weight:900; background:linear-gradient(to right, #642B73, #C6426E); color:#fff; border:none; border-radius:4px; cursor:pointer; display:none; flex-direction:column; align-items:center;">
    <span>üíé MULTIPLY COINS</span>
    <span style="font-size:9px; opacity:0.8; font-weight:400; margin-top:2px;">( WATCH VIDEO TO SPIN )</span>
</button>

        <div class="gameOverActions">
          <button id="restartBtn" class="bigButton">Play Again</button>
          <button id="menuBtn" class="bigButton">Main Menu</button>
        </div>
      </div>
    </div>

 <div id="multiplierPopup" style="display:none;">
    <div class="multi-container">
        <div class="multi-title">PRISM MULTIPLIER</div>
        
        <div class="wheel-wrapper-outer">
            <div class="laser-pointer"></div>
            <div class="wheel-wrapper-inner">
                <div id="multiWheel" class="neon-wheel">
                    <div class="mw-segments"></div>
                    <div class="mw-dividers"></div>
                    <div class="mw-labels">
                        <div class="mw-lbl l-x2">x2</div>
                        <div class="mw-lbl l-x4">x4</div>
                        <div class="mw-lbl l-x6">x6</div>
                        <div class="mw-lbl l-x8">x8</div>
                        <div class="mw-lbl l-x10">x10</div>
                        <div class="mw-lbl l-x15">x15</div>
                    </div>
                </div>
            </div>
            <div class="center-hub"><div class="hub-inner"></div></div>
        </div>
        
        <div id="multiResult" class="multi-result-text">READY?</div>
    </div>
</div>

  </div>


</body>
<script>
/* =========================================================
   GLOBAL STATE ‚Äî SAFE BOOTSTRAP
========================================================= */
let continueInterval = null;
// ================= GAME CORE =================
let gameState = "intro";
let gameRunning = true; // üî• UNIQUE source de v√©rit√© (NE PAS red√©clarer ailleurs)
// √©tats globaux
let loopStarted = false;
let accTime   = 0;
let drawAcc  = 0;
let fxTick   = 0;
let lastTS   = 0;
const RestartActivity =
  window.Capacitor &&
  window.Capacitor.Plugins &&
  window.Capacitor.Plugins.RestartActivity;

// Variable de s√©curit√© pour la transition
let isTransitioning = false;
let equippedSkin = "moony";
// ================= TRAIL TIMING =================
let lastMenuEnterTS = 0;

let skinId = localStorage.getItem("currentSkin") || "solar";
let t = 0; // temps global logique
let gameOverTriggered = false;
let isTouch = false;
let noiseCanvas = null;
let moonyExpr = 0;
let lastFrameTime = performance.now();
let worstDelta = 0;
let lastOverdrivePct = -1;
let reviveInvincible = false;
let reviveInvTimer = 0;
let overdriveEndingFlag = false;
// =========================================================
// 1. BACKGROUND & INIT CANVAS
// =========================================================
const bgCanvas = document.createElement("canvas");
const bgCtx = bgCanvas.getContext("2d");

let canvas = null;
let ctx = null;

function bindCanvas(){
  canvas = document.getElementById("game");
  if (!canvas) throw new Error("Canvas #game introuvable");
  
  // Optimisation : alpha false pour perf, desynchronized pour fluidit√© tactile
  ctx = canvas.getContext("2d", { alpha: false, desynchronized: true });
  if (!ctx) throw new Error("Contexte 2D impossible");

  // Configuration Qualit√©
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
}

// =========================================================
// 2. WORLD / CAMERA & CONSTANTES
// =========================================================
const BASE_W = 810;
const BASE_H = 405;

// Variables Legacy (Compatibilit√© avec ton gameplay existant)
let OFF_X = 0;
let OFF_Y = 0;
let VIEW_W = BASE_W;
let VIEW_H = BASE_H;

// Variables Syst√®me
let bgScroll = 0;
let currentScale = 1;
let currentDPR   = 1;

let cameraScale   = 1;
let cameraOffsetX = 0;
let cameraOffsetY = 0;

// Globales Safe Area (Pour le Player)
window.SAFE_TOP = 0;
window.SAFE_BOTTOM = BASE_H;

function resizeCanvas(){
  if (!canvas) bindCanvas();
  if (!canvas || !ctx) return;

  // 1. R√©cup√©ration Dimensions √âcran
  // On utilise visualViewport si dispo pour √©viter les bugs de clavier/barres
  const vv = window.visualViewport;
  const w = (vv && vv.width) ? vv.width : window.innerWidth;
  const h = (vv && vv.height) ? vv.height : window.innerHeight;
  
  // 2. DPI & Canvas Physique
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  currentDPR = dpr;

  const cw = Math.round(w * dpr);
  const ch = Math.round(h * dpr);

  if (canvas.width !== cw || canvas.height !== ch) {
    canvas.width = cw;
    canvas.height = ch;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr); // On applique le DPI
  }

  canvas.style.width = w + "px";
  canvas.style.height = h + "px";

  // 3. CALCUL DU SCALE DE JEU (GAMEPLAY)
  // Base 810x405 (Ratio 2:1)
  const ratioX = w / BASE_W;
  const ratioY = h / BASE_H;
  
  // "Contain" : On prend le ratio qui permet de tout voir sans couper
  let gameScale = Math.min(ratioX, ratioY);

  // Correction Tablette (√©viter que les pixels soient √©normes)
  if (w > 1000 && gameScale > 1.8) gameScale = 1.8;

  cameraScale = gameScale;
  currentScale = gameScale;

  // Centrage (Letterboxing virtuel)
  cameraOffsetX = (w - BASE_W * cameraScale) / 2;
  cameraOffsetY = (h - BASE_H * cameraScale) / 2;

  OFF_X = cameraOffsetX;
  OFF_Y = cameraOffsetY;
  VIEW_W = w / cameraScale;
  VIEW_H = h / cameraScale; // Important pour le spawn

  // 4. CALCUL DU SCALE UI (C'est l√† que tout se joue !)
  // Si l'√©cran est "√©troit" (ratio < 1.9, ex: 16:9 classique), on r√©duit l'UI
  // pour √©viter l'effet "zoom√©"
  const screenRatio = w / h;
  let targetUiScale = gameScale;

  if (screenRatio < 1.9) {
      // √âcran "Carr√©" ou 16:9 : On r√©duit l'√©chelle UI de 15% par rapport au jeu
      targetUiScale = gameScale * 0.85; 
  }

  // On clamp pour rester lisible (ni minuscule, ni g√©ant)
  const uiScale = Math.min(Math.max(targetUiScale, 0.50), 1.1);
  
  // On applique la variable CSS
  document.documentElement.style.setProperty('--ui-scale', uiScale);
}
// Listeners
window.addEventListener("resize", resizeCanvas, { passive:true });
if (window.visualViewport) {
  window.visualViewport.addEventListener("resize", resizeCanvas, { passive:true });
}

// Premier appel pour tout caler
resizeCanvas();

// =========================================================
// 4. UI REFERENCES (SAFE INIT)
// =========================================================

const UI = {
  score: null, best: null, coins: null, 
  combo: null, overCount: null, overFill: null
};

let uiBound = false;

function bindUI(){
  if (uiBound) return;
  uiBound = true;

  UI.score     = document.getElementById("uiScore")        || null;
  UI.best      = document.getElementById("uiBest")         || null;
  UI.coins     = document.getElementById("coinCount")      || null;
  UI.combo     = document.getElementById("comboVal")       || null;
  UI.overCount = document.getElementById("overdriveCount") || null;
  UI.overFill  = document.getElementById("overdriveBarInner") || null;
}

function safeText(el, value){
  if (el) el.textContent = value;
}

// ================= PATH CACHES (iOS SAFE) =================
const _arcPathCache  = new Map();
const _rectPathCache = new Map();

// ================= FRAME / FX =================
let frameCount = 0;
let fxCalm = 1;

const OVERDRIVE_CALM = {
  glow: 0.65,
  blur: 0.6,
  alpha: 0.7
};

// --- GLOBAL SPAWN VARIABLES ---
let lastSpawnTime = 0;
let lastBarTime   = 0;

// --- LOGIQUE DE CHEMIN FAISABLE ---
// --- CONFIG ---
const SPAWN_MARGIN_X = 100; // Distance off-screen where things spawn
/* =========================================================
   FX QUALITY MANAGER ‚Äî SINGLE INSTANCE
========================================================= */

const FXQuality = (() => {

  let tier = 2; // 0..3
  let scene = "game";
  let forceTier = null;

  let lastT = 0;
  let emaDt = 16.67;
  let emaFps = 60;
  const alpha = 0.08;

  let cooldown = 0;
  const UP_COOLDOWN = 0.9;

  const isMobile =
    (typeof navigator !== "undefined" &&
     /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent)) ||
    (typeof matchMedia !== "undefined" &&
     matchMedia("(pointer: coarse)").matches);

  function setScene(s){
    scene = s || "game";
  }

  function setForceTier(v){
    forceTier = (v === 0 || v === 1 || v === 2 || v === 3) ? v : null;
  }

  function update(ts){
    if (!lastT){
      lastT = ts;
      return;
    }

    const dt = ts - lastT;
    lastT = ts;
    if (dt > 1200) return;

    emaDt  += (dt - emaDt) * alpha;
    emaFps  = 1000 / Math.max(1, emaDt);

    if (forceTier !== null){
      tier = forceTier;
      return;
    }

    let down45 = 48, down35 = 38, up55 = 57, up60 = 61;

    if (scene === "menu"){
      down45 = 43; down35 = 33; up55 = 53; up60 = 58;
    } else if (scene === "shop"){
      down45 = 46; down35 = 36; up55 = 56; up60 = 60;
    }

    if (isMobile){
      up60 -= 6;
      up55 -= 4;
      down45 += 1;
      down35 += 1;
    }

    if (cooldown > 0){
      cooldown -= dt * 0.001;
    }

    if (emaFps < down35){
      tier = Math.max(0, tier - 2);
      cooldown = UP_COOLDOWN;
      return;
    }

    if (emaFps < down45){
      tier = Math.max(0, tier - 1);
      cooldown = UP_COOLDOWN;
      return;
    }

    if (cooldown <= 0){
      if (emaFps > up60){
        tier = Math.min(3, tier + 1);
      } else if (emaFps > up55 && tier < 2){
        tier = Math.min(2, tier + 1);
      }
    }
  }

  function q(){ return tier; }
  function fps(){ return emaFps; }

  function scaleCount(base, minFactor = 0.35){
    const f = tier === 3 ? 1 : tier === 2 ? 0.85 : tier === 1 ? 0.65 : 0.45;
    return Math.max(1, Math.round(base * Math.max(minFactor, f)));
  }

  function scaleAlpha(base){
    const f = tier === 3 ? 1 : tier === 2 ? 0.92 : tier === 1 ? 0.78 : 0.65;
    return base * f;
  }

  function allowHeavy(){
    if (tier === 0) return false;
    if (tier === 1 && scene === "shop") return false;
    return true;
  }

  return {
    update,
    setScene,
    setForceTier,
    q,
    fps,
    isMobile,
    scaleCount,
    scaleAlpha,
    allowHeavy
  };

})();

// ================= GLOBAL FX FLAGS =================
const IS_MOBILE = FXQuality.isMobile;
const USE_PATH  = !IS_MOBILE;

// üîí mobile = LOW forc√© (une seule fois)
if (IS_MOBILE){
  FXQuality.setForceTier(0);
}



/* =========================================================
   üéûÔ∏è VIDEO MANAGER (HELPER FOR UI STATE)
========================================================= */

// ================= MENU VIDEO CONTROL =================
const menuVideo = document.getElementById("menuVideo");

/* Note : Les fonctions showMenu() et hideMenu() sont supprim√©es 
   car elles sont d√©sormais g√©r√©es int√©gralement par setUIState() */

// ================= VIDEO WARMUP (iOS SAFE) =================
function warmupMenuVideo(){
  if (!menuVideo || menuVideoWarmed) return;

  try {
    menuVideo.style.visibility = "hidden";
    menuVideo.currentTime = 0;

    menuVideo.play().then(() => {
      setTimeout(() => {
        try {
          menuVideo.pause();
          menuVideo.currentTime = 0;
          menuVideo.style.visibility = "visible";

          menuVideo.loop = true;
          menuVideo.play().catch(()=>{});
          menuVideoWarmed = true;
        } catch(e){}
      }, 300);
    }).catch(()=>{});
  } catch(e){}
}

// =========================================================
// FX STATE (SINGLE SOURCE)
// =========================================================

const FX = {
  level: 1,
  preview: false,
  overdrive: false,
  intensity: 1
};

function updateFXState(){
  if (typeof uiState !== "undefined" && uiState === "shop"){
    FX.preview   = true;
    FX.overdrive = false;
    FX.level     = 0;
    FX.intensity = 0.3;
    return;
  }

  FX.preview = false;

  if (gameState === "playing"){
    FX.overdrive = document.body.classList.contains("overdriveActive");
    FX.level     = FX.overdrive ? 2 : 1;
    FX.intensity = FX.overdrive ? 1 : 0.6;
    return;
  }

  FX.level = 0;
  FX.intensity = 0;
  FX.overdrive = false;
}

function updateFXCalm(delta){
  if (delta > 20){
    fxCalm = Math.max(0.55, fxCalm - 0.08);
  } else {
    fxCalm = Math.min(1, fxCalm + 0.05);
  }
}



// =========================================================
// üëÜ INPUT ZONE (OPTIMIS√â & R√âACTIF)
// =========================================================
const touchZone = document.getElementById("touchZone");

if (touchZone){

  // D√©tection tactile (Optimisation passive)
  window.addEventListener("touchstart", () => {
    isTouch = true;
  }, { once:true, passive:true });

  // --- PRESS (Voler) ---
  touchZone.addEventListener("pointerdown", (e) => {
    // V√©rification de l'√©tat du jeu (doit √™tre d√©fini ailleurs, ex: 'playing')
    if (typeof uiState !== 'undefined' && uiState !== "playing") return;

    if (e.cancelable) e.preventDefault();
    
    // Capture le pointeur pour ne pas le perdre si on glisse hors de l'√©cran
    try {
        touchZone.setPointerCapture(e.pointerId);
    } catch(err){}

    // Appel de ta fonction de saut
    if (typeof jetStart === 'function') jetStart();
  });

  // --- RELEASE (Tomber) ---
  function stopJet(e){
    if (typeof uiState !== 'undefined' && uiState !== "playing") return;
    
    if (typeof jetStop === 'function') jetStop();
    
    try {
       touchZone.releasePointerCapture(e.pointerId);
    } catch(err){}
  }

  touchZone.addEventListener("pointerup", stopJet);
  touchZone.addEventListener("pointercancel", stopJet);
  touchZone.addEventListener("pointerleave", stopJet);
}




/* =========================================================
   üîä AUDIO MANAGER V18 (FINAL - RAM BUFFERING & MUTE FIX)
   - Charge le son en RAM (Anti-coupure Android)
   - Gestion du volume via GainNodes (Mute instantan√©)
========================================================= */

const sfxDeath = document.getElementById("sfxDeath");
const sfxOverdrive = document.getElementById("sfxOverdrive");
const sfxIntro = document.getElementById("sfxIntro");

// --- CONTEXTE AUDIO ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx = new AudioContext();

// --- CONFIGURATION ---
const audioSettings = JSON.parse(localStorage.getItem("audioSettings") || "null") 
      || { music: 70, sfx: 80, mute: false };

let currentMusicState = "none";
let audioUnlocked = false;

// STOCKE LES SONS EN RAM ICI
const SOUNDS = {
    menu: { buffer: null, source: null, gainNode: null, url: 'audio/Menu.mp3' },
    game: { buffer: null, source: null, gainNode: null, url: 'audio/musicgame.mp3' }
};

// --- 1. LE CHARGEUR RAM ---
async function loadSoundToRAM(key) {
    try {
        const response = await fetch(SOUNDS[key].url);
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        SOUNDS[key].buffer = audioBuffer;
        console.log(`‚úÖ ${key} charg√© en RAM`);
    } catch (e) {
        console.error(`‚ùå Erreur chargement ${key}:`, e);
    }
}

// Chargement initial
loadSoundToRAM('menu');
loadSoundToRAM('game');

// --- 2. LE LECTEUR DE BUFFER (AVEC GESTION MUTE) ---
function playBuffer(key, volumeTarget) {
    const sound = SOUNDS[key];
    if (!sound.buffer) return; 

    // Stop ancienne instance
    stopBuffer(key);

    // Cr√©ation Source & Gain
    const source = audioCtx.createBufferSource();
    source.buffer = sound.buffer;
    source.loop = true;

    const gainNode = audioCtx.createGain();
    
    // üõ°Ô∏è FIX MUTE CRITIQUE : On v√©rifie le mute AVANT de donner le volume
    // Si mute est coch√©, le volume de d√©part EST Z√âRO.
    const startVol = audioSettings.mute ? 0 : volumeTarget;
    gainNode.gain.value = startVol; 
    
    // Connexions
    source.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    source.start(0);
    
    // Sauvegarde des r√©f√©rences
    sound.source = source;
    sound.gainNode = gainNode;
}

function stopBuffer(key) {
    const sound = SOUNDS[key];
    if (sound.source) {
        try { 
            // Fade out rapide
            if(sound.gainNode) {
                sound.gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            }
            setTimeout(() => {
                if(sound.source) sound.source.stop();
                sound.source = null;
                sound.gainNode = null;
            }, 150);
        } catch(e){}
    }
}

// --- 3. FONCTION PRINCIPALE (PLAY MUSIC) ---
function playMusic(which) {
    if (currentMusicState === which) return;
    currentMusicState = which;

    // Volume de base (sans prendre en compte le mute ici, c'est g√©r√© dans playBuffer)
    const vol = Math.max(0, Math.min(1, audioSettings?.music / 100 || 0.6));

    if (audioCtx.state === 'suspended') audioCtx.resume();

    if (which === "game") {
        stopBuffer('menu');
        playBuffer('game', vol);
    } 
    else if (which === "menu") {
        stopBuffer('game');
        playBuffer('menu', vol * 0.9);
    } 
    else {
        stopBuffer('menu');
        stopBuffer('game');
        currentMusicState = "none";
    }
}

// --- 4. SFX (Compatible Mute) ---
function playSFX(originalTrack, volumeScale = 1.0) {
    // Si MUTE est activ√©, on ne joue rien du tout
    if (!originalTrack || audioSettings.mute) return;
    
    if (audioCtx.state === 'suspended') audioCtx.resume();

    const clone = originalTrack.cloneNode();
    clone.volume = Math.max(0, Math.min(1, (audioSettings.sfx / 100) * volumeScale));
    clone.play().catch(()=>{});
    clone.onended = () => clone.remove();
}

function stopMusic() { playMusic("none"); }

/* =========================
   LISTENERS UI (MUTE INSTANTAN√â)
========================= */
const optMusic = document.getElementById("optMusic");
const optSfx   = document.getElementById("optSfx");
const optMute  = document.getElementById("optMute");

// Fonction Ma√Ætre du Volume
function applyAudioSettings() {
    // Si mute coch√©, volume cible = 0. Sinon, volume du slider.
    const vol = audioSettings.mute ? 0 : (audioSettings.music / 100);
    
    // On applique imm√©diatement aux musiques en cours
    if (SOUNDS.menu.gainNode) {
        SOUNDS.menu.gainNode.gain.setTargetAtTime(vol * 0.9, audioCtx.currentTime, 0.05);
    }
    if (SOUNDS.game.gainNode) {
        SOUNDS.game.gainNode.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.05);
    }
}

if (optMusic && optSfx && optMute) {
    optMusic.value = audioSettings.music;
    optSfx.value = audioSettings.sfx;
    optMute.checked = audioSettings.mute;

    optMusic.addEventListener("input", () => {
        audioSettings.music = +optMusic.value;
        localStorage.setItem("audioSettings", JSON.stringify(audioSettings));
        applyAudioSettings(); // Mise √† jour live
    });

    optSfx.addEventListener("input", () => {
        audioSettings.sfx = +optSfx.value;
        localStorage.setItem("audioSettings", JSON.stringify(audioSettings));
    });

    optMute.addEventListener("change", () => {
        audioSettings.mute = optMute.checked;
        localStorage.setItem("audioSettings", JSON.stringify(audioSettings));
        
        // Mute Physique (Coupe tout imm√©diatement)
        if (audioSettings.mute) {
            if (SOUNDS.menu.gainNode) SOUNDS.menu.gainNode.gain.value = 0;
            if (SOUNDS.game.gainNode) SOUNDS.game.gainNode.gain.value = 0;
        } else {
            // Unmute : On r√©tablit le volume
            applyAudioSettings();
            
            // Relance s√©curit√© si le moteur s'est endormi
            if (currentMusicState !== "none" && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }
    });
}

function unlockAllAudio() {
  if (audioUnlocked) return;
  audioUnlocked = true;
  if (audioCtx.state === 'suspended') audioCtx.resume();
  [sfxDeath, sfxIntro, sfxOverdrive].forEach(snd => { if(snd) snd.load(); });
}

document.addEventListener("visibilitychange", () => {
    if (document.hidden) {
        // L'app passe en arri√®re-plan (Pub, SMS, Verrouillage)
        audioCtx.suspend();
        if (gameRunning) {
            window._wasRunning = true;
            stopLoop(); // Coupe le moteur proprement
        }
    } else {
        // L'app revient au premier plan
        audioCtx.resume();
        if (window._wasRunning) {
            window._wasRunning = false;
            // startLoop() contient d√©j√† "lastTS = 0" ce qui emp√™che le saut temporel !
            startLoop(); 
        }
    }
});
/* =========================================
   CINEMATIC INTRO TRANSITION (CLEAN)
========================================= */
function playIntroTransition() {
  const intro = document.getElementById("overlayIntro");
  const loader = document.getElementById("transitionLoader");
  const bar = document.getElementById("transBar");
  const txt = document.getElementById("transText");
  const pct = document.getElementById("transPct");

  console.log("üöÄ Lancement Transition...");

  // 1. VERROUILLAGE & AUDIO
  isTransitioning = true; 
  if (typeof unlockAllAudio === "function") unlockAllAudio();
  
  // Le SFX ne se jouera QUE si mute est false (g√©r√© par playSFX)
  if (typeof playSFX === "function" && sfxIntro) playSFX(sfxIntro, 0.8);

  // 2. SWAP VISUEL
  if (intro) {
      intro.style.opacity = "0";
      intro.style.pointerEvents = "none";
      setTimeout(() => { intro.style.display = "none"; }, 300);
  }
  
  if (loader) {
    loader.style.display = "flex"; 
    loader.style.zIndex = "2147483647";
    void loader.offsetWidth; // Force Reflow
    loader.style.opacity = "1";
    loader.classList.add("active");
  }

  // 3. ANIMATION
  let progress = 0;
  const duration = 1600; 
  const startTime = performance.now();
  let techInitialized = false;

  function updateLoad(now) {
    const elapsed = now - startTime;
    progress = Math.min(100, (elapsed / duration) * 100);

    if (bar) bar.style.width = progress + "%";
    if (pct) pct.textContent = Math.floor(progress) + "%";

    if (progress < 30) {
        if(txt) txt.textContent = "LOADING ASSETS...";
    } else if (progress < 60) {
        if(txt) txt.textContent = "CONNECTING SERVER...";
        if (!techInitialized) {
            techInitialized = true;
            if (typeof resizeCanvas === "function") resizeCanvas();
            if (typeof updateMenuStats === "function") updateMenuStats();
        }
    } else if (progress < 90) {
        if(txt) txt.textContent = "CALIBRATING ENGINE...";
    } else {
        if(txt) txt.textContent = "SYSTEM READY.";
    }

    if (progress < 100) {
      requestAnimationFrame(updateLoad);
    } else {
      // 4. FIN
      setTimeout(() => {
        isTransitioning = false;
        if (typeof setUIState === "function") setUIState("menu");

        if (loader) {
            loader.style.opacity = "0";
            setTimeout(() => { 
                loader.style.display = "none"; 
                loader.classList.remove("active");
            }, 500);
        }
      }, 200);
    }
  }

  requestAnimationFrame(updateLoad);
}
/* =========================================
   üîò OVERLAY MANUEL "TAP TO SPIN"
========================================= */
function showTapToSpinOverlay(onSpinCallback) {
    // Supprime l'ancien s'il existe d√©j√†
    const oldOverlay = document.getElementById("spinReadyOverlay");
    if (oldOverlay) oldOverlay.remove();

    // Cr√©e le nouvel √©cran sombre
    const overlay = document.createElement("div");
    overlay.id = "spinReadyOverlay";
    overlay.style.cssText = `
        position: fixed; inset: 0; width: 100vw; height: 100vh;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: rgba(0,0,0,0.6); z-index: 99999; cursor: pointer; pointer-events: auto !important;
        backdrop-filter: blur(2px);
    `;
    
    // Le texte styl√© (en anglais)
    overlay.innerHTML = `
        <div style="font-family:Orbitron, sans-serif; font-size:40px; color:#00f0ff; text-shadow:0 0 15px cyan; margin-bottom:10px;">READY?</div>
        <div style="font-family:Rajdhani, sans-serif; font-size:24px; color:white; letter-spacing:2px; font-weight:bold; animation: blink 1s infinite;">TAP TO SPIN</div>
    `;

    document.body.appendChild(overlay);

    // L'action quand on clique
    const triggerSpin = (e) => {
        if (e) { e.preventDefault(); e.stopPropagation(); }
        overlay.remove(); // Enl√®ve l'√©cran
        if (onSpinCallback) onSpinCallback(); // Lance la roulette
    };

    overlay.onclick = triggerSpin;
    overlay.ontouchstart = triggerSpin;
}
/* =========================
   GAME OVER / CORE STATE
========================== */

// --- GAME OVER UI ---
const finalScoreEl = document.getElementById("finalScore");
const finalBestEl  = document.getElementById("finalBest");
const finalCoinsEl = document.getElementById("finalCoins");

// --- OVERLAYS ---
const overlayMenu     = document.getElementById("menuOverlay");
const overlayGameOver = document.getElementById("overlayGameOver");

// --- INPUT ---
const restartBtn = document.getElementById("restartBtn");

// --- OVERDRIVE UI ---
const OVERDRIVE_MAX = 20;
const overdriveBar     = document.getElementById("overdriveBarInner");
const overdriveCountEl = document.getElementById("overdriveCount");

// --- FX / HUD ---
const tint     = document.getElementById("tint");
const comboVal = document.getElementById("comboVal");

// --- MENUS / PANELS ---
const overlayIntro   = document.getElementById("overlayIntro");
const optionsPanelEl = document.getElementById("optionsPanel");
const transitionFX   = document.getElementById("transitionFX");


/* =========================
   UI SAFETY
========================= */

function safeStyle(el, prop, value){
  if (el) el.style[prop] = value;
}

/* =========================
   OVERDRIVE LOGIC
========================= */
function addOverdrive(amount){
  if (overdriveActive) return;

  overdrive += amount;

  if (overdrive >= OVERDRIVE_THRESHOLD){
    overdrive = 0;
    activateOverdrive();
  }

  updateOverdriveUI();
}

function activateOverdrive(){
  if (overdriveActive) return;
  overdriveEndingFlag = false;

  overdriveActive = true;
  overdriveTimer = overdriveDuration;

  document.body.classList.add("overdriveActive");
  document.body.classList.remove("overdriveEnding");

 if (!audioSettings.mute){
    playSFX(sfxOverdrive);
}
  }


function deactivateOverdrive(){
  overdriveActive = false;
  overdriveTimer = 0;
  overdrive = 0;

  document.body.classList.remove("overdriveActive");
  document.body.classList.remove("overdriveEnding");

  updateOverdriveUI();
}

function updateOverdriveUI(){
  if (overdriveActive) return;

  const ratio = Math.min(1, overdrive / OVERDRIVE_THRESHOLD);
  if (UI.overFill)  UI.overFill.style.height = (ratio * 100) + "%";
  if (UI.overCount) UI.overCount.textContent = Math.floor(overdrive);
}


/* =========================
   PERF MODE (FIXED)
========================= */
let PERF_MODE = "HIGH"; // HIGH | MED | LOW

function updatePerf(){
  const f = FXQuality.fps();
  if (f < 42) PERF_MODE = "LOW";
  else if (f < 55) PERF_MODE = "MED";
  else PERF_MODE = "HIGH";
}

/* =========================
   PLAYER / WORLD STATE
========================= */
const player = { x:100, y:BASE_H/2, width:36, height:32, vy:0 };
const BASE_PLAYER_W = 36;
const BASE_PLAYER_H = 32;

const GRAVITY = 0.42;
const THRUST  = -0.8;
let jetOn = false;

let obstacles = [];
let coins     = [];
let bullets   = [];

let obstacleSpeed = 3.8;
let lastSpawn = 0;
let score = 0;
// ================= PERF MEMORY (ANTI-LAG) =================
let _lastScore = -1;
let _lastCoins = -1;
let _lastCombo = -1;
let coinsCollected = 0;
let pendingCoins   = 0;

let newRecordThisRun = false;
/* =========================================================
   üíæ DATA & SKIN ENGINE V2 (ORDRE CORRIG√â)
========================================================= */

// 1. D'ABORD : ON CR√âE LES VARIABLES GLOBALES
// (Comme √ßa, Player peut les modifier sans planter)
let currentSkin = "moony";
let coinsBank = 0;
let bestScore = 0;

// 2. CONFIGURATION DES SKINS (PRIX √âQUILIBR√âS POUR MULTIPLICATEUR)
const SKINS_DB = {
  moony: { name: "Moony", category: "common", price: 0, trail: { color: "rgba(235,230,200,0.95)", glow: 6, size: 1.8, shape: "round" } },
  forest: { name: "Forest", category: "common", price: 800, trail: { color: "rgba(150,200,120,0.85)", glow: 6, size: 1.6, shape: "round" } },
  arctic: { name: "Arctic", category: "rare", price: 2500, trail: { color: "rgba(210,235,255,0.95)", glow: 8, size: 1.5, shape: "snow" } },
  solar: { name: "Solar", category: "rare", price: 2500, trail: { color: "rgba(255,200,80,0.95)", glow: 10, size: 1.9, shape: "spark" } },
  inferno: { name: "Inferno", category: "epic", price: 6500, trail: { color: "rgba(255,120,60,0.95)", glow: 14, size: 2.0, shape: "ember" } },
  neon: { name: "Neon", category: "epic", price: 8500, trail: { color: "rgba(0,255,255,0.95)", glow: 12, size: 1.6, shape: "line" } },
  voidwalker: { name: "Voidwalker", category: "legendary", price: 20000, trail: { color: "rgba(160,120,220,0.8)", glow: 16, size: 2.2, shape: "void" } }
};

const SKIN_KEYS = Object.keys(SKINS_DB);

// 3. FONCTION DE MISE √Ä JOUR UI
function updateCoinsUI(){
  // On met √† jour coinsBank depuis Player pour √™tre s√ªr
  if (typeof Player !== "undefined") coinsBank = Player.coins;
  
  ["menuCoins", "shopCoins", "shopTotalCoins", "finalCoins"].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.textContent = coinsBank.toLocaleString();
  });
}

// 4. √âTAT DU JOUEUR
let Player = {
  coins: 0, bestScore: 0, unlocked: ["moony"], equipped: "moony",    
  
  load: function(){
    try {
      this.coins = Number(localStorage.getItem("coinsBank") || 0);
      this.bestScore = Number(localStorage.getItem("bestScore") || 0);
      this.unlocked = JSON.parse(localStorage.getItem("ownedSkins") || '["moony"]');
      
      const savedEquip = localStorage.getItem("currentSkin");
      this.equipped = (savedEquip && SKINS_DB[savedEquip]) ? savedEquip : "moony";
      
      // MAINTENANT √áA MARCHE : Les variables existent d√©j√† !
      coinsBank = this.coins; 
      bestScore = this.bestScore; 
      currentSkin = this.equipped;
      
      updateCoinsUI();
    } catch(e){ console.warn("Save reset", e); }
  },
  
  save: function(){
    localStorage.setItem("coinsBank", this.coins);
    localStorage.setItem("bestScore", this.bestScore);
    localStorage.setItem("ownedSkins", JSON.stringify(this.unlocked));
    localStorage.setItem("currentSkin", this.equipped);
    
    coinsBank = this.coins; 
    bestScore = this.bestScore; 
    currentSkin = this.equipped;
    
    updateCoinsUI(); 
    if (typeof updateMenuStats === "function") updateMenuStats();
  },
  
  buy: function(skinId){
    const skin = SKINS_DB[skinId];
    if (!skin || this.coins < skin.price) return false;
    
    this.coins -= skin.price;
    if (!this.unlocked.includes(skinId)) this.unlocked.push(skinId);
    this.equipped = skinId; 
    
    this.save();
    return true;
  },
  
  equip: function(skinId){
    if (this.unlocked.includes(skinId)){
      this.equipped = skinId;
      this.save();
      return true;
    }
    return false;
  }
};

// 5. LANCEMENT (√Ä LA FIN)
Player.load();
// Variables globales de compatibilit√©

/* =========================
   OVERDRIVE / RUN STATE
========================= */
let overdriveActive = false;
let overdriveTimer  = 0;

const OVERDRIVE_DURATION_BASE = 3000;
let overdriveDuration = OVERDRIVE_DURATION_BASE;

const OVERDRIVE_THRESHOLD = 20;
let overdrive = 0; // charge actuelle

let dyingTimer = 0;
let dyingFromCircle = null;

let lastType = null;
let lastIntensity = 0;

// combo
let combo = 1;
let lastCoinTime = 0;

// FX collision
let particles = [];
let shake = 0;
let shockwave = null;
let bloom = null;
let deathOrigin = null; // {x,y}
let lastShakeX = 0;
let lastShakeY = 0;
/* =========================================================
   ENGINE v3.1 ‚Äî GOLD MASTER (COMPLETE)
   (Alignement parfait √† 60k + Respiration + Helpers)
========================================================= */

// --- CONFIGURATION UNIFI√âE (OPTION A: FLOW PUR) ---
const GLOBAL_CAP = 60000;

// 1. VITESSE
const SPEED_START = 1.1;
const SPEED_MAX   = 2.6; 

// 2. SPAWN (Intervalle)
const SPAWN_START = 1200;
const SPAWN_END   = 600; 

// 3. GAP (LARGEUR DES TROUS) ‚Äî MODE SERR√â
// Avant : 290 -> Maintenant : 210 (On attaque direct dans le dur)
const GAP_START = 180; 

// Avant : 195 -> Maintenant : 135 (Il faut fr√¥ler les murs)
const GAP_END   = 135;

// 4. MOUVEMENT VERTICAL
const MOVE_START = 0;
const MOVE_END   = 100;

/* =========================
   MATHS : COURBES LISS√âES
========================= */
function easeInOutQuad(x) {
  return x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2;
}

function getCurvedValue(score, startVal, endVal) {
  if (score <= 0) return startVal;
  if (score >= GLOBAL_CAP) return endVal;
  
  let pct = score / GLOBAL_CAP;
  pct = easeInOutQuad(pct);
  return startVal + (endVal - startVal) * pct;
}

/* =========================
   ACC√àS RAPIDES
========================= */
function paceMultiplier(score){
    if (score < 3000) return 1.0; 
    return getCurvedValue(score - 3000, SPEED_START, SPEED_MAX);
}

function currentSpawnInterval(score){
    if (score < 3000) return SPAWN_START;
    return getCurvedValue(score - 3000, SPAWN_START, SPAWN_END);
}

function movingAmplitude(score){
    if (score < 10000) return 0; 
    return getCurvedValue(score - 10000, MOVE_START, MOVE_END);
}

/* =========================
   GAP INTELLIGENT (BASE + WAVE LISS√âE)
========================= */
function getBaseGap(score){
    if (score < 3000) return GAP_START;
    
    let gap = getCurvedValue(score - 3000, GAP_START, GAP_END);

    const cycle = score % 7000;
    if (cycle < 2000) {
        const t = cycle / 2000; 
        const bonus = 40 * (1 - t); 
        gap += bonus;
    }
    return gap;
}

/* =========================
   PHASES & FR√âQUENCES
========================= */
function phase(score){
  if (score < 3000)  return 0;
  if (score < 12000) return 1;
  if (score < 30000) return 2;
  if (score < GLOBAL_CAP) return 3;
  return 4;
}

const FREQ = {
  0: { rotbar:0.00, circle:0.40, mover:0.00, sweeper:0.00, gap:0.60 },
  1: { rotbar:0.15, circle:0.25, mover:0.20, sweeper:0.05, gap:0.35 },
  2: { rotbar:0.25, circle:0.15, mover:0.30, sweeper:0.10, gap:0.20 },
  3: { rotbar:0.30, circle:0.10, mover:0.30, sweeper:0.15, gap:0.10 },
  4: { rotbar:0.35, mover:0.35, gap:0.10, sweeper:0.15, circle:0.05 } 
};
function currentFreq(score){ return FREQ[phase(score)]; }

/* =========================
   POIDS OBSTACLES (DENSIT√â)
========================= */
const OBSTACLE_WEIGHT = {
  gap:     0,
  circle:  1,
  mover:   1,
  sweeper: 1,
  rotbar:  2
};

/* =========================
   üöÄ HELPERS G√âN√âRAUX (LES REVOIL√Ä !)
========================= */
function randomRange(a, b) {
  return a + Math.random() * (b - a);
}

function clamp(v, a, b) {
  return Math.max(a, Math.min(b, v));
}

// Optionnel: calcul de probabilit√© pond√©r√©e si tu en as besoin
function pickWeighted(options) {
  const keys = Object.keys(options);
  const r = Math.random();
  let cumulative = 0;
  for (let key of keys) {
    cumulative += options[key];
    if (r <= cumulative) return key;
  }
  return keys[keys.length - 1];
}
/* =========================
   MONDE & CAMERA
========================= */
const WORLD_W = BASE_W;
const WORLD_H = BASE_H;

// distance de spawn anticip√© (API v1.0)
const SAFE_SPAWN_AHEAD = BASE_W * 1.3;


/* =========================================================
   üé∞ LUCKY SPIN SYSTEM (UNIFI√â - ROULETTE + ADMOB + TIMER)
========================================================= */

const ADS_MAX_PER_DAY = 5;
let adsDate = "";
let adsWatchedToday = 0;
let freeSpinUsed = false;
let isSpinning = false;
let currentRotation = 0;

// Les tranches (Align√©es visuellement avec ta roue HTML)
const segments = [
    { value: 20, chance: 0.35, minDeg: 0, maxDeg: 60, color: "#ff4444" },   // Rouge
    { value: 40, chance: 0.30, minDeg: 60, maxDeg: 120, color: "#ffffff" }, // Blanc
    { value: 80, chance: 0.20, minDeg: 120, maxDeg: 180, color: "#00f0ff" },// Cyan
    { value: 150, chance: 0.10, minDeg: 180, maxDeg: 240, color: "#ffffff" },// Blanc
    { value: 300, chance: 0.04, minDeg: 240, maxDeg: 300, color: "#ff00ff" },// Magenta
    { value: 1000, chance: 0.01, minDeg: 300, maxDeg: 360, color: "#ffd700" }// Or (Jackpot)
];

// --- 1. GESTION DU TEMPS ET SAUVEGARDES ---
function getTodayKey() {
    const d = new Date();
    return d.getFullYear() + "-" + String(d.getMonth()+1).padStart(2,"0") + "-" + String(d.getDate()).padStart(2,"0");
}

function getTimeUntilMidnight() {
    const now = new Date();
    const midnight = new Date();
    midnight.setHours(24, 0, 0, 0); // D√©finit minuit pile
    
    const diff = midnight - now;
    const hours = Math.floor(diff / (1000 * 60 * 60));
    const mins = Math.floor((diff / (1000 * 60)) % 60);
    
    return `${hours}h ${mins}m`;
}

function initRoulette() {
    const today = getTodayKey();
    adsDate = localStorage.getItem("rouletteDate");
    adsWatchedToday = Number(localStorage.getItem("adsCount") || 0);
    freeSpinUsed = localStorage.getItem("freeSpinUsed") === "true";

    // Si on est un nouveau jour, on reset tout
    if (adsDate !== today) {
        adsDate = today;
        adsWatchedToday = 0;
        freeSpinUsed = false;
        
        localStorage.setItem("rouletteDate", today);
        localStorage.setItem("adsCount", "0");
        localStorage.setItem("freeSpinUsed", "false");
    }
    updateRouletteUI();
}

function updateRouletteUI() {
    const status = document.getElementById("rouletteStatus");
    const spinBtn = document.getElementById("spinBtn");
    const shopStatus = document.getElementById("shopRouletteStatus");
    
    if (!freeSpinUsed) {
        // --- STEP 1: READY TO GO ---
        if(status) status.textContent = "READY"; 
        if(spinBtn) { 
            spinBtn.textContent = "FREE SPIN üéÅ"; 
            spinBtn.style.background = "linear-gradient(135deg, #00f0ff, #0080ff)"; 
            spinBtn.style.opacity = "1"; 
            spinBtn.style.cursor = "pointer"; 
        }
        if(shopStatus) { 
            shopStatus.textContent = "FREE SPIN READY!"; 
            shopStatus.style.color = "#00f0ff"; 
        }

    } else if (adsWatchedToday < ADS_MAX_PER_DAY) {
        // --- STEP 2: SOME LEFT ---
        let left = ADS_MAX_PER_DAY - adsWatchedToday;
        if(status) status.textContent = "READY";
        if(spinBtn) { 
            spinBtn.textContent = `SPIN (${left} LEFT) üì∫`; 
            spinBtn.style.background = "linear-gradient(135deg, #00f0ff, #0080ff)";
            spinBtn.style.opacity = "1"; 
            spinBtn.style.cursor = "pointer"; 
        }
        if(shopStatus) { 
            shopStatus.textContent = `${left} SPINS LEFT`; 
            shopStatus.style.color = "#00f0ff"; 
        }

    } else {
        // --- STEP 3: ALL DONE (WAITING FOR RESET) ---
        const timeLeft = getTimeUntilMidnight();
        
        if(status) status.textContent = "EMPTY"; 
        
        if(spinBtn) { 
            spinBtn.textContent = `COME BACK IN ${timeLeft}`; // Super clear instruction
            spinBtn.style.background = "#333"; 
            spinBtn.style.color = "#777";
            spinBtn.style.boxShadow = "none";
            spinBtn.style.opacity = "0.8";
            spinBtn.style.cursor = "not-allowed"; 
        }
        
        if(shopStatus) { 
            shopStatus.textContent = `RESET IN: ${timeLeft}`; // Explains the wait
            shopStatus.style.color = "#ff5555"; 
        }
    }
}

function openRoulette() {
    initRoulette();
    const popup = document.getElementById("roulettePopup");
    if (popup) popup.style.display = "flex";
    
    const resultText = document.getElementById("rouletteResult");
    if (resultText) resultText.textContent = "";

    // Rafra√Æchir le timer toutes les minutes tant que c'est ouvert
    if (window.rouletteTimer) clearInterval(window.rouletteTimer);
    window.rouletteTimer = setInterval(updateRouletteUI, 60000); 
}

function closeRoulette() {
    if (isSpinning) return; // Emp√™che de fermer pendant que la roue tourne
    const popup = document.getElementById("roulettePopup");
    if (popup) popup.style.display = "none";

    // Stop le timer pour √©conomiser la batterie
    if (window.rouletteTimer) clearInterval(window.rouletteTimer);
}

// --- 3. LIAISON AVEC ADMOB ---
function trySpin() {
    if (isSpinning) return;
    
    if (freeSpinUsed && adsWatchedToday >= ADS_MAX_PER_DAY) {
        const resultText = document.getElementById("rouletteResult");
        if (resultText) {
            resultText.textContent = "NO MORE SPINS TODAY!";
            resultText.style.color = "#ff4444";
        }
        return;
    }

    if (!freeSpinUsed) {
        // SPIN GRATUIT (Pas de pub = Spin imm√©diat apr√®s clic)
        freeSpinUsed = true;
        localStorage.setItem("freeSpinUsed", "true");
        if (typeof scheduleFreeSpinNotification === "function") scheduleFreeSpinNotification();
        executeSpin();
    } else {
        // SPIN VIA ADMOB
        const spinBtn = document.getElementById("spinBtn");
        
        if (typeof showRewardedAd === "function") {
            if (spinBtn) {
                spinBtn.textContent = "LOADING AD...";
                spinBtn.style.filter = "grayscale(1)"; // Petit style chargement
            }
            
            if(typeof playMusic === "function") playMusic("none");
            
            showRewardedAd(
                () => { // SUCC√àS DE LA PUB
                    adsWatchedToday++;
                    localStorage.setItem("adsCount", String(adsWatchedToday));
                    if(typeof playMusic === "function") playMusic("menu");
                    
                    // üî• L'√âCRAN D'ATTENTE "TAP TO SPIN" EST ICI
                    showTapToSpinOverlay(() => { 
                        executeSpin(); 
                    });
                },
                () => { // √âCHEC OU PUB FERM√âE
                    if (spinBtn) {
                        let left = ADS_MAX_PER_DAY - adsWatchedToday;
                        spinBtn.textContent = `SPIN (${left} LEFT) üì∫`;
                        spinBtn.style.filter = "none";
                    }
                    const resultText = document.getElementById("rouletteResult");
                    if (resultText) {
                        resultText.textContent = "AD CANCELED.";
                        resultText.style.color = "#ff4444";
                    }
                    if(typeof playMusic === "function") playMusic("menu");
                }
            );
        } else {
            // MODE TEST / PC
            adsWatchedToday++;
            localStorage.setItem("adsCount", String(adsWatchedToday));
            showTapToSpinOverlay(() => { executeSpin(); });
        }
    }
}

function executeSpin() {
    isSpinning = true;
    
    const spinBtn = document.getElementById("spinBtn");
    const resultText = document.getElementById("rouletteResult");
    const wheel = document.getElementById("wheel");

    // --- 1. FEEDBACK VISUEL IMM√âDIAT SUR LE BOUTON ---
    if (spinBtn) {
        spinBtn.textContent = "SPINNING..."; // On change le texte
        spinBtn.style.opacity = "0.5";       // On le grise
        spinBtn.style.cursor = "not-allowed";
        spinBtn.style.filter = "grayscale(1)"; // On enl√®ve la couleur
    }

    if (resultText) {
        resultText.textContent = "GOOD LUCK...";
        resultText.style.color = "#fff";
    }

    // --- 2. TIRAGE & ANGLE DYNAMIQUE (Version ChatGPT Valid√©e) ---
    let rand = Math.random(), cumulative = 0, winningSegment = segments[0];
    for (let i = 0; i < segments.length; i++) {
        cumulative += segments[i].chance;
        if (rand <= cumulative) { winningSegment = segments[i]; break; }
    }

    const segmentSize = winningSegment.maxDeg - winningSegment.minDeg;
    const randomAngleInsideSegment = (Math.random() * (segmentSize * 0.6)) + (segmentSize * 0.2);
    const targetAngle = 360 - (winningSegment.minDeg + randomAngleInsideSegment);

    // --- 3. ANIMATION DE LA ROUE (4 SECONDES) ---
    if (wheel) {
        wheel.style.transition = "transform 4s cubic-bezier(0.15, 0, 0.15, 1)";
        currentRotation += (360 * 8) + targetAngle - (currentRotation % 360);
        wheel.style.transform = `rotate(${currentRotation}deg)`;
    }

    // --- 4. R√âCOMPENSE & RESET ---
    setTimeout(() => {
        isSpinning = false;

        // Effet de choc (Dopamine) : petite vibration sur le texte du gain
        if (resultText) {
            resultText.textContent = `+ ${winningSegment.value} COINS !`;
            resultText.style.color = winningSegment.color;
            let glow = winningSegment.color === "#ffffff" ? "#00f0ff" : winningSegment.color;
            resultText.style.textShadow = `0 0 20px ${glow}`;
            
            // Animation de "pop"
            resultText.animate([
                { transform: 'scale(1)' },
                { transform: 'scale(1.5)', offset: 0.5 },
                { transform: 'scale(1)' }
            ], { duration: 500, easing: 'ease-out' });
        }

        // Cr√©diter les pi√®ces
        if (typeof coinsBank !== "undefined") {
            coinsBank += winningSegment.value;
            if (typeof Player !== "undefined") { Player.coins = coinsBank; Player.save(); }
            if (typeof updateCoinsUI === "function") updateCoinsUI();
        }

        // On remet le bouton √† jour (il affichera le timer ou le prochain spin)
        updateRouletteUI();
        
        // On remet le style du bouton par d√©faut (enlev√© le grayscale)
        if (spinBtn) {
            spinBtn.style.filter = "none";
        }

    }, 4000);
}
// --- 5. REVIVE ---
let canContinueThisRun = true;
let isWatchingAd = false;
let continueTimeout = null;

function hideContinuePopup() {
    const popup = document.getElementById("continuePopup");
    if (continueTimeout) clearTimeout(continueTimeout);
    continueTimeout = null;
    if (popup) popup.style.display = "none";
}

function showContinuePopup(durationSec = 4.0) {
    const popup = document.getElementById("continuePopup");
    const bar = document.getElementById("continueBar");
    const btn = document.getElementById("continueAdBtn");

    if (!popup || !bar || !btn || !canContinueThisRun) return;

    hideContinuePopup();
    popup.style.display = "flex";
    btn.disabled = false;
    btn.innerHTML = `<span class="btn-glitch"></span><span class="btn-txt">üì∫ WATCH AD & REVIVE</span>`;

    bar.style.transition = "none";
    bar.style.width = "100%";
    void bar.offsetWidth; 

    requestAnimationFrame(() => {
        bar.style.transition = `width ${durationSec}s linear`;
        bar.style.width = "0%";
    });

    continueTimeout = setTimeout(() => {
        hideContinuePopup(); // Le temps est √©coul√©, on reste sur l'√©cran de score
    }, durationSec * 1000);
}

/* =========================================
   REVIVE AD LOGIC (AUDIO SAFE)
========================================= */
function handleContinueAd() {
    if (isWatchingAd || !canContinueThisRun) return;
    isWatchingAd = true;
    canContinueThisRun = false; // On consomme le revive

    const btn = document.getElementById("continueAdBtn");
    if (btn) btn.innerHTML = `<span class="btn-txt">LOADING AD...</span>`;
    if (continueTimeout) clearTimeout(continueTimeout);

    // üîá COUPURE AUDIO (Le Game Over est d√©j√† silencieux, mais double s√©curit√©)
    playMusic("none");

    if (typeof showRewardedAd === "function") {
        showRewardedAd(
            () => { // SUCC√àS
                isWatchingAd = false;
                // La musique "GAME" sera relanc√©e dans revivePlayerAfterAd()
                revivePlayerAfterAd();
            },
            () => { // √âCHEC / FERMETURE SANS R√âCOMPENSE
                isWatchingAd = false;
                hideContinuePopup(); 
                // On reste sur le Game Over, donc silence
                playMusic("none");
            }
        );
    } else {
        isWatchingAd = false;
        hideContinuePopup();
    }
}

/* =========================================
   REVIVE PLAYER (CORRIG√â - FIX TACTILE COMPLET)
========================================= */
function revivePlayerAfterAd() {
    hideContinuePopup();
    
    // 1. UI RESET
    if (overlayGameOver) {
        overlayGameOver.classList.remove("visible");
        overlayGameOver.style.display = "none";
    }

    // üî• FIX 1 : LE SECRET EST ICI
    // On utilise ta fonction centrale ! Elle va retirer le bouclier `uiLayer`
    // et d√©bloquer proprement le `touchZone`.
    setUIState("playing"); 

    gameRunning = false; 

    // 2. RESET PHYSIQUE DU JOUEUR
    player.x = 100;
    player.y = BASE_H * 0.5;
    player.vy = 0;
    player.width = BASE_PLAYER_W;
    player.height = BASE_PLAYER_H;
    
    jetOn = false;

    // 3. NETTOYAGE DES FX FIG√âS
    shockwave = null;
    bloom = null;
    dyingFromCircle = null;

    overdriveActive = false; 
    overdriveTimer = 0;
    player.invincible = true;

    // 4. NETTOYAGE ZONE
    obstacles = obstacles.filter(o => o.x > player.x + 800);
    bullets = [];
    
    lastSpawnTime = renderTime + 1000; 

    draw(); 

    // 5. OVERLAY "READY?"
    const oldOverlay = document.getElementById("resumeOverlay");
    if (oldOverlay) oldOverlay.remove();

    const resumeOverlay = document.createElement("div");
    resumeOverlay.id = "resumeOverlay";
    resumeOverlay.style.cssText = `
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column; align-items: center; justify-content: center;
        background: rgba(0,0,0,0.5); z-index: 99999; cursor: pointer; pointer-events: auto !important;
    `;
    
    resumeOverlay.innerHTML = `
        <div style="font-family:Orbitron, sans-serif; font-size:40px; color:#00f0ff; text-shadow:0 0 15px cyan; margin-bottom:10px;">READY?</div>
        <div style="font-family:Rajdhani, sans-serif; font-size:20px; color:white; letter-spacing:2px; animation: blink 1s infinite;">TAP TO START</div>
    `;

    document.body.appendChild(resumeOverlay);

    // 6. RELANCE DU JEU
    const resumeGame = (e) => {
        // Emp√™che le clic de traverser et de faire voler le perso accidentellement d√®s la 1√®re frame
        if (e) { e.preventDefault(); e.stopPropagation(); }
        
        resumeOverlay.remove();
        
        // Relance Moteur
        gameRunning = true;
        if (typeof lastTS !== "undefined") lastTS = performance.now();
        startLoop();

        // Relance Son
        if (typeof audioSettings !== "undefined" && !audioSettings.mute) {
            playMusic("game");
        }

        document.body.classList.add("overdriveActive"); 
        
        setTimeout(() => { 
            player.invincible = false; 
            document.body.classList.remove("overdriveActive");
        }, 3000);
    };

    resumeOverlay.onclick = resumeGame;
    resumeOverlay.ontouchstart = resumeGame;
}

let hasMultiplied = false; // S√©curit√© pour emp√™cher de multiplier 10 fois

function handleGameOver() {
    _startRunLock = false;
    if (gameOverTriggered) return;
    gameOverTriggered = true;

    setUIState("gameover"); 
    pauseLoop();

    const tz = document.getElementById("touchZone");
    if (tz) tz.style.pointerEvents = "none";

    const s = Math.floor(score || 0);
    const previousBest = bestScore || 0; 
    
    if (s > previousBest) {
        bestScore = s;
        newRecordThisRun = true; 
    }

    // Sauvegarde initiale des pi√®ces
    coinsBank += (coinsCollected || 0);
    Player.coins = coinsBank;
    Player.bestScore = bestScore;
    Player.save();
    if (typeof updateMenuStats === 'function') updateMenuStats();

    // Remplissage UI Game Over
    safeText(finalScoreEl, s.toLocaleString());
    safeText(finalBestEl, (bestScore || 0).toLocaleString());
    safeText(finalCoinsEl, (coinsCollected || 0).toLocaleString());

    // --- üí∞ GESTION DU BOUTON MULTIPLICATEUR ---
    const multiplyBtn = document.getElementById("multiplyBtn");
    if (multiplyBtn) {
        // On affiche le bouton SEULEMENT SI le joueur a des pi√®ces √† multiplier
        if (coinsCollected > 0 && !hasMultiplied) {
            multiplyBtn.style.display = "block";
            multiplyBtn.textContent = "üî•üé∞ WATCH AD & MULTIPLY COINS!üì∫";
            multiplyBtn.disabled = false;
            multiplyBtn.style.filter = "none";
        } else {
            multiplyBtn.style.display = "none";
        }
    }

    // --- üèÜ GESTION NEW RECORD ---
    const nrEl = document.getElementById("newRecord");
    if (nrEl) {
        if (newRecordThisRun) {
            nrEl.style.display = "block";
            requestAnimationFrame(() => {
                nrEl.style.opacity = "1";
                nrEl.style.transform = "scale(1)";
            });
        } else {
            nrEl.style.display = "none";
            nrEl.style.opacity = "0";
            nrEl.style.transform = "scale(0.6)";
        }
    }

    // Affichage du popup de REVIVE par dessus (S'il est dispo)
    if (canContinueThisRun && isAdSystemReady()) {
        showContinuePopup(4.5);
    }
}
// ================================
// 4. SHOP UI GENERATION (NEW HTML)
// ================================
function initShopUI(){
  const panel = document.getElementById("shopPanel");
  if (!panel) return;
  
  // HTML M√ÄJ : On remplace le vieux Loot par le bouton Roulette
  panel.innerHTML = `
    <div id="shopBackBtn" onclick="closeShop()">‚Üê BACK</div>
    
    <div id="shopBalanceDisplay">
      <div class="coinIcon needs-glow"></div>
      <div id="shopTotalCoins">0</div>
    </div>
    
    <div id="shopAdBlock" onclick="openRoulette()">
        <div class="loot-icon" style="filter: drop-shadow(0 0 5px #00f0ff);">üé∞</div>
        <div class="loot-info">
            <div class="loot-title" id="shopRouletteStatus" style="color:#00f0ff;">FREE SPIN üéÅ</div>
            <div class="loot-action">LUCKY SPIN</div>
        </div>
    </div>
    
    <div class="shopContentZone">
      <div class="skinCard">
        <canvas id="shopHeroCanvas" width="1200" height="1200" class="skinPreview"></canvas>
      </div>
      
      <div class="skinInfoZone">
        <div class="skinName" id="shopSkinName">SKIN</div>
        <div class="skinPrice" id="shopSkinPrice">0</div>
        <button id="shopActionBtn" class="skinButton">ACTION</button>
      </div>
    </div>
    
    <div class="navArrow left" onclick="shopNav(-1)">‚Äπ</div>
    <div class="navArrow right" onclick="shopNav(1)">‚Ä∫</div>
  `;
  
  // Re-bind du canvas
  const cvs = document.getElementById("shopHeroCanvas");
  if (cvs) shopCanvasCtx = cvs.getContext("2d", { alpha: true });
}


// ================= PARTICLES GLOBALS (OBLIGATOIRES) =================
const PARTICLE_POOL_SIZE = FXQuality?.isMobile ? 80 : 160;

const particlePool = [];
const playerParticles = [];

let poolIndex = 0;
let lastTrailSpawn = 0;
for (let i = 0; i < PARTICLE_POOL_SIZE; i++){
  particlePool.push({
    active:false,
    x:0, y:0,
    vx:0, vy:0,
    life:0, lifeMax:0,
    size:0, glow:0,
    seed:0,
    shape:"default",
    color:"#fff",
    jx:null, js:null
  });
}
/* =========================
   SPAWN PLAYER TRAIL (POOL SAFE / FINAL)
========================= */
function spawnPlayerTrail(x, y, skin){
  const now = renderTime || performance.now();

  // üîí throttle CRITIQUE (mobile / FX heavy)
  const delay = FXQuality.isMobile ? 24 : 16;
  if (now - lastTrailSpawn < delay) return;
  lastTrailSpawn = now;

  // üîí pool circulaire (AUCUNE ALLOC)
  const p = particlePool[poolIndex];
  poolIndex = (poolIndex + 1) % PARTICLE_POOL_SIZE;

  // ===== RESET COMPLET =====
  p.active  = true;
  p.x = x;
  p.y = y;

  p.vx = -1.4 - Math.random() * 0.6;
  p.vy = (Math.random() - 0.5) * 0.6;

  p.life    = 26;
  p.lifeMax = 26;

  p.seed = Math.random() * 999;
  p.jx = null;
  p.js = null;

  p.size = overdriveActive ? 2.6 : 3.6;
  p.glow = overdriveActive ? 8 : 14;

  p.shape = "default";
  p.color = "rgba(230,240,255,0.9)";

  // ===== SKIN VARIANTS =====
  switch (skin){
    case "solar":
      p.shape = "solar";
      p.color = "rgba(255,210,90,1)";
      p.glow  = overdriveActive ? 10 : 18;
      break;

    case "neon":
      p.shape = "line";
      p.color = "rgba(120,220,255,1)";
      p.glow  = 12;
      break;

    case "inferno":
      p.shape = "ember";
      p.color = "rgba(255,120,40,1)";
      p.glow  = 16;
      break;

    case "arctic":
      p.shape = "snow";
      p.color = "rgba(220,245,255,1)";
      p.glow  = 6;
      break;

    case "forest":
      p.shape = "leaf";
      p.color = "rgba(120,200,120,1)";
      p.glow  = 6;
      break;

    case "voidwalker":
      p.shape = "void";
      p.color = "rgba(140,110,220,1)";
      p.glow  = 14;
      break;
  }

  // ===== REGISTER (SANS DUPLICAT) =====
  if (!p._inList){
    p._inList = true;
    playerParticles.push(p);
  }
}


// ================= CAMERA SHAKE (GLOBAL SAFE) =================
let shakeX = 0, shakeY = 0;
let shakeTime = 0, shakePower = 0;

function triggerShake(power = 6, duration = 120){
  shakePower = Math.max(shakePower, power);
  shakeTime = duration;
}

function updateShake(delta){
  if (shakeTime > 0){
    const prev = shakeTime;
    shakeTime -= delta;

    const p = shakePower * (shakeTime / Math.max(1, prev));
    const nx = (Math.random() * 2 - 1) * p;
    const ny = (Math.random() * 2 - 1) * p;

    shakeX = shakeX * 0.6 + nx * 0.4;
    shakeY = (shakeY * 0.6 + ny * 0.4) * 0.75;

    if (shakeTime <= 0){
      shakeX = 0;
      shakeY = 0;
      shakePower = 0;
    }
  } else {
    shakeX = 0;
    shakeY = 0;
  }
}

/* =========================
   UTILS
========================= */
function aabbVsRect(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function isOptionsOpen(){
  return optionsPanelEl && optionsPanelEl.style.display === "flex";
}




/* =========================
    UPDATE (VERSION R√âPAR√âE & FLUIDE)
========================= */
function update(delta, ts){

  // ---------- PERF / FX ----------
  updateFXCalm(delta);
  updateShake(delta);
  const now = performance.now(); // On utilise performance.now() pour plus de pr√©cision
  renderTime = now; 
  skipHeavyFX = (delta > 24);

  // Expression du perso
  const target = jetOn ? 1 : 0;
  moonyExpr += (target - moonyExpr) * 0.08;

  // ---------- √âTAT MORT (DYING) ----------
  if (gameState === "dying"){
    for (let i = particles.length - 1; i >= 0; i--){
      const p = particles[i];
      p.x += p.vx; p.y += p.vy; p.vy += 0.02; p.age += delta;
      if (p.age >= p.life) particles.splice(i, 1);
    }
    if (shockwave){
      shockwave.r += 6; shockwave.alpha *= 0.95;
      if (shockwave.r > (shockwave.max || 180) || shockwave.alpha < 0.02) shockwave = null;
    }
    if (bloom){
      bloom.a *= 0.92; if (bloom.a < 0.02) bloom = null;
    }
    if (dyingFromCircle){
      const cx = dyingFromCircle.x; const cy = dyingFromCircle.y;
      const pcx = player.x + player.width*0.5; const pcy = player.y + player.height*0.5;
      player.x += (cx - pcx) * 0.06; player.y += (cy - pcy) * 0.06;
      player.width *= 0.992; player.height *= 0.992;
    }
    dyingTimer -= delta;
    if (dyingTimer <= 0) handleGameOver();
    return;
  }

  if (gameState !== "playing") return;

  // ---------- OVERDRIVE ----------
  let currentPacing = paceMultiplier(score); // On r√©cup√®re ta courbe de difficult√©
  if (overdriveActive){
    currentPacing *= 1.5; // Boost de vitesse
    overdriveTimer -= delta;
    const pct = Math.max(0, overdriveTimer / overdriveDuration);
    const pctInt = (pct * 100) | 0;
    if (pctInt !== lastOverdrivePct){
      lastOverdrivePct = pctInt;
      if (UI.overFill) UI.overFill.style.height = pctInt + "%";
    }
    if (pct < 0.35 && !overdriveEndingFlag){
      overdriveEndingFlag = true;
      document.body.classList.add("overdriveEnding");
    }
    if (overdriveTimer <= 0) deactivateOverdrive();
  }

  // ---------- PHYSIQUE JOUEUR ----------
  // On multiplie par (delta/16.6) pour que la vitesse soit la m√™me peu importe les FPS
  const dt = delta / 16.6; 
  player.vy += (jetOn ? THRUST : GRAVITY) * dt;
  player.vy = clamp(player.vy, -8, 8);
  player.y  += player.vy * dt;

  const SAFE_TOP = OFF_Y;
  const SAFE_BOTTOM = WORLD_H - OFF_Y - player.height;

  if (player.y < SAFE_TOP){ player.y = SAFE_TOP; player.vy = 0; } 
  else if (player.y > SAFE_BOTTOM){ player.y = SAFE_BOTTOM; player.vy = 0; }

  // Trail
  if ((jetOn || Math.abs(player.vy) > 0.25) && (now - lastTrailSpawn) > 40){
    spawnPlayerTrail(player.x + player.width*0.5, player.y + player.height*0.65, currentSkin || "moony");
    lastTrailSpawn = now;
  }

  // ---------- VITESSE & SPAWN ----------
  // On utilise ta nouvelle logique de vitesse progressive
  obstacleSpeed = 3.8 * currentPacing; 
  const sp = obstacleSpeed * dt;

  // Appel du spawn (le spawn check lui-m√™me le timing)
  spawn(); 

  // ---------- OBSTACLES (LOGIQUE & COLLISIONS) ----------
  const rx = player.x, ry = player.y, rw = player.width, rh = player.height;
  const cxp = rx + rw * 0.5, cyp = ry + rh * 0.5;
  const DESPAWN_X = -400;

  for (let i = obstacles.length - 1; i >= 0; i--){
    const ob = obstacles[i]; 

    // Mouvements Sp√©ciaux
    if (ob.kind === "piston"){
        ob.t += ob.speed * dt;
        const range = (WORLD_H - ob.height - 80) / 2;
        const center = WORLD_H / 2 - ob.height / 2;
        ob.y = center + Math.sin(ob.t) * range;
    }
    else if (ob.kind === "laserScan"){
        ob.y += ob.vy * dt;
        if (ob.y < 20 || ob.y > WORLD_H - 40) ob.vy *= -1;
    }
    else if (ob.kind === "movingRect" || ob.kind === "mover"){
      ob.t += ob.speed * 0.05 * dt;
      const range = ob.amp || 80;
      const baseY = (ob.baseY != null) ? ob.baseY : WORLD_H/2;
      ob.y = clamp(baseY - Math.sin(ob.t) * range, SAFE_TOP, SAFE_BOTTOM - ob.height);
    }
    
    // Mouvement Horizontal
    if (ob.kind === "rotbar"){
      ob.cx -= sp; ob.angle += ob.speed * dt;
    } else {
      ob.x -= sp;
    }

    // Despawn
    const rightEdge = (ob.kind === "rotbar") ? (ob.cx + ob.len) : (ob.x + (ob.width||ob.r||0));
    if (rightEdge < DESPAWN_X){ 
        obstacles.splice(i, 1); 
        continue; 
    }

    // Collisions
    if (!overdriveActive && !player.invincible){
      const ox = (ob.kind === "rotbar") ? ob.cx : ob.x;
      if (Math.abs(ox - cxp) <= 200){ 
        
        if (ob.kind === "piston" || ob.kind === "rect" || ob.kind === "movingRect" || ob.kind === "mover" || ob.kind === "sweeper"){
             if (aabbVsRect(rx, ry, rw, rh, ob.x, ob.y, ob.width, ob.height)) return startDeath(false, null, ob.kind);
        }
        else if (ob.kind === "laserScan"){
             if (aabbVsRect(rx, ry, rw, rh, ob.x, ob.y + 4, ob.width, ob.height - 8)) return startDeath(false, null, "laser");
        }
        else if (ob.kind === "circle"){
          const dx = cxp - ob.x, dy = cyp - ob.y;
          const rr = (ob.r * 0.9);
          if (dx*dx + dy*dy < rr*rr) return startDeath(true, ob, "circle");
        }
        else if (ob.kind === "rotbar"){
          if (aabbVsOBB(rx, ry, rw, rh, ob.cx, ob.cy, (ob.half || 7), ob.len, ob.angle)) return startDeath(false, null, "bar");
        }
      }
    }
  }

  // ---------- COINS ----------
  for (let i = coins.length - 1; i >= 0; i--){
    const c = coins[i];
    c.x -= sp;
    if (c.x < -100){ coins.splice(i, 1); continue; }
    
    const dx = cxp - c.x, dy = cyp - c.y;
    if (dx*dx + dy*dy <= (c.r + 20)*(c.r + 20)){
      coins.splice(i, 1); coinsCollected++;
      combo = ((now - lastCoinTime) < 1600) ? (combo + 1) : 1;
      lastCoinTime = now; addOverdrive(1);
      score += (overdriveActive ? 400 : 200) + (combo * 20);
    }
  }

  // ---------- SCORE & UI ----------
  // Augmentation du score bas√©e sur la distance
  score += delta * 0.24 * currentPacing * (overdriveActive ? 2 : 1);
  
  if ((frameCount & 3) === 0){ 
    if (UI.score) UI.score.textContent = Math.floor(score);
    if (UI.coins) UI.coins.textContent = coinsCollected;
    if (UI.combo) UI.combo.textContent = combo;
  }
// üëâ AJOUTE CETTE LIGNE ICI (Juste avant le fxGarbageCollect) :
  if (typeof updateSpaceJourney === "function") updateSpaceJourney(score, delta);
  fxGarbageCollect();
}
let _lastLagLog = 0;

function debugLag(delta){
  const now = performance.now();
  if (delta > 22 && now - _lastLagLog > 1200){
    _lastLagLog = now;
    console.warn(
      "LAG",
      delta.toFixed(1),
      "score:", Math.floor(score),
      "obs:", obstacles.length,
      "fx:", particles.length
    );
  }
}


/* =====================================================
   üßπ GARBAGE COLLECTOR (SYSTEME NETTOYAGE M√âMOIRE)
===================================================== */

// ‚úÖ 1. D√âCLARATION MANQUANTE (C'est √ßa qui causait l'erreur)
const _obFX = {
  glowColor: new Map(),
  rectBody: new Map(),
  circleBody: new Map()
};

let _fxGC = 0;

// ‚úÖ 2. FONCTION DE NETTOYAGE S√âCURIS√âE
function fxGarbageCollect(){
  _fxGC++;
  if (_fxGC < 600) return; // S'ex√©cute toutes les ~10 secondes
  _fxGC = 0;

  // Nettoyage des caches de chemins (Path2D)
  if (typeof _arcPathCache !== 'undefined' && _arcPathCache.size > 64) _arcPathCache.clear();
  if (typeof _rectPathCache !== 'undefined' && _rectPathCache.size > 64) _rectPathCache.clear();

  // Nettoyage des caches d'effets (si la variable existe bien)
  if (typeof _obFX !== 'undefined') {
      for (const k in _obFX){
        // On v√©rifie que c'est bien une Map avant de vider
        if (_obFX[k] instanceof Map && _obFX[k].size > 64) {
            _obFX[k].clear();
        }
      }
  }
}



// =========================
// DEATH ORIGIN (SAFE)
// =========================
function getDeathXY(){
  if (deathOrigin) return deathOrigin;
  return {
    x: player.x + player.width  * 0.5,
    y: player.y + player.height * 0.5
  };
}

/* =========================================================
   üåå BACKGROUND SYSTEM (OPTIMIZED + DISTANT WORLD)
   - Performance : Lune en cache + Warp simplifi√©.
   - Gameplay : Lune disparait √† 84k.
   - Visuel : Plus d'OVNIs, mais des plan√®tes lointaines.
========================================================= */

// --- 1. COULEURS (INCHANG√â) ---
const BG_THEME = {
    top: "#020005", bottom: "#100020", 
    blobs: [
        { color: "#4400ff", x: 0.2, y: 0.3, s: 0.6, t: 0.5 }, 
        { color: "#ff0055", x: 0.8, y: 0.7, s: 0.5, t: 0.8 }, 
        { color: "#00ccff", x: 0.5, y: 0.8, s: 0.7, t: 0.3 }, 
        { color: "#7700ff", x: 0.1, y: 0.9, s: 0.8, t: 0.6 }  
    ]
};

// --- 2. LOGIQUE ---
const bgJourney = {
    moonAlpha: 1, 
    warpAlpha: 0,
    
    // Cache pour la lune (Optimisation CPU)
    moonCache: null,
    
    // Listes d'objets
    distantPlanets: [], // Rempla√ßant des soucoupes ("loiiiin")
    shootingStars: [], 
    warpLines: []
};

function initSpaceJourney() {
    bgJourney.moonAlpha = 1; 
    bgJourney.warpAlpha = 0;
    bgJourney.warpLines = []; 
    bgJourney.distantPlanets = [];
    bgJourney.shootingStars = [];
    bgJourney.moonCache = null; // Reset cache au d√©marrage
}

function updateSpaceJourney(score, delta) {
    const W = (typeof VIEW_W !== 'undefined') ? VIEW_W : 800;
    const H = (typeof BASE_H !== 'undefined') ? BASE_H : 600;
    
    // Vitesse globale
    const speed = Math.min(2.4, 1.0 + (score / 50000));
    
    // --- A. GESTION DES PHASES ---
    
    // Lune : Dispara√Æt √† 84k (Transition douce)
    let targetMoon = (score < 84000) ? 1 : 0;
    bgJourney.moonAlpha += (targetMoon - bgJourney.moonAlpha) * 0.01; // Fade tr√®s lent

    // Warp : Apparition progressive vers la fin
    let targetWarp = (score >= 85000) ? 1 : 0;
    bgJourney.warpAlpha += (targetWarp - bgJourney.warpAlpha) * 0.02;

    // --- B. PLAN√àTES LOINTAINES (Remplacent les soucoupes) ---
    // Elles sont tr√®s lentes pour donner une impression de distance immense
    if (bgJourney.distantPlanets.length < 2) { 
        if (Math.random() < 0.002) { 
            const size = 10 + Math.random() * 30;
            bgJourney.distantPlanets.push({
                x: W + 100, 
                y: Math.random() * H,
                radius: size,
                type: Math.random() > 0.5 ? 'ring' : 'gas', // Anneau ou Gaz
                color: `hsl(${Math.random()*360}, 60%, 40%)`,
                speed: (0.2 + Math.random() * 0.3) // Tr√®s lent par rapport au reste
            });
        }
    }

    // Mise √† jour Plan√®tes
    for (let i = bgJourney.distantPlanets.length - 1; i >= 0; i--) {
        let p = bgJourney.distantPlanets[i];
        p.x -= p.speed * speed; 
        if (p.x < -100) bgJourney.distantPlanets.splice(i, 1);
    }

    // --- C. √âTOILES FILANTES ---
    if (Math.random() < 0.01) { 
        bgJourney.shootingStars.push({
            x: W + Math.random() * 200,
            y: Math.random() * (H * 0.7),
            vx: -20 - Math.random() * 15,
            vy: (Math.random() - 0.5) * 5, 
            len: 60 + Math.random() * 60,
            life: 1.0
        });
    }
    for (let i = bgJourney.shootingStars.length - 1; i >= 0; i--) {
        let s = bgJourney.shootingStars[i];
        s.x += s.vx * speed; s.y += s.vy * speed; s.life -= 0.02;
        if (s.life <= 0) bgJourney.shootingStars.splice(i, 1);
    }

// --- D. WARP DOUX (Optimis√© & Parallax Fix√©) ---
    if (bgJourney.warpAlpha > 0.01) {
        if (Math.random() < 0.15) { // Moins de lignes (0.15 au lieu de 0.3) pour moins surcharger l'√©cran
            bgJourney.warpLines.push({
                x: W + 50, 
                y: Math.random() * H,
                // On √©tire √©norm√©ment les lignes pour l'effet "Vitesse Lumi√®re" (Motion Blur)
                w: 400 + Math.random() * 400, 
                // VITESSE R√âDUITE (Parallax) : Doit √™tre plus lent que les murs du premier plan
                s: 1.5 + Math.random() * 2.0,   
                a: 0, 
                ta: 0.1 + Math.random() * 0.15 // Opacit√© tr√®s douce pour ne pas aveugler
            });
        }
    }
    for (let i = bgJourney.warpLines.length - 1; i >= 0; i--) {
        let w = bgJourney.warpLines[i];
        w.x -= w.s * speed;
        if (w.a < w.ta) w.a += 0.02; // Apparition en fondu doux
        if (w.x + w.w < -100) bgJourney.warpLines.splice(i, 1);
    }}
// --- 3. DESSIN (LUNE QUI TE REGARDE + PERFORMANCE) ---
function drawSpaceJourney(ctx) {
    const W = (typeof VIEW_W !== 'undefined') ? VIEW_W : 800;
    const t = performance.now() * 0.001;

    // 1. PLAN√àTES LOINTAINES
    bgJourney.distantPlanets.forEach(p => {
        ctx.save();
        ctx.globalAlpha = 0.6;
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath(); ctx.arc(p.x - p.radius*0.3, p.y + p.radius*0.2, p.radius*0.9, 0, Math.PI*2); ctx.fill();
        if (p.type === 'ring') {
            ctx.strokeStyle = "rgba(255,255,255,0.3)"; ctx.lineWidth = p.radius * 0.4;
            ctx.beginPath(); ctx.ellipse(p.x, p.y, p.radius * 1.8, p.radius * 0.4, -0.2, 0, Math.PI*2); ctx.stroke();
        }
        ctx.restore();
    });

    // 2. LUNE KAWAII (HYBRIDE : Corps en Cache + Yeux Dynamiques)
    if (bgJourney.moonAlpha > 0.01) {
        // A. G√©n√©ration du cache (Une seule fois : juste le corps et les joues)
        if (!bgJourney.moonCache) {
            const mCanvas = document.createElement('canvas');
            mCanvas.width = 120; mCanvas.height = 120;
            const mCtx = mCanvas.getContext('2d');
            mCtx.translate(60, 60);

            // Corps (Lourd √† calculer)
            const g = mCtx.createRadialGradient(-10, -10, 5, 0, 0, 55);
            g.addColorStop(0, "#fff"); g.addColorStop(1, "#eef6ff");
            mCtx.fillStyle = g; mCtx.beginPath(); mCtx.arc(0, 0, 50, 0, Math.PI*2); mCtx.fill();
            mCtx.strokeStyle = "rgba(180, 200, 255, 0.8)"; mCtx.lineWidth = 3; mCtx.stroke();

            // Joues (Statiques, c'est plus mignon)
            mCtx.fillStyle = "rgba(255, 150, 180, 0.5)";
            mCtx.beginPath(); mCtx.arc(-24, 16, 6, 0, Math.PI*2); mCtx.fill();
            mCtx.beginPath(); mCtx.arc(24, 16, 6, 0, Math.PI*2); mCtx.fill();

            bgJourney.moonCache = mCanvas;
        }

        // B. Positionnement
        const mx = W - 120;
        const my = 120 + Math.sin(t*1.5)*5;

        // C. Dessin du Corps (Depuis le cache)
        ctx.globalAlpha = bgJourney.moonAlpha;
        ctx.shadowColor = "rgba(200, 230, 255, 0.4)"; ctx.shadowBlur = 20;
        ctx.drawImage(bgJourney.moonCache, mx - 60, my - 60);
        ctx.shadowBlur = 0;

        // D. Calcul du Regard (Tracking du joueur)
        // On r√©cup√®re la position du joueur (ou 0 par d√©faut si pas encore d√©fini)
        let px = (typeof player !== 'undefined') ? player.x : 0;
        let py = (typeof player !== 'undefined') ? player.y : 0;
        
        // On limite le mouvement des yeux pour qu'ils ne sortent pas du visage (Clamp)
        let dx = Math.max(-8, Math.min(8, (px - mx) * 0.04));
        let dy = Math.max(-6, Math.min(6, (py - my) * 0.04));

        // E. Dessin du Visage (Dynamique)
        ctx.translate(mx, my); // On se place au centre de la lune
        
        // Yeux (Base sombre)
        ctx.fillStyle = "#334455"; 
        ctx.beginPath(); ctx.ellipse(-16 + dx, -4 + dy, 6, 8, 0, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.ellipse(16 + dx, -4 + dy, 6, 8, 0, 0, Math.PI*2); ctx.fill();
        
        // Reflets (Blanc)
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(-19 + dx, -7 + dy, 2.5, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.arc(13 + dx, -7 + dy, 2.5, 0, Math.PI*2); ctx.fill(); 

        // Bouche (Suit un peu moins le mouvement pour effet 3D)
        ctx.strokeStyle = "#334455"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(dx*0.5, 12 + dy*0.5, 6, 0.1*Math.PI, 0.9*Math.PI); ctx.stroke();
        
        // Reset transformation
        ctx.translate(-mx, -my);
        ctx.globalAlpha = 1;
    }

    // 3. √âTOILES FILANTES
    ctx.lineWidth = 2;
    bgJourney.shootingStars.forEach(s => {
        ctx.strokeStyle = `rgba(255, 255, 220, ${s.life})`; 
        ctx.beginPath(); ctx.moveTo(s.x, s.y); 
        ctx.lineTo(s.x - s.len, s.y - s.len * (s.vy/s.vx)); ctx.stroke();
    });

    // 4. WARP DOUX (Optimis√©)
    if (bgJourney.warpAlpha > 0.01) {
        ctx.globalAlpha = bgJourney.warpAlpha;
        bgJourney.warpLines.forEach(w => {
            ctx.fillStyle = `rgba(180, 230, 255, ${w.a})`; 
            ctx.fillRect(w.x, w.y, w.w, 2); 
        });
        ctx.globalAlpha = 1;
    }
}

// --- 4. MOTEUR DE FOND FIXE ---
let bgStarsFar, bgStarsNear, bgInitialized = false;
function createCrispStars(w, h, count) {
    const cvs = document.createElement('canvas'); cvs.width = w; cvs.height = h; const c = cvs.getContext('2d');
    c.fillStyle = "white";
    for(let i=0; i<count; i++) {
        c.globalAlpha = Math.random()*0.8 + 0.2;
        c.beginPath(); c.arc(Math.random()*w, Math.random()*h, Math.random()<0.9?1:2, 0, Math.PI*2); c.fill();
    }
    return cvs;
}
function initParallax(w, h) {
    bgStarsFar = createCrispStars(w, h, 150); bgStarsNear = createCrispStars(w, h, 50); bgInitialized = true;
}

function drawBG(scroll) {
    if (!ctx) return;
    const W = (typeof VIEW_W !== 'undefined') ? VIEW_W : 800;
    const H = (typeof BASE_H !== 'undefined') ? BASE_H : 600;
    const tNow = (typeof renderTime !== 'undefined') ? renderTime * 0.001 : performance.now() * 0.001;
    if (!bgInitialized || !bgStarsFar || bgStarsFar.width !== Math.ceil(W)) initParallax(Math.ceil(W), Math.ceil(H));

    ctx.save();
    const ox = (typeof OFF_X !== 'undefined') ? OFF_X : 0; const oy = (typeof OFF_Y !== 'undefined') ? OFF_Y : 0;
    ctx.translate(-ox, -oy);

    // FOND
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, BG_THEME.top); bgGrad.addColorStop(1, BG_THEME.bottom);
    ctx.fillStyle = bgGrad; ctx.fillRect(-50, -50, W+100, H+100);

    // Blobs (Optimis√©: globalAlpha r√©duit pour m√©lange plus doux et rapide)
    ctx.globalCompositeOperation = "lighter";
    BG_THEME.blobs.forEach((blob) => {
        const cx = (W * blob.x) + Math.sin(tNow*0.5 + blob.t*10)*W*0.2;
        const cy = (H * blob.y) + Math.cos(tNow*0.3 + blob.t*10)*H*0.1;
        const r = Math.min(W, H) * blob.s;
        
        // Optimisation possible : Si √ßa lag trop, commenter le gradient et mettre une couleur unie floue
        const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        g.addColorStop(0, blob.color); g.addColorStop(1, "transparent");
        ctx.fillStyle = g; ctx.globalAlpha = 0.25; // Alpha un peu r√©duit
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
    });

    // √âtoiles
    ctx.globalCompositeOperation = "source-over"; ctx.globalAlpha = 1.0;
    if (bgStarsFar) { let x = -(scroll * 0.02) % W; if (x > 0) x -= W; ctx.drawImage(bgStarsFar, x, 0, W, H); ctx.drawImage(bgStarsFar, x + W, 0, W, H); }
    if (bgStarsNear) { let x = -(scroll * 0.1) % W; if (x > 0) x -= W; ctx.drawImage(bgStarsNear, x, 0, W, H); ctx.drawImage(bgStarsNear, x + W, 0, W, H); }

    // DRAW SPACE JOURNEY
    drawSpaceJourney(ctx);

    // VIGNETTE
    const vig = ctx.createRadialGradient(W/2, H/2, H*0.6, W/2, H/2, W);
    vig.addColorStop(0, "rgba(0,0,0,0)"); vig.addColorStop(1, "rgba(0,0,0,0.5)");
    ctx.fillStyle = vig; ctx.fillRect(-50, -50, W+100, H+100);

    ctx.restore();
}
/* =========================================================
   üî• AAA PARTICLE SYSTEM (Optimized & Cached)
========================================================= */

// √âtat global des particules
const activeParticles = [];
const solarGradCache  = new Map(); // Cache pour les d√©grad√©s complexes

// CLASSE PARTICULE
class Particle {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type || "fire"; // fire, smoke, neon, void
        this.life = 1.0;
        this.maxLife = 1.0;
        
        // Physique al√©atoire selon le type
        const spread = 1.5;
        this.vx = (Math.random() - 0.5) * spread;
        this.vy = (Math.random() * 2) + 2; // Tombe vers le bas (jetpack pousse vers le haut)
        
        this.size = (Math.random() * 6) + 4;
        this.decay = (Math.random() * 0.03) + 0.02;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= this.decay;
        this.size *= 0.95; // R√©tr√©cit avec le temps
    }

    draw(ctx) {
        if (this.life <= 0) return;
        
        ctx.globalAlpha = this.life;
        
        // Rendu optimis√© via Cache de Gradient (comme ton id√©e originale)
        // On g√©n√®re une cl√© unique bas√©e sur la taille et la couleur
        const grad = getParticleGradient(ctx, this.size, this.life, this.type);
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 1.0;
    }
}

// CACHE INTELLIGENT (Inspir√© de ton code "Solar")
function getParticleGradient(ctx, r, life, type){
    // On arrondit le rayon pour limiter le nombre de cl√©s en cache
    const q = Math.max(2, (r * 2) | 0);
    // On segmente la vie (High, Mid, Low) pour varier les couleurs
    const tier = life > 0.6 ? 1 : life > 0.3 ? 2 : 3;
    const key = `${type}|${q}|${tier}`;

    let g = solarGradCache.get(key);
    if (g) return g;

    // Cr√©ation du gradient si pas en cache
    g = ctx.createRadialGradient(0, 0, 0, 0, 0, r);

    // PALETTES DE COULEURS SELON LE SKIN
    if (type === "neon") {
        // Cyan / Electric Blue
        g.addColorStop(0, `rgba(200, 255, 255, 1)`);
        g.addColorStop(0.5, `rgba(0, 255, 255, 0.5)`);
        g.addColorStop(1, `rgba(0, 100, 255, 0)`);
    } else if (type === "void") {
        // Violet / Dark Matter
        g.addColorStop(0, `rgba(255, 200, 255, 1)`);
        g.addColorStop(0.5, `rgba(180, 0, 255, 0.5)`);
        g.addColorStop(1, `rgba(50, 0, 100, 0)`);
    } else {
        // Default Fire (Orange/Jaune)
        g.addColorStop(0, `rgba(255, 255, 200, 1)`);
        g.addColorStop(0.4, `rgba(255, 160, 0, 0.6)`);
        g.addColorStop(1, `rgba(255, 50, 0, 0)`);
    }

    // Limite de taille du cache pour √©viter fuite m√©moire
    if (solarGradCache.size > 100) solarGradCache.clear();
    
    solarGradCache.set(key, g);
    return g;
}

// FONCTION MANAGER (√Ä appeler dans GameLoop)
function updateAndDrawParticles(ctx) {
    // 1. Nettoyage (supprimer les mortes)
    for (let i = activeParticles.length - 1; i >= 0; i--) {
        const p = activeParticles[i];
        p.update();
        if (p.life <= 0) {
            activeParticles.splice(i, 1);
        } else {
            p.draw(ctx);
        }
    }
}

// FONCTION SPAWNER (√Ä appeler quand JetOn = true)
function spawnJetParticles(x, y, skinId) {
    // D√©termine le type de particule selon le skin
    let type = "fire";
    if (skinId === "neon") type = "neon";
    if (skinId === "voidwalker") type = "void";

    // Ajoute 2 particules par frame pour un effet dense
    activeParticles.push(new Particle(x, y, type));
    activeParticles.push(new Particle(x + (Math.random()*10 - 5), y, type));
}

/* =========================
   DRAW PLAYER PARTICLES (OPTIMIS√â MOBILE / SKINS)
========================= */
function drawPlayerParticles(ctx){
  const arr = playerParticles;
  if (!arr.length) return;

  const isMobile = FXQuality.isMobile; // üî• D√©tection Mobile
  const allowGlow = (!isMobile && fps > 48 && fxCalm > 0.01);

  ctx.save();

  for (let i = arr.length - 1; i >= 0; i--){
    const p = arr[i];

    // ===== UPDATE =====
    p.x += p.vx;
    p.y += p.vy;
    p.life--;

    if (p.life <= 0){
      p.active = false;
      p._inList = false;
      arr.splice(i,1);
      continue;
    }

    const lifeRatio = p.life / p.lifeMax;
    if (lifeRatio <= 0.02){
      p.active = false;
      p._inList = false;
      arr.splice(i,1);
      continue;
    }

    ctx.globalAlpha = lifeRatio;

    // ‚ö° OPTIMISATION : Pas de shadowBlur sur mobile (trop lourd)
    if (allowGlow && p.glow > 0){
      ctx.shadowColor = p.color;
      ctx.shadowBlur  = p.glow * fxCalm;
    } else {
      ctx.shadowBlur = 0;
    }

    const x = p.x, y = p.y, s = p.size;

    switch (p.shape){

      // ===== DEFAULT (Moony) =====
      default:{
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = p.color;
        // Simplification math√©matique du rayon
        const r = s * (0.8 + lifeRatio * 0.6); 
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
      } break;

      // ===== LEAF (Forest) =====
      case "leaf":{
        ctx.globalCompositeOperation = "source-over";
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.ellipse(x, y, s * 1.1, s * 0.6, p.life * 0.15, 0, Math.PI * 2);
        ctx.fill();
      } break;

      // ===== SOLAR (Optimis√© Mobile) =====
      case "solar":{
        ctx.globalCompositeOperation = "lighter";
        const rr = s * (0.9 + lifeRatio * 0.9);

        ctx.save();
        ctx.translate(x, y);

        if (isMobile) {
          // üî• MOBILE : Pas de gradient, juste un cercle solide rapide
          ctx.fillStyle = "rgba(255, 200, 50, 0.6)"; 
          ctx.beginPath();
          ctx.arc(0, 0, rr * 2.5, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // üíª PC : Le beau gradient co√ªteux
          ctx.fillStyle = getSolarGradient(ctx, rr, lifeRatio);
          ctx.beginPath();
          ctx.arc(0, 0, rr * 3.1, 0, Math.PI * 2);
          ctx.fill();
        }

        // Coeur blanc (pour les deux)
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(0, 0, rr, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
        ctx.globalCompositeOperation = "source-over";
      } break;

      // ===== SNOW (Arctic) =====
      case "snow":{
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 1;
        const ss = s * 1.4 * lifeRatio;
        ctx.beginPath();
        ctx.moveTo(x - ss, y);
        ctx.lineTo(x + ss, y);
        ctx.moveTo(x, y - ss);
        ctx.lineTo(x, y + ss);
        ctx.stroke();
      } break;

      // ===== EMBER (Inferno) =====
      case "ember":{
        if (p.jx == null){
          p.jx = (Math.random() - 0.5) * 1.2;
          p.js = 0.5 + Math.random() * 0.6;
        }
        ctx.globalCompositeOperation = "source-over"; // Pas de lighter sur Inferno mobile ?
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(x + p.jx, y - (1 - lifeRatio) * 2, s * p.js, 0, Math.PI * 2);
        ctx.fill();
      } break;

      // ===== LINE (Neon) =====
      case "line":{
        ctx.globalCompositeOperation = "lighter";
        ctx.strokeStyle = p.color;
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - p.vx * 2, y - p.vy * 2);
        ctx.stroke();
        ctx.globalCompositeOperation = "source-over";
      } break;

      // ===== VOID (Voidwalker - Optimis√© Mobile) =====
      case "void":{
        ctx.globalCompositeOperation = "lighter";

        // üî• MOBILE : On saute le gros halo violet pour gagner 50% de perf
        if (!isMobile) {
            ctx.fillStyle = "rgba(120,90,180,0.75)";
            ctx.beginPath();
            ctx.arc(x, y, s * (0.9 + lifeRatio), 0, Math.PI * 2);
            ctx.fill();
        }

        // Coeur sombre (Toujours dessin√©)
        ctx.fillStyle = "rgba(15,8,25,0.9)";
        ctx.beginPath();
        ctx.arc(x, y, s * 0.45, 0, Math.PI * 2);
        ctx.fill();

        ctx.globalCompositeOperation = "source-over";
      } break;
    }
  }

  ctx.restore();
}






/* =========================
   FACE DISPATCH (SINGLE SOURCE)
========================= */
const FACE_FN = {
  moony:      drawMoonyFace,
  solar:      drawSolarFace,
  forest:     drawForestFace,
  arctic:     drawArcticFace,
  neon:       drawNeonFace,
  inferno:    drawInfernoFace,
  voidwalker: drawVoidFace
};

function getFaceFn(skinId){
  return FACE_FN[skinId] || drawMoonyFace;
}

/* =========================
   PLAYER ‚Äî RENDER (CLEAN / ORDER SAFE)
   - FX back
   - FACE (DEVANT)
   - FX front optionnel
========================= */



function drawPlayer(){
  const bx = player.x;
  const by = player.y;
  const bw = player.width;
  const bh = player.height;
  const vy = player.vy || 0;

  const skinId = currentSkin || "moony";
  const fxBack = SKIN_FX_BACK[skinId];
  const faceFn = getFaceFn(skinId);

  const VISUAL_SCALE = 1.42;

  ctx.save();

  // invincibility alpha
  if (player.invincible){
    ctx.globalAlpha = 0.7 + Math.sin(renderTime * 0.02) * 0.15;
  }

  // ===== TRANSFORM =====
ctx.translate((bx + bw * 0.5) | 0, (by + bh * 0.5) | 0);
  ctx.scale(VISUAL_SCALE, VISUAL_SCALE);

  const tilt = clamp(-vy * 0.04, -0.35, 0.35);
  ctx.rotate(tilt);
  ctx.translate(-bw * 0.5, -bh * 0.5);

  const hx = bw * 0.5;
  const hy = bh * 0.48;
  const headR = bw * 0.42;

  // ===== SHIELD =====
  if (player.invincible){
    ctx.save();
    ctx.globalCompositeOperation = "screen";

    const r = bw * 0.65;
    const g = ctx.createRadialGradient(hx, hy, r * 0.2, hx, hy, r);
    g.addColorStop(0, "rgba(160,220,255,0.35)");
    g.addColorStop(1, "rgba(160,220,255,0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(hx, hy, r, 0, Math.PI * 2);
    ctx.fill();

    ctx.restore();
  }

  // ===== FX BACK (CORRIG√â : renderTime en ms) =====
  if (fxBack){
    // ‚úÖ ICI : On envoie renderTime (ms) au lieu de fxTime (s)
    fxBack(ctx, 0, 0, bw, bh, renderTime, false);
  }

  // ===== FACE (Utilise fxTime global) =====
  faceFn(ctx, hx, hy, headR, vy);

  // ===== FX FRONT (CORRIG√â : renderTime en ms) =====
  if (skinId === "voidwalker"){
    // ‚úÖ ICI : On envoie renderTime (ms)
    drawVoidwalkerFrontFX(ctx, 0, 0, bw, bh, renderTime);
  }

  ctx.restore();
}

/* =========================
   SHOP PREVIEW ‚Äî MIRROR SAFE
========================= */
function drawPlayerPreview(pctx, skinId, t){
  const w = pctx.canvas.width;
  const h = pctx.canvas.height;

  const bw = 36;
  const bh = 32;
  const bx = (w - bw) * 0.5;
  const by = (h - bh) * 0.5 + 6;

  const fxBack = SKIN_FX_BACK[skinId] || drawMoonyFX;
  const faceFn = getFaceFn(skinId);

  pctx.save();
  pctx.translate(bx + bw * 0.5, by + bh * 0.5);
  pctx.scale(1.35, 1.35);
  pctx.translate(-bw * 0.5, -bh * 0.5);

  const hx = bw * 0.5;
  const hy = bh * 0.48;
  const headR = bw * 0.42;

  fxBack(pctx, 0, 0, bw, bh, t, true);
  faceFn(pctx, hx, hy, headR, 0);

  pctx.restore();
}

/* =========================================================
   üé® SKIN ROUTERS (LE PONT ENTRE LE SHOP ET LE DESSIN)
   Ces fonctions permettent au Shop d'appeler le bon dessin
   sans conna√Ætre les d√©tails techniques du jeu.
========================================================= */

// 1. ROUTEUR DE VISAGE (FACE)
function getFaceFn(skinId){
  // Associe le nom du skin √† la fonction de visage existante dans ton jeu
  switch(skinId){
    case "moony":      return drawMoonyFace;   // V√©rifie que ces noms existent bien
    case "solar":      return drawSolarFace;
    case "forest":     return drawForestFace;
    case "arctic":     return drawArcticFace;
    case "inferno":    return drawInfernoFace;
    case "neon":       return drawNeonFace;
    case "voidwalker": return drawVoidFace;    // Souvent appel√© drawVoidFace ou drawVoidwalkerFace
    default:           return drawMoonyFace;
  }
}

// 2. ROUTEUR FX ARRI√àRE (BACK)
// On cr√©e une map pour √©viter un switch g√©ant si possible, ou on garde le switch
const SKIN_FX_BACK = {
  "moony":      drawMoonyFX,
  "solar":      drawSolarFX,
  "forest":     drawForestFX,
  "arctic":     drawArcticFX,
  "inferno":    drawInfernoFX,
  "neon":       drawNeonFX,
  "voidwalker": drawVoidwalkerFX
};

// 3. ROUTEUR FX G√âN√âRAL (Appel√© par le preview)
function drawSkinFX(ctx, skinId, bx, by, bw, bh, t, isPreview){
  if (skipHeavyFX) return;


  
  if (fxFunc) {
    fxFunc(ctx, bx, by, bw, bh, t, isPreview);
  }
}

// 4. ROUTEUR FX AVANT (FRONT - Masques, lueurs par dessus le visage)
function drawSkinFrontFX(ctx, skinId, bx, by, bw, bh, t, isPreview){
  // Seuls certains skins ont des effets par dessus le visage
  if (skinId === "voidwalker"){
    // V√©rifie si cette fonction existe dans ton code, sinon commente la ligne
    if (typeof drawVoidwalkerFrontFX === "function") {
      drawVoidwalkerFrontFX(ctx, bx, by, bw, bh, t);
    }
  }
  // Tu peux ajouter d'autres skins ici si besoin (ex: lunettes pour Neon ?)
}

// ===== GLOBAL VARS =====
let moonyBlink = 1;
let nextBlink  = 0;
let blinkPhase = 0;

// ===== FONCTION MOONY "LIVING GUMMY" (AAA KAWAII) =====
function drawMoonyFace(ctx, hx, hy, r, vy){
  const t = fxTime;
  const isHappy = player.invincible; // Expression sp√©ciale quand invincible

  // --- 1. SQUASH & STRETCH (PHYSIQUE) ---
  // Plus fluide : on amortit la d√©formation
  const stretch = Math.max(-0.25, Math.min(0.25, vy * 0.015)); 
  const sx = 1 - stretch; 
  const sy = 1 + stretch;

  ctx.save();
  ctx.translate(hx, hy);
  ctx.scale(sx, sy);

  // --- 2. CORPS "GUMMY" (LUMI√àRE INTERNE) ---
  // On simule une mati√®re semi-transparente qui capte la lumi√®re
  const bodyGrad = ctx.createRadialGradient(0, -r*0.3, r*0.1, 0, 0, r);
  bodyGrad.addColorStop(0, "#ffffff");   // Highlight z√©nithal
  bodyGrad.addColorStop(0.4, "#ffffff"); // Corps blanc pur
  bodyGrad.addColorStop(0.85, "#ddeeff"); // L√©g√®re teinte bleut√©e (subsurface)
  bodyGrad.addColorStop(1, "#bbccee");    // Ombre de contour douce
  
  ctx.fillStyle = bodyGrad;
  ctx.beginPath();
  ctx.arc(0, 0, r, 0, Math.PI*2);
  ctx.fill();

  // Contour interne "Gel√©e" (Inner Glow)
  // √áa donne l'√©paisseur du mat√©riau
  const innerGlow = ctx.createRadialGradient(0, -r*0.2, r*0.8, 0, 0, r);
  innerGlow.addColorStop(0.8, "rgba(255,255,255,0)");
  innerGlow.addColorStop(1, "rgba(255,255,255,0.6)");
  ctx.fillStyle = innerGlow;
  ctx.fill();

  // --- 3. REBONDISSEMENT DU VISAGE (Face Lag) ---
  // Le visage a un l√©ger retard sur le corps pour l'inertie
  const faceY = r * 0.1 + (vy * 0.02); 

  // --- 4. JOUES (BREATHING) ---
  const breath = Math.sin(t * 2) * 0.05;
  const cheekY = faceY + r * 0.15;
  const cheekX = r * 0.55 + breath; // Les joues bougent avec la respiration
  
  ctx.fillStyle = "rgba(255, 120, 150, 0.5)"; // Rose soft
  ctx.beginPath(); ctx.ellipse(-cheekX, cheekY, r*0.18, r*0.12, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(cheekX, cheekY, r*0.18, r*0.12, 0, 0, Math.PI*2); ctx.fill();

  // --- 5. YEUX (REGARD DYNAMIQUE) ---
  // Calcul du regard (Look At)
  const lookY = Math.max(-r*0.15, Math.min(r*0.15, vy * 0.05)); // Regarde haut/bas
  
  // Gestion clignement
  if (!isHappy) { // On ne cligne pas si on fait l'expression "Happy"
      if (t > nextBlink && blinkPhase === 0) blinkPhase = 0.01;
      if (blinkPhase > 0) {
          blinkPhase += 0.25;
          moonyBlink = Math.abs(Math.cos(blinkPhase));
          if (blinkPhase > Math.PI) {
              blinkPhase = 0;
              moonyBlink = 1;
              nextBlink = t + 2 + Math.random() * 3;
          }
      }
  } else {
      moonyBlink = 1; // Yeux forc√©s ouverts pour dessiner l'arc
  }

  const eyeBaseY = faceY - r * 0.1;
  const eyeX = r * 0.26;
  const eyeSize = r * 0.24;

  if (isHappy) {
      // EXPRESSION : HAPPY (^ ^)
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.strokeStyle = "#151525";
      
      // Oeil Gauche ^
      ctx.beginPath();
      ctx.moveTo(-eyeX - eyeSize/2, eyeBaseY);
      ctx.lineTo(-eyeX, eyeBaseY - eyeSize/2);
      ctx.lineTo(-eyeX + eyeSize/2, eyeBaseY);
      ctx.stroke();

      // Oeil Droit ^
      ctx.beginPath();
      ctx.moveTo(eyeX - eyeSize/2, eyeBaseY);
      ctx.lineTo(eyeX, eyeBaseY - eyeSize/2);
      ctx.lineTo(eyeX + eyeSize/2, eyeBaseY);
      ctx.stroke();

  } else {
      // EXPRESSION : STANDARD (Yeux ouverts avec regard)
      ctx.fillStyle = "#151525"; // Noir doux

      // Oeil Gauche
      ctx.save();
      ctx.translate(-eyeX, eyeBaseY + lookY); // Ajout du lookY
      ctx.scale(1, moonyBlink);
      ctx.beginPath(); ctx.arc(0, 0, eyeSize, 0, Math.PI*2); ctx.fill();
      // Gros reflet
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(-eyeSize*0.3, -eyeSize*0.3, eyeSize*0.35, 0, Math.PI*2); ctx.fill();
      // Petit reflet bas
      ctx.beginPath(); ctx.arc(eyeSize*0.2, eyeSize*0.3, eyeSize*0.15, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // Oeil Droit
      ctx.fillStyle = "#151525";
      ctx.save();
      ctx.translate(eyeX, eyeBaseY + lookY); // Ajout du lookY
      ctx.scale(1, moonyBlink);
      ctx.beginPath(); ctx.arc(0, 0, eyeSize, 0, Math.PI*2); ctx.fill();
      // Gros reflet
      ctx.fillStyle = "#fff";
      ctx.beginPath(); ctx.arc(-eyeSize*0.3, -eyeSize*0.3, eyeSize*0.35, 0, Math.PI*2); ctx.fill();
      // Petit reflet bas
      ctx.beginPath(); ctx.arc(eyeSize*0.2, eyeSize*0.3, eyeSize*0.15, 0, Math.PI*2); ctx.fill();
      ctx.restore();
  }

  // --- 6. BOUCHE (R√âACTIVE) ---
  // La bouche change de forme selon l'effort
  // Si on monte fort (vy < 0) -> Petite bouche "o" (Effort)
  // Si on plane/tombe -> Sourire ":3"
  
  const mouthY = faceY + r * 0.28;
  ctx.lineCap = "round";
  ctx.strokeStyle = "#151525";
  ctx.lineWidth = 2.5;
  ctx.beginPath();

  if (vy < -2) {
      // Effort (Petit rond)
      ctx.arc(0, mouthY, r*0.06, 0, Math.PI*2);
  } else {
      // Normal (Petit sourire mignon)
      // Forme en W tr√®s doux
      const w = r * 0.1;
      ctx.moveTo(-w, mouthY - w*0.3);
      ctx.quadraticCurveTo(0, mouthY + w*0.8, w, mouthY - w*0.3);
  }
  ctx.stroke();

  ctx.restore(); // Fin Squash
}

/* =========================================================
   üõ†Ô∏è GLOBAL HELPERS (ESSENTIEL POUR √âVITER LES CRASH)
   D√©finis une seule fois ici pour tout le monde.
========================================================= */

// Quantize (Arrondir par pas pour les cl√©s de cache)
window._q = function(v, step){ return Math.round(v / step) * step; };

// Quantize 0..1 vers un index entier
window._qi01 = function(v, steps){
  const x = v < 0 ? 0 : (v > 1 ? 1 : v);
  return (x * steps) | 0;
};

// --- HELPER KAWAII (Pour Forest & Arctic uniquement) ---
function drawKawaiiFaceFeatures(ctx, r, t, isInvincible, vy) {
  // Gestion clignement global
  if (typeof window.blinkGlobal === 'undefined') { window.blinkGlobal = 1; window.nextBlinkGlobal = 0; window.blinkPhaseGlobal = 0; }
  
  if (!isInvincible) {
      if (t > window.nextBlinkGlobal && window.blinkPhaseGlobal === 0) window.blinkPhaseGlobal = 0.01;
      if (window.blinkPhaseGlobal > 0) {
          window.blinkPhaseGlobal += 0.25;
          window.blinkGlobal = Math.abs(Math.cos(window.blinkPhaseGlobal));
          if (window.blinkPhaseGlobal > Math.PI) {
              window.blinkPhaseGlobal = 0;
              window.blinkGlobal = 1;
              window.nextBlinkGlobal = t + 2 + Math.random() * 3;
          }
      }
  } else { window.blinkGlobal = 1; }

  const blink = window.blinkGlobal;
  const lookY = Math.max(-r*0.15, Math.min(r*0.15, vy * 0.05));
  const eyeX = r * 0.28;
  const eyeY = -r * 0.05;
  const eyeSize = r * 0.22;

  // Yeux
  if (isInvincible) {
      ctx.lineWidth = 3; ctx.lineCap = "round"; ctx.strokeStyle = "#151525";
      ctx.beginPath(); ctx.moveTo(-eyeX - eyeSize/2, eyeY); ctx.lineTo(-eyeX, eyeY - eyeSize/2); ctx.lineTo(-eyeX + eyeSize/2, eyeY); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(eyeX - eyeSize/2, eyeY); ctx.lineTo(eyeX, eyeY - eyeSize/2); ctx.lineTo(eyeX + eyeSize/2, eyeY); ctx.stroke();
  } else {
      ctx.fillStyle = "#151525";
      const drawEye = (x) => {
          ctx.save(); ctx.translate(x, eyeY + lookY); ctx.scale(1, blink);
          ctx.beginPath(); ctx.arc(0, 0, eyeSize, 0, Math.PI*2); ctx.fill();
          ctx.fillStyle = "#fff";
          ctx.beginPath(); ctx.arc(-eyeSize*0.3, -eyeSize*0.3, eyeSize*0.35, 0, Math.PI*2); ctx.fill(); // Reflet
          ctx.restore();
      };
      drawEye(-eyeX); drawEye(eyeX);
  }
  // Bouche
  const mouthY = r * 0.25;
  ctx.lineCap = "round"; ctx.strokeStyle = "#151525"; ctx.lineWidth = 2.5;
  ctx.beginPath();
  if (vy < -2) ctx.arc(0, mouthY, r*0.06, 0, Math.PI*2);
  else { ctx.moveTo(-r*0.1, mouthY-r*0.03); ctx.quadraticCurveTo(0, mouthY+r*0.08, r*0.1, mouthY-r*0.03); }
  ctx.stroke();
  // Joues
  ctx.fillStyle = "rgba(255, 120, 150, 0.4)";
  ctx.beginPath(); ctx.arc(-r*0.55, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(r*0.55, r*0.15, r*0.15, 0, Math.PI*2); ctx.fill();
}

/* =========================================================
   üõ†Ô∏è GLOBAL HELPERS
========================================================= */
window._q = function(v, step){ return Math.round(v / step) * step; };
window._qi01 = function(v, steps){ const x = v < 0 ? 0 : (v > 1 ? 1 : v); return (x * steps) | 0; };
function lerpColor(r1, g1, b1, r2, g2, b2, factor) {
    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);
    return `rgb(${r}, ${g}, ${b})`;
}

/* =========================================================
   üîÆ NEON FACE ‚Äî HD & CLEAN EXPRESSIONS
   - Traits fins et pr√©cis
   - Bouche bien s√©par√©e des yeux
   - Expressions digitales claires
========================================================= */
const _neonFaceState = { idx: 0, nextT: 0 };

function drawNeonFace(ctx, hx, hy, r, vy){
  const t = performance.now();
  // Clignotement l√©ger du contour uniquement
  const flicker = 0.9 + Math.random() * 0.1;

  ctx.save();
  ctx.translate(hx, hy);

  // 1. CASQUE (Fond sombre propre)
  ctx.fillStyle = "#050510"; 
  ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

  // Contour N√©on (Fin et brillant)
  ctx.globalAlpha = flicker;
  ctx.strokeStyle = "#0ff"; 
  ctx.lineWidth = 2; 
  ctx.shadowColor = "#0ff"; ctx.shadowBlur = 10;
  ctx.beginPath(); ctx.arc(0, 0, r*0.92, 0, Math.PI*2); ctx.stroke();
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 1.0; 

  // 2. GESTION DES EXPRESSIONS
  if (t > _neonFaceState.nextT) {
      // Choix al√©atoire : 0=Normal, 1=Happy, 2=Skeptic, 3=Glitch
      const rand = Math.random();
      if(rand < 0.5) _neonFaceState.idx = 0;
      else if(rand < 0.75) _neonFaceState.idx = 1;
      else if(rand < 0.9) _neonFaceState.idx = 2;
      else _neonFaceState.idx = 3;
      
      _neonFaceState.nextT = t + 2000 + Math.random() * 2000;
  }

  // Configuration du trait (FIN et NET)
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.strokeStyle = "#0ff";
  ctx.lineWidth = r * 0.08; // Trait proportionnel et fin (~1.5px)
  
  // Pas de shadowBlur sur le visage pour garder la nettet√©
  // ou tr√®s l√©ger
  ctx.shadowColor = "#0ff"; ctx.shadowBlur = 2;

  // Coordonn√©es espac√©es
  const eyeY = -r * 0.15;  // Yeux plus haut
  const mouthY = r * 0.35; // Bouche plus bas
  const ex = r * 0.32;     // Ecartement X
  const es = r * 0.18;     // Taille symbole

  switch(_neonFaceState.idx) {
      case 0: // NORMAL [  ]  [  ] + Trait
          // Yeux (Rectangles vides nets)
          ctx.strokeRect(-ex - es, eyeY - es/2, es*1.2, es);
          ctx.strokeRect(ex - es*0.2, eyeY - es/2, es*1.2, es);
          // Bouche (Trait simple)
          ctx.beginPath(); ctx.moveTo(-ex/2, mouthY); ctx.lineTo(ex/2, mouthY); ctx.stroke();
          break;

      case 1: // HAPPY ^  ^ + Sourire
          // Oeil G
          ctx.beginPath(); 
          ctx.moveTo(-ex - es, eyeY); ctx.lineTo(-ex - es/2, eyeY - es); ctx.lineTo(-ex, eyeY); 
          ctx.stroke();
          // Oeil D
          ctx.beginPath(); 
          ctx.moveTo(ex, eyeY); ctx.lineTo(ex + es/2, eyeY - es); ctx.lineTo(ex + es, eyeY); 
          ctx.stroke();
          // Bouche (U)
          ctx.beginPath(); ctx.arc(0, mouthY - es/2, es, 0.2, Math.PI-0.2); ctx.stroke();
          break;

      case 2: // SKEPTIC -  O + Bouche d√©cal√©e
          // Oeil G (Trait)
          ctx.beginPath(); ctx.moveTo(-ex - es, eyeY); ctx.lineTo(-ex, eyeY); ctx.stroke();
          // Oeil D (Rond)
          ctx.beginPath(); ctx.arc(ex + es/2, eyeY, es/2, 0, Math.PI*2); ctx.stroke();
          // Bouche (Petit trait c√¥t√©)
          ctx.beginPath(); ctx.moveTo(0, mouthY); ctx.lineTo(ex, mouthY); ctx.stroke();
          break;
      
      case 3: // GLITCH >  < + Zigzag
          ctx.strokeStyle = "#f0f"; ctx.shadowColor = "#f0f";
          // Yeux > <
          ctx.beginPath(); ctx.moveTo(-ex - es, eyeY - es/2); ctx.lineTo(-ex, eyeY); ctx.lineTo(-ex - es, eyeY + es/2); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(ex + es, eyeY - es/2); ctx.lineTo(ex, eyeY); ctx.lineTo(ex + es, eyeY + es/2); ctx.stroke();
          // Bouche W
          ctx.beginPath(); 
          ctx.moveTo(-ex/2, mouthY); 
          ctx.lineTo(-ex/4, mouthY+es/2); ctx.lineTo(0, mouthY); ctx.lineTo(ex/4, mouthY+es/2); ctx.lineTo(ex/2, mouthY);
          ctx.stroke();
          break;
  }
  ctx.shadowBlur = 0;
  ctx.restore();
}

/* =========================================================
   üåø FOREST FACE (Kawaii Helper)
========================================================= */
const _forestGrad = new Map();
function drawForestFace(ctx, hx, hy, r, vy) {
    const t = performance.now() / 1000;
    const stretch = Math.max(-0.2, Math.min(0.2, vy * 0.015));
    ctx.save(); ctx.translate(hx, hy); ctx.scale(1 - stretch, 1 + stretch);
    let grad = _forestGrad.get("body");
    if(!grad){
        grad = ctx.createRadialGradient(0, -r*0.3, r*0.1, 0, 0, r);
        grad.addColorStop(0, "#ddffdd"); grad.addColorStop(1, "#448844");
        _forestGrad.set("body", grad);
    }
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(0, -r * 0.9); ctx.rotate(Math.sin(t * 2) * 0.1);
    ctx.fillStyle = "#22aa22"; ctx.beginPath(); ctx.ellipse(0, -r*0.2, r*0.15, r*0.3, 0, 0, Math.PI*2); ctx.fill();
    ctx.restore();
    drawKawaiiFaceFeatures(ctx, r, t, player.invincible, vy);
    ctx.restore();
}

/* =========================================================
   ‚ùÑÔ∏è ARCTIC FACE (NOUVEAU DESIGN SPHERE)
========================================================= */
const _arcticGradBody = new Map();
function drawArcticFace(ctx, hx, hy, r, vy) {
    const t = performance.now() / 1000;
    const hover = Math.sin(t * 1.5) * 2;
    ctx.save(); ctx.translate(hx, hy + hover);
    const rq = _q(r, 0.5);
    let grad = _arcticGradBody.get(rq);
    if(!grad){
        grad = ctx.createRadialGradient(-rq*0.3, -rq*0.3, rq*0.1, 0, 0, rq);
        grad.addColorStop(0, "#ffffff"); grad.addColorStop(0.4, "#d0f0ff"); grad.addColorStop(1, "#60a0ff");
        _arcticGradBody.set(rq, grad);
    }
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#e0ffff"; ctx.beginPath();
    ctx.moveTo(-r*0.6, -r*0.5); ctx.lineTo(-r*0.4, -r*0.9); ctx.lineTo(-r*0.2, -r*0.6); 
    ctx.lineTo(0, -r*1.0); ctx.lineTo(r*0.2, -r*0.6); ctx.lineTo(r*0.4, -r*0.9); ctx.lineTo(r*0.6, -r*0.5); ctx.fill();
    ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(0, 0, r*0.85, Math.PI, Math.PI*1.5); ctx.stroke();
    const lookY = vy * 0.05;
    ctx.fillStyle = "#004488"; ctx.beginPath(); ctx.ellipse(-r*0.25, -r*0.05+lookY, r*0.12, r*0.18, 0, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.ellipse(r*0.25, -r*0.05+lookY, r*0.12, r*0.18, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#004488"; ctx.beginPath(); ctx.arc(0, r*0.3, r*0.06, 0, Math.PI*2); ctx.fill(); 
    const breath = (Math.sin(t * 3) + 1) * 0.5; 
    if (breath > 0.2) {
        ctx.fillStyle = `rgba(255, 255, 255, ${breath * 0.4})`;
        ctx.beginPath(); ctx.arc(0, r*0.4 + breath*5, r*0.15 * breath, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
}

/* =========================================================
   üî• INFERNO FACE (CRESCENDO)
========================================================= */
const _infernoGradSkin = new Map();
function drawInfernoFace(ctx, hx, hy, r, vy){
  const t = performance.now() / 1000;
  const rawHeat = Math.sin(t * 2); 
  const heat = (rawHeat + 1) * 0.5;
  ctx.save(); ctx.translate(hx, hy);
  const rq = _q(r, 0.5);
  const hIdx = Math.floor(heat * 20); 
  const key = rq + "_" + hIdx;
  let skin = _infernoGradSkin.get(key);
  if (!skin){
      skin = ctx.createRadialGradient(-rq*0.2, -rq*0.2, rq*0.1, 0, 0, rq);
      if (heat < 0.5) {
          const f = heat * 2; 
          skin.addColorStop(0, lerpColor(150,0,0, 255,60,0, f));
          skin.addColorStop(0.5, lerpColor(100,0,0, 200,20,0, f));
          skin.addColorStop(1, "#220000");
      } else {
          const f = (heat - 0.5) * 2; 
          skin.addColorStop(0, lerpColor(255,60,0, 255,255,200, f)); 
          skin.addColorStop(0.5, lerpColor(200,20,0, 255,150,0, f)); 
          skin.addColorStop(1, lerpColor(34,0,0, 100,20,0, f)); 
      }
      _infernoGradSkin.set(key, skin);
  }
  ctx.fillStyle = skin; ctx.beginPath();
  for(let i=0; i<8; i++){
      const a = (Math.PI*2*i)/8; const d = r * (0.92 + Math.cos(i*10)*0.08); 
      if (i===0) ctx.moveTo(Math.cos(a)*d, Math.sin(a)*d); else ctx.lineTo(Math.cos(a)*d, Math.sin(a)*d);
  }
  ctx.fill();
  ctx.strokeStyle = (heat > 0.8) ? "#fff" : "rgba(255, 100, 0, 0.8)"; ctx.lineWidth = 2;
  if(heat > 0.3) { ctx.shadowColor = "#ff4400"; ctx.shadowBlur = heat * 20; }
  ctx.beginPath(); ctx.moveTo(-r*0.4, -r*0.4); ctx.lineTo(0, -r*0.1); ctx.lineTo(r*0.3, -r*0.5);
  ctx.moveTo(-r*0.1, r*0.5); ctx.lineTo(r*0.2, r*0.2); ctx.stroke(); ctx.shadowBlur = 0;
  ctx.fillStyle = (heat > 0.9) ? "#fff" : "#ffcc00"; 
  const lookY = vy * 0.05;
  ctx.beginPath(); ctx.moveTo(-r*0.6, -r*0.25+lookY); ctx.lineTo(-r*0.2, -r*0.25+lookY); ctx.lineTo(-r*0.4, -r*0.05+lookY); ctx.fill();
  ctx.beginPath(); ctx.moveTo(r*0.6, -r*0.25+lookY); ctx.lineTo(r*0.2, -r*0.25+lookY); ctx.lineTo(r*0.4, -r*0.05+lookY); ctx.fill();
  ctx.restore();
}

/* =========================================================
   ‚òÄÔ∏è SOLAR & üï≥Ô∏è VOID (Gard√©s tels quels)
========================================================= */
const _solarGradCorona = new Map();
const _solarGradSkin = new Map();
function drawSolarFace(ctx, hx, hy, r, vy){
  const t = performance.now() / 1000;
  const vib = Math.sin(t * 30) * 0.03; 
  ctx.save(); ctx.translate(hx, hy); ctx.scale(1 + vib, 1 - vib);
  const rq = _q(r, 0.5); 
  ctx.save(); ctx.rotate(t * 1.5); 
  let coronaGrad = _solarGradCorona.get(rq);
  if (!coronaGrad){
      coronaGrad = ctx.createRadialGradient(0, 0, rq*0.8, 0, 0, rq*1.6);
      coronaGrad.addColorStop(0, "rgba(255, 200, 0, 0.9)"); coronaGrad.addColorStop(1, "rgba(255, 50, 0, 0)");
      _solarGradCorona.set(rq, coronaGrad);
  }
  ctx.fillStyle = coronaGrad;
  const spikes = 10; ctx.beginPath();
  for(let i=0; i<spikes*2; i++){
      const a = (Math.PI*2 * i) / (spikes*2); const d = (i%2===0) ? rq*1.5 : rq*1.1;
      ctx.lineTo(Math.cos(a)*d, Math.sin(a)*d);
  }
  ctx.fill(); ctx.restore();
  let skinGrad = _solarGradSkin.get(rq);
  if (!skinGrad){
      skinGrad = ctx.createRadialGradient(-rq*0.2, -rq*0.3, rq*0.1, 0, 0, rq);
      skinGrad.addColorStop(0, "#fff"); skinGrad.addColorStop(0.3, "#fc0"); skinGrad.addColorStop(0.8, "#f50"); skinGrad.addColorStop(1, "#a00");
      _solarGradSkin.set(rq, skinGrad);
  }
  ctx.fillStyle = skinGrad; ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();
  const lookY = vy * 0.05;
  ctx.fillStyle = "#fff"; ctx.shadowColor = "#f00"; ctx.shadowBlur = 15;
  ctx.beginPath(); ctx.ellipse(-r*0.3, -r*0.05 + lookY, r*0.22, r*0.15, 0.2, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.3, -r*0.05 + lookY, r*0.22, r*0.15, -0.2, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0; ctx.restore();
}

const _voidDiskCache = new Map();
function drawVoidFace(ctx, hx, hy, r, vy){
  const t = performance.now() / 1000;
  ctx.save(); ctx.translate(hx, hy);
  const rq = _q(r, 0.5);
  ctx.save(); ctx.rotate(t * 2); 
  let diskGrad = _voidDiskCache.get(rq);
  if (!diskGrad) {
      diskGrad = ctx.createRadialGradient(0, 0, rq*0.5, 0, 0, rq*1.2);
      diskGrad.addColorStop(0, "rgba(0,0,0,0)"); diskGrad.addColorStop(0.6, "rgba(75, 0, 130, 0.8)"); diskGrad.addColorStop(1, "rgba(0, 0, 0, 0)");
      _voidDiskCache.set(rq, diskGrad);
  }
  ctx.fillStyle = diskGrad; ctx.beginPath(); ctx.arc(0, 0, r*1.2, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle = "#fff";
  for(let i=0; i<6; i++) {
     const angle = (i * Math.PI / 3); const dist = r * 0.9;
     ctx.beginPath(); ctx.arc(Math.cos(angle)*dist, Math.sin(angle)*dist, 2, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
  ctx.shadowColor = "#fff"; ctx.shadowBlur = 10; ctx.strokeStyle = "#fff"; ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0, 0, r*0.65, 0, Math.PI*2); ctx.stroke(); ctx.shadowBlur = 0;
  ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0, 0, r*0.6, 0, Math.PI*2); ctx.fill();
  const lookY = vy * 0.05;
  ctx.fillStyle = "#fff"; ctx.shadowColor = "#a0f"; ctx.shadowBlur = 15;
  ctx.beginPath(); ctx.ellipse(-r*0.25, -r*0.05 + lookY, r*0.1, r*0.25, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(r*0.25, -r*0.05 + lookY, r*0.1, r*0.25, 0, 0, Math.PI*2); ctx.fill();
  ctx.shadowBlur = 0; ctx.restore();
}

/* =========================================================
   MOONY FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî cache OK
   ‚úî FIX MAJEUR : ctx.restore() GARANTI
========================================================= */

const _moonyHaloCache = new Map();

function drawMoonyFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è restore toujours garanti
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw * 0.5;
  const cy = by + bh * 0.5 + bh * 0.1;

  // pulsation douce (inchang√©e)
  const pulse = 0.85 + Math.sin(t * 1.8) * 0.15;

  /* =========================
     HALO LUNAIRE ARRI√àRE
  ========================= */
  const rY = bh * (isPreview ? 1.05 : 1.25);
  const rX = bw * 1.05;

  // cl√© stable (pas de float instable)
  const key = bw + "|" + bh + "|" + (isPreview ? 1 : 0);
  let g = _moonyHaloCache.get(key);

  if (!g){
    g = ctx.createRadialGradient(
      cx, cy, bh * 0.15,
      cx, cy, rY
    );
    g.addColorStop(0.0, "rgba(255,245,210,0.55)");
    g.addColorStop(0.45,"rgba(180,200,255,0.25)");
    g.addColorStop(1.0, "rgba(0,0,0,0)");

    if (_moonyHaloCache.size > 12) _moonyHaloCache.clear();
    _moonyHaloCache.set(key, g);
  }

  ctx.globalAlpha = pulse * (isPreview ? 0.55 : 0.85);
  ctx.fillStyle = g;

  ctx.beginPath();
  ctx.ellipse(cx, cy, rX, rY, 0, 0, Math.PI * 2);
  ctx.fill();

  /* =========================
     PARTICULES ORBITALES
     (runtime uniquement)
  ========================= */
  if (!isPreview){
    ctx.globalAlpha = 0.75;
    ctx.fillStyle = "rgba(255,250,230,0.95)";

    const baseA = t * 0.6;
    const r = bw * 0.55;

    // 4 particules fixes ‚Üí stable / zero random
    for (let i = 0; i < 4; i++){
      const a = baseA + i * (Math.PI * 0.5);
      const px = cx + Math.cos(a) * r;
      const py = cy + Math.sin(a) * r * 0.7;

      ctx.beginPath();
      ctx.arc(px, py, 1.1, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  ctx.restore();
}





/* =========================================================
   FOREST FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî cache conserv√©
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
========================================================= */

const _forestGradCache = new Map();

function _getForestGrad(ctx, key, maker){
  let g = _forestGradCache.get(key);
  if (!g){
    g = maker();
    if (_forestGradCache.size > 24) _forestGradCache.clear();
    _forestGradCache.set(key, g);
  }
  return g;
}

function drawForestFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è ne jamais return apr√®s save()
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.5;
  const R  = Math.min(bw, bh) * 0.82;

  const time = t * 0.001; // t = fxTime unifi√©
  const I = isPreview ? 0.65 : 1.0;
  const TAU = Math.PI * 2;

  const clamp01 = v => Math.max(0, Math.min(1, v));
  const pulse = (s, ph=0)=> 0.5 + 0.5*Math.sin(time*s + ph);
  const hash = n => { const x = Math.sin(n*127.1)*43758.5453; return x - Math.floor(x); };

  function runeStroke(c, x, y, s, rot){
    c.save();
    c.translate(x,y);
    c.rotate(rot);
    c.lineWidth = 1.15 * I;
    c.lineCap = "round";
    c.beginPath();
    c.moveTo(-s*0.6, -s*0.25);
    c.lineTo( s*0.25, -s*0.25);
    c.lineTo( s*0.25,  s*0.55);
    c.moveTo(-s*0.2,  s*0.1);
    c.lineTo( s*0.6,  s*0.1);
    c.stroke();
    c.restore();
  }

  /* ===== 0) FOG / AURA ===== */
  const breathe = 0.86 + 0.14*Math.sin(time*1.7);
  const fog = _getForestGrad(
    ctx,
    `fog_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.10, cx, cy, R*1.25);
      g.addColorStop(0.00, `rgba(220,255,235,${0.18*I})`);
      g.addColorStop(0.28, `rgba(130,220,170,${0.18*I})`);
      g.addColorStop(0.60, `rgba(35,110,75,${0.20*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = breathe;
  ctx.fillStyle = fog;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.25, 0, TAU);
  ctx.fill();

  /* ===== 1) VORTEX ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = 0.55 * I;

  const swirl = _getForestGrad(
    ctx,
    `swirl_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.15, cx, cy, R*1.05);
      g.addColorStop(0.00, "rgba(255,255,255,0)");
      g.addColorStop(0.35, `rgba(150,255,205,${0.18*I})`);
      g.addColorStop(0.70, `rgba(80,190,130,${0.14*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.save();
  ctx.translate(
    cx + Math.sin(time*1.2)*R*0.02,
    cy + Math.cos(time*1.0)*R*0.02
  );
  ctx.rotate(time*0.22);
  ctx.scale(1.05, 0.82);
  ctx.fillStyle = swirl;
  ctx.beginPath();
  ctx.arc(0, 0, R*1.05, 0, TAU);
  ctx.fill();
  ctx.restore();

  ctx.globalCompositeOperation = "source-over";

  /* ===== 2) RING ===== */
  const ringRot = time * 0.35;
  const ringPulse = 0.75 + 0.25*pulse(2.6, 0.4);

  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = (isPreview ? 0.38 : 0.62) * I * ringPulse;
  ctx.lineWidth = 2.4 * I;

  const ringG = _getForestGrad(
    ctx,
    `ring_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.70, cx, cy, R*1.02);
      g.addColorStop(0.0, `rgba(170,255,220,${0.10*I})`);
      g.addColorStop(0.55,`rgba(110,235,170,${0.42*I})`);
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.strokeStyle = ringG;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.92, 0, TAU);
  ctx.stroke();

  ctx.globalCompositeOperation = "source-over";

  /* ===== 3) RUNES ===== */
  const runeCount = isPreview ? 10 : 16;
  ctx.globalAlpha = (isPreview ? 0.42 : 0.70) * I;
  ctx.strokeStyle = "rgba(200,255,230,0.85)";
  for(let i=0;i<runeCount;i++){
    const a = ringRot + i*(TAU/runeCount);
    runeStroke(
      ctx,
      cx + Math.cos(a)*R*0.83,
      cy + Math.sin(a)*R*0.83*0.86,
      R*(0.06 + 0.01*Math.sin(time*3 + i)),
      a + Math.PI/2
    );
  }

  /* ===== 4) LUCIOLES ===== */
  ctx.globalCompositeOperation = "screen";
  const fireflies = isPreview ? 6 : 14;

  for(let i=0;i<fireflies;i++){
    const seed = i*19.73;
    const a = time*(0.7 + 0.03*i) + seed;
    const rr = R*(0.20 + 0.55*hash(seed+1));
    const x = cx + Math.cos(a)*rr;
    const y = cy + Math.sin(a*1.18)*rr*0.78;
    const tw = clamp01(0.25 + 0.75*pulse(5.0, i*1.4));
    const r = (isPreview ? 1.4 : 2.0) * (0.7 + tw) * I;

    ctx.globalAlpha = (isPreview ? 0.55 : 0.85) * tw * I;
    ctx.fillStyle = "rgba(210,255,235,1)";
    ctx.beginPath();
    ctx.arc(x, y, r, 0, TAU);
    ctx.fill();

    ctx.globalAlpha *= 0.25;
    ctx.beginPath();
    ctx.arc(x, y, r*3.0, 0, TAU);
    ctx.fill();
  }

  /* ===== 5) CORE ===== */
  ctx.globalCompositeOperation = "screen";
  const corePulse = 0.55 + 0.45*Math.sin(time*3.1);

  const coreG = _getForestGrad(
    ctx,
    `core_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*0.46);
      g.addColorStop(0.0, `rgba(235,255,245,${0.22*corePulse*I})`);
      g.addColorStop(0.35,`rgba(170,255,215,${0.14*I})`);
      g.addColorStop(1.0, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 1;
  ctx.fillStyle = coreG;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.46, 0, TAU);
  ctx.fill();

  ctx.restore();
}


/* =========================================================
   SOLAR FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
   ‚úî time UNIFI√â (t = fxTime en ms)
========================================================= */
/* =========================
   HELPER MANQUANT : SOLAR GRADIENT
========================= */
const _solarTrailCache = new Map();

function getSolarGradient(ctx, r, life){
  // On arrondit les valeurs pour que le cache fonctionne
  const rq = Math.round(r); 
  const lq = Math.round(life * 10); 
  const key = `${rq}_${lq}`;

  let g = _solarTrailCache.get(key);
  
  if (!g){
    // Cr√©ation du d√©grad√© (Jaune -> Orange -> Transparent)
    g = ctx.createRadialGradient(0, 0, 0, 0, 0, r);
    g.addColorStop(0, "rgba(255, 255, 200, 1)");      // Coeur blanc/jaune
    g.addColorStop(0.4, "rgba(255, 160, 0, 0.8)");    // Corps orange
    g.addColorStop(1, "rgba(255, 50, 0, 0)");         // Bord rouge transparent

    // Nettoyage si trop gros
    if (_solarTrailCache.size > 50) _solarTrailCache.clear();
    _solarTrailCache.set(key, g);
  }
  return g;
}
const _solarGradCache = new Map();

function _getSolarGrad(key, maker){
  let g = _solarGradCache.get(key);
  if (!g){
    g = maker();
    if (_solarGradCache.size > 32) _solarGradCache.clear();
    _solarGradCache.set(key, g);
  }
  return g;
}

function drawSolarFX(ctx, bx, by, bw, bh, t, isPreview = false){
  // ‚ö†Ô∏è ne jamais return apr√®s save()
  if (skipHeavyFX) return;

  ctx.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.5;
  const R  = Math.min(bw, bh) * 0.80;

  const time = t * 0.001; // t = fxTime unifi√© (ms)
  const I = isPreview ? 0.65 : 1.0;

  const TAU = Math.PI*2;
  const clamp01 = v => Math.max(0, Math.min(1, v));
  const n1 = x => Math.sin(x)*0.5 + Math.sin(x*2.3+1.2)*0.25 + Math.sin(x*4.7+2.6)*0.15;

  /* ===== 0) SHIMMER ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.globalAlpha = 0.10 * I;

  const shimmer = _getSolarGrad(
    `shimmer_${bw}_${bh}`, // (identique)
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.15, cx, cy, R*1.05);
      g.addColorStop(0,   "rgba(120,200,255,0.00)");
      g.addColorStop(0.5, "rgba(255,180,60,0.10)");
      g.addColorStop(1,   "rgba(255,120,20,0.00)");
      return g;
    }
  );

  ctx.fillStyle = shimmer;
  ctx.beginPath();
  ctx.arc(
    cx + Math.sin(time*2.1)*R*0.015,
    cy + Math.cos(time*1.7)*R*0.015,
    R*1.05, 0, TAU
  );
  ctx.fill();

  /* ===== 1) HALOS ===== */
  const breath = 0.78 + 0.22 * (0.5 + 0.5*Math.sin(time*2.2));

  const halo1 = _getSolarGrad(
    `halo1_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.12, cx, cy, R*1.05);
      g.addColorStop(0.00, `rgba(255,255,235,${0.75*I})`);
      g.addColorStop(0.30, `rgba(255,210,120,${0.55*I})`);
      g.addColorStop(0.62, `rgba(255,140,35,${0.32*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 0.95 * breath * (isPreview ? 0.75 : 1);
  ctx.fillStyle = halo1;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.05, 0, TAU);
  ctx.fill();

  const halo2 = _getSolarGrad(
    `halo2_${bw}_${bh}_${I}`,
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, R*0.35, cx, cy, R*1.25);
      g.addColorStop(0.00, `rgba(255,180,70,${0.12*I})`);
      g.addColorStop(0.60, `rgba(255,120,25,${0.10*I})`);
      g.addColorStop(1.00, "rgba(0,0,0,0)");
      return g;
    }
  );

  ctx.globalAlpha = 1;
  ctx.fillStyle = halo2;
  ctx.beginPath();
  ctx.arc(cx, cy, R*1.25, 0, TAU);
  ctx.fill();

  /* ===== 2) COURONNE ===== */
  ctx.globalCompositeOperation = "screen";
  ctx.lineCap = "round";

  const coronaPts = isPreview ? 26 : 34;
  const rot = time*0.65;
  const ampBase = isPreview ? 0.055 : 0.085;

  for(let pass=0; pass<2; pass++){
    ctx.lineWidth = (pass===0 ? 2.6 : 1.2) * I;
    ctx.globalAlpha = (pass===0 ? 0.22 : 0.55) * I;
    ctx.strokeStyle = pass===0
      ? "rgba(255,150,35,0.85)"
      : "rgba(255,220,140,0.95)";

    ctx.beginPath();
    for(let i=0;i<=coronaPts;i++){
      const u = i/coronaPts;
      const ang = u*TAU + rot;
      const spiky = Math.max(0, n1(time*2.8 + u*12.0)) * (isPreview?0.5:1.0);
      const wave  = n1(time*1.6 + u*7.5);
      const amp = ampBase + spiky*0.06;
      const rr  = R * (0.90 + wave*amp + Math.sin(time*3.3 + u*TAU*2.0)*0.015);
      const x = cx + Math.cos(ang) * rr;
      const y = cy + Math.sin(ang) * rr;
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.stroke();
  }

  /* ===== 3) RAYONS ===== */
  const rays = isPreview ? 7 : 12;
  const rayBase = time*0.55;

  for(let i=0;i<rays;i++){
    const u = i/rays;
    const ang = rayBase + u*TAU;
    const pulseV = 0.55 + 0.45*(0.5 + 0.5*Math.sin(time*3.2 + i*1.7));
    const jitter = n1(time*5.0 + i*2.0) * 0.06;

    const len = R * (1.05 + pulseV*0.55);
    const inner = R * (0.45 + jitter*0.15);

    const x1 = cx + Math.cos(ang)*inner;
    const y1 = cy + Math.sin(ang)*inner;
    const x2 = cx + Math.cos(ang)*len;
    const y2 = cy + Math.sin(ang)*len;

    const g = _getSolarGrad(
      `ray_${bw}_${bh}_${i}`, // (identique)
      ()=> {
        const gg = ctx.createLinearGradient(x1,y1,x2,y2);
        gg.addColorStop(0.00, "rgba(255,230,160,0.00)");
        gg.addColorStop(0.25, `rgba(255,210,110,${0.65*I})`);
        gg.addColorStop(0.55, `rgba(255,140,45,${0.35*I})`);
        gg.addColorStop(1.00, "rgba(255,120,25,0.00)");
        return gg;
      }
    );

    ctx.strokeStyle = g;
    ctx.globalAlpha = (isPreview ? 0.42 : 0.75) * pulseV * I;
    ctx.lineWidth = (isPreview ? 2.0 : 2.8) * I;
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();

    ctx.globalAlpha *= 0.75;
    ctx.lineWidth = (isPreview ? 0.9 : 1.3) * I;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(
      x2 + Math.cos(ang-0.9)*R*0.020,
      y2 + Math.sin(ang-0.9)*R*0.020
    );
    ctx.stroke();
  }

  /* ===== 4) PARTICULES ===== */
  const pCount = isPreview ? 6 : 14;
  ctx.fillStyle = "rgba(255,235,180,1)";
  for(let i=0;i<pCount;i++){
    const k = i + 1;
    const a = time*(0.9 + k*0.03) + k*1.85;
    const o = R * (0.52 + 0.18*Math.sin(time*1.3 + k));
    const sx = cx + Math.cos(a) * o;
    const sy = cy + Math.sin(a*1.06) * (o*0.78);
    const tw = 0.35 + 0.65*clamp01(0.5 + 0.5*Math.sin(time*6.2 + k*2.1));
    const rr = (isPreview ? 1.3 : 1.8) * I * (0.8 + tw*0.6);

    ctx.globalAlpha = (isPreview ? 0.55 : 0.85) * tw * I;
    ctx.beginPath();
    ctx.arc(sx, sy, rr, 0, TAU);
    ctx.fill();
  }

  /* ===== 5) COEUR ===== */
  const corePulse = 0.55 + 0.45*(0.5 + 0.5*Math.sin(time*4.6));

  const core = _getSolarGrad(
    `core_${bw}_${bh}_${I}`, // (identique)
    ()=> {
      const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, R*0.40);
      g.addColorStop(0.00, `rgba(255,255,255,${0.22*I*corePulse})`);
      g.addColorStop(0.25, `rgba(255,245,210,${0.18*I})`);
      g.addColorStop(1.00, "rgba(255,255,255,0)");
      return g;
    }
  );

  ctx.globalAlpha = (isPreview ? 0.55 : 0.9) * I;
  ctx.fillStyle = core;
  ctx.beginPath();
  ctx.arc(cx, cy, R*0.40, 0, TAU);
  ctx.fill();

  ctx.globalCompositeOperation = "source-over";
  ctx.restore();
}




/* =========================================================
   ARCTIC FX ‚Äî CLEAN / SAFE / MOBILE
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : ctx.restore() GARANTI
   ‚úî time UNIFI√â (t = fxTime en ms)
   ‚úî pas de return apr√®s save()
========================================================= */

const _arcticGradCache = new Map();

function _getArcticGrad(key, maker){
  let g = _arcticGradCache.get(key);
  if (!g){
    g = maker();
    if (_arcticGradCache.size > 24) _arcticGradCache.clear();
    _arcticGradCache.set(key, g);
  }
  return g;
}

function drawArcticFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  // t = fxTime (ms)
  const time = t * 0.001;

  /* ===== PREVIEW SAFE (ULTRA LIGHT) ===== */
  if (isPreview){
    c.save();
    c.globalAlpha = 0.6;
    c.fillStyle = "rgba(180,220,255,0.35)";
    c.beginPath();
    c.arc(bx + bw/2, by + bh/2, bw*0.6, 0, Math.PI*2);
    c.fill();
    c.restore();
    return;
  }

  c.save();

  const cx = bx + bw * 0.5;
  const cy = by + bh * 0.58;

  /* ===== AURA POLAIRE ===== */
  const breath = Math.sin(time * 1.6) * 0.08;

  const halo = _getArcticGrad(
    `halo_${bw}_${bh}`,
    () => {
      const g = c.createRadialGradient(
        cx, cy, bw * 0.1,
        cx, cy, bw * (1.15 + breath)
      );
      g.addColorStop(0,   "rgba(250,255,255,0.95)");
      g.addColorStop(0.25,"rgba(210,240,255,0.65)");
      g.addColorStop(0.6, "rgba(140,200,255,0.28)");
      g.addColorStop(1,   "rgba(0,0,0,0)");
      return g;
    }
  );

  c.globalCompositeOperation = "screen";
  c.globalAlpha = 1;
  c.fillStyle = halo;
  c.beginPath();
  c.ellipse(cx, cy, bw * 1.15, bh * 1.35, 0, 0, Math.PI * 2);
  c.fill();

  c.globalCompositeOperation = "source-over";

  /* ===== FLOCON ===== */
  function drawSnowflake(x, y, r, rot, seed){
    c.save();
    c.translate(x, y);
    c.rotate(rot);

    const arms = 5 + (seed % 3);
    c.strokeStyle = "rgba(245,252,255,0.95)";
    c.lineWidth = 0.9 + Math.sin(seed) * 0.4;

    for (let a = 0; a < arms; a++){
      c.rotate((Math.PI * 2) / arms);
      const len = r * (0.6 + Math.sin(seed + a) * 0.35);

      c.beginPath();
      c.moveTo(0, 0);
      c.lineTo(0, len);

      if (Math.sin(seed * 1.7 + a) > 0){
        c.moveTo(0, len * 0.45);
        c.lineTo(len * 0.2, len * 0.65);
      }
      if (Math.cos(seed * 1.3 + a) > 0){
        c.moveTo(0, len * 0.45);
        c.lineTo(-len * 0.22, len * 0.7);
      }
      c.stroke();
    }

    c.restore();
  }

  /* ===== TEMP√äTE (OPTIMIS√âE) ===== */
  const stormCount = 18;
  for (let i = 0; i < stormCount; i++){
    const seed = i * 13.13;

    const x =
      cx +
      Math.sin(time * 1.7 + seed) * bw * (0.18 + Math.sin(seed) * 0.3) +
      Math.sin(time * 5.5 + seed) * 10;

    const y =
      cy +
      Math.cos(time * 1.3 + seed) * bh * (0.15 + Math.cos(seed) * 0.25) +
      Math.sin(time * 3.8 + seed) * 8;

    const r   = 2.2 + Math.sin(time * 3 + seed) * 1.4;
    const rot = time * (0.35 + Math.sin(seed) * 0.35) + seed;

    drawSnowflake(x, y, r, rot, seed);
  }

  /* ===== BLIZZARD (OPTIMIS√â) ===== */
  c.globalAlpha = 0.8;
  const blizzardCount = 22;

  for (let i = 0; i < blizzardCount; i++){
    const seed = i * 21.7;
    const rise = (time * 48 + seed * 26) % (bh * 1.3);

    const x =
      cx +
      Math.sin(rise * 0.018 + seed) * bw * (0.22 + Math.sin(seed) * 0.3) +
      Math.sin(time * 4.5 + seed) * 12;

    const y =
      by + bh - rise +
      Math.sin(time * 2.8 + seed) * 10;

    const r   = 2 + Math.sin(time * 3.6 + seed) * 1.5;
    const rot = time * (0.7 + Math.cos(seed) * 0.45) + seed * 0.6;

    drawSnowflake(x, y, r, rot, seed);
  }

  /* ===== GIVRE INF√âRIEUR ===== */
  c.globalAlpha = 0.85;
  c.strokeStyle = "rgba(235,250,255,1)";
  c.lineWidth = 1.5;

  for (let i = 0; i < 6; i++){
    const x = bx + bw * (0.22 + i * 0.11);
    const sway = Math.sin(time * 2 + i) * 3.5;
    const h = bh * (0.18 + Math.sin(time * 1.4 + i) * 0.08);

    c.beginPath();
    c.moveTo(x, by + bh * 0.78);
    c.lineTo(x + sway, by + bh * 0.78 + h);
    c.stroke();
  }

  c.restore();
}








/* =========================================================
   INFERNO FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : aucun return apr√®s save()
   ‚úî time UNIFI√â (t = fxTime en ms)
   ‚úî gradients toujours restaur√©s
========================================================= */

const _infernoGradCache = new Map();
function _g(key, fn){
  let v = _infernoGradCache.get(key);
  if(!v){
    v = fn();
    if(_infernoGradCache.size > 48) _infernoGradCache.clear();
    _infernoGradCache.set(key, v);
  }
  return v;
}

function drawInfernoFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  // t = fxTime (ms)
  const time = t * 0.001;

  c.save();

  const cx = bx + bw*0.5;
  const cy = by + bh*0.55;
  const R  = Math.min(bw, bh) * 0.92;

  const I = isPreview ? 0.62 : 1.0;
  const TAU = Math.PI * 2;

  const clamp01 = v => v<0?0:v>1?1:v;
  const fract = x => x - (x|0);
  const hash  = n => fract(Math.sin(n*127.1)*43758.5453123);

  const turb = (u, k) =>
    Math.sin(u*3.1 + time*4.8 + k)*0.55 +
    Math.sin(u*7.7 - time*3.4 + k*1.9)*0.30 +
    Math.sin(u*13.3+ time*2.2 + k*2.7)*0.15;

  /* ===== DARK VIGNETTE ===== */
  c.globalCompositeOperation = "source-over";
  c.globalAlpha = (isPreview ? 0.12 : 0.18) * I;
  c.fillStyle = _g(`vig_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, R*0.25, cx, cy, R*1.35);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,1)");
    return g;
  });
  c.beginPath();
  c.arc(cx, cy, R*1.35, 0, TAU);
  c.fill();

  /* ===== CORE ===== */
  c.globalCompositeOperation = "screen";
  const corePulse = 0.65 + 0.35*Math.sin(time*5.2);
  c.globalAlpha = (isPreview ? 0.70 : 1.0) * corePulse * I;
  c.fillStyle = _g(`core_${bw}_${bh}`, ()=>{
    const g = c.createRadialGradient(cx, cy, 0, cx, cy, R*0.60);
    g.addColorStop(0.00, "rgba(255,255,255,0.28)");
    g.addColorStop(0.18, "rgba(255,210,150,0.35)");
    g.addColorStop(0.38, "rgba(255,120,55,0.42)");
    g.addColorStop(0.62, "rgba(190,25,20,0.34)");
    g.addColorStop(1.00, "rgba(0,0,0,0)");
    return g;
  });
  c.beginPath();
  c.arc(cx, cy, R*0.62, 0, TAU);
  c.fill();

  /* ===== SEAL ===== */
  const sealRot = time*0.55;
  const sealR = R*0.74;
  const ringR = R*0.86;

  c.globalAlpha = (isPreview ? 0.38 : 0.62) * I;
  c.lineWidth = 2.1 * I;
  c.strokeStyle = "rgba(255,70,40,0.55)";
  c.setLineDash([10*I,8*I]);
  c.lineDashOffset = -time*55;
  c.beginPath();
  c.arc(cx, cy, ringR, 0, TAU);
  c.stroke();
  c.setLineDash([]);

  function starPath(r, rot){
    const idx = [0,2,4,1,3,0];
    c.beginPath();
    for(let j=0;j<idx.length;j++){
      const i = idx[j];
      const a = rot + i*(TAU/5) - Math.PI/2;
      const x = cx + Math.cos(a)*r;
      const y = cy + Math.sin(a)*r*0.94;
      if(j===0) c.moveTo(x,y); else c.lineTo(x,y);
    }
  }

  c.globalAlpha = (isPreview ? 0.42 : 0.78) * I;
  c.lineWidth = 2.6 * I;
  c.strokeStyle = "rgba(255,180,140,0.45)";
  starPath(sealR, sealRot);
  c.stroke();

  c.globalAlpha = (isPreview ? 0.28 : 0.55) * I;
  c.lineWidth = 1.6 * I;
  c.strokeStyle = "rgba(255,60,30,0.85)";
  starPath(sealR*0.98, -sealRot*0.7);
  c.stroke();

  /* ===== FLAME CROWN ===== */
  const tongues = isPreview ? 9 : 16;
  const baseR = R*0.88;
  c.globalCompositeOperation = "screen";

  for(let i=0;i<tongues;i++){
    const u = i/tongues;
    const a = u*TAU + time*0.95;
    const n = turb(u*TAU, i);
    const spike = Math.max(0,n) * (isPreview?0.35:0.75);

    const rr = baseR*(0.92 + 0.07*Math.sin(time*2.6+i) + spike*0.22);
    const fx = cx + Math.cos(a)*rr;
    const fy = cy + Math.sin(a)*rr*0.78;

    const h = R*(0.22 + 0.18*(0.5+0.5*Math.sin(time*6+i*0.9)) + spike*0.35);
    const w = R*(0.06 + 0.03*(0.5+0.5*Math.sin(time*4.2+i*1.3)));

    const grad = c.createLinearGradient(fx, fy, fx, fy-h);
    grad.addColorStop(0,"rgba(255,90,20,0.75)");
    grad.addColorStop(0.25,"rgba(255,170,60,0.60)");
    grad.addColorStop(0.55,"rgba(255,240,190,0.34)");
    grad.addColorStop(1,"rgba(255,255,255,0)");

    c.globalAlpha = (isPreview ? 0.40 : 0.75) * I;
    c.fillStyle = grad;

    const bend = (Math.sin(time*7.5+i*1.4)*0.55 + n*0.35) * w;

    c.beginPath();
    c.moveTo(fx,fy);
    c.bezierCurveTo(
      fx+w+bend, fy-h*0.25,
      fx+w*0.25, fy-h*0.92,
      fx+bend*0.25, fy-h
    );
    c.bezierCurveTo(
      fx-w*0.25, fy-h*0.92,
      fx-w+bend*0.2, fy-h*0.25,
      fx,fy
    );
    c.fill();
  }

  /* ===== EMBERS ===== */
  const embers = isPreview ? 7 : 18;
  for(let i=0;i<embers;i++){
    const seed=i*33.7;
    const a=time*(0.9+hash(seed)*1.2)+seed;
    const rr=R*(0.22+0.68*hash(seed+1))+Math.sin(time*2+i)*R*0.03;

    const x=cx+Math.cos(a)*rr;
    const y=cy+Math.sin(a*1.05)*rr*0.78;

    const tw=0.35+0.65*(0.5+0.5*Math.sin(time*7+i*1.7));
    const r=(isPreview?1.4:2.6)*(0.65+tw)*I;

    if(!isPreview){
      c.globalAlpha=0.16*tw*I;
      c.fillStyle="rgba(255,140,70,1)";
      c.beginPath(); c.arc(x-Math.cos(a)*12,y-Math.sin(a)*12,r*2.2,0,TAU); c.fill();
    }

    c.globalAlpha=(isPreview?0.55:0.85)*tw*I;
    c.fillStyle="rgba(255,220,170,1)";
    c.beginPath(); c.arc(x,y,r,0,TAU); c.fill();

    c.globalAlpha*=0.22;
    c.beginPath(); c.arc(x,y,r*3,0,TAU); c.fill();
  }

  c.globalCompositeOperation="source-over";
  c.globalAlpha=1;
  c.restore();
}


/* =========================================================
   NEON FX ‚Äî OPTIMIS√â (ZERO ALLOC / DIRECT CACHE)
   ‚úî Plus de fonction anonyme inutile (_ng supprim√©)
   ‚úî Cache v√©rifi√© directement (Inline)
   ‚úî Clip restaur√© proprement
========================================================= */

const _neonGradCache = new Map();

function drawNeonFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  const time = t * 0.001;          // t = fxTime (ms)
  const I = isPreview ? 0.7 : 1.0;
  const TAU = Math.PI * 2;

  const cx = bx + bw*0.5;
  const cy = by + bh*0.55;
  const R  = Math.min(bw, bh) * 0.85;

  c.save();

  // Clipping circulaire (Attention, op√©ration lourde, mais n√©cessaire ici)
  c.beginPath();
  c.arc(cx, cy, R*0.95, 0, TAU);
  c.clip();

  const fract = x => x - (x|0);
  const hash  = n => fract(Math.sin(n*127.1)*43758.5453);

  /* ===== STREAKS (RAYONS) ===== */
  const streaks = isPreview ? 4 : 9;

  for(let i=0;i<streaks;i++){
    const seed = i*21.7;
    const life = fract(time*0.6 + hash(seed));

    const angle = seed + life*TAU;
    const dist  = R*(1.3 - life*1.6);

    const x = cx + Math.cos(angle)*dist;
    const y = cy + Math.sin(angle)*dist*0.75;

    const dx = Math.cos(angle);
    const dy = Math.sin(angle)*0.75;

    const L = R*(0.18 + 0.25*(1-life));

    // Cl√© de cache (Quantized)
    // On utilise des entiers pour limiter la cr√©ation de strings
    const kx = (x*0.1)|0;
    const ky = (y*0.1)|0;
    const kl = (L*10)|0;
    const kp = isPreview?1:0;
    const key = `${kx}_${ky}_${kl}_${kp}`;

    // üî• OPTIMISATION : Check direct (pas de closure cr√©√©e)
    let grad = _neonGradCache.get(key);
    if (!grad){
      grad = c.createLinearGradient(x, y, x - dx*L, y - dy*L);
      grad.addColorStop(0.00, "rgba(255,255,255,0.95)");
      grad.addColorStop(0.35, "rgba(0,255,255,0.85)");
      grad.addColorStop(1.00, "rgba(0,255,255,0)");
      
      // Garbage collect simple du cache local
      if (_neonGradCache.size > 64) _neonGradCache.clear();
      _neonGradCache.set(key, grad);
    }

    c.strokeStyle = grad;
    c.lineWidth = (isPreview ? 1.4 : 2.2) * I;
    c.globalAlpha = (1-life) * (isPreview ? 0.7 : 1.0);

    c.beginPath();
    c.moveTo(x,y);
    c.lineTo(x - dx*L, y - dy*L);
    c.stroke();
  }

  /* ===== CORE FLASH ===== */
  c.globalCompositeOperation = "screen";
  const corePulse = 0.5 + 0.5*Math.sin(time*6.2);
  c.globalAlpha = (isPreview ? 0.25 : 0.45) * corePulse * I;

  // Cache pour le coeur (simple key)
  const coreKey = `core_${bw}_${bh}_${isPreview?1:0}`;
  let coreGrad = _neonGradCache.get(coreKey);
  
  if (!coreGrad){
    coreGrad = c.createRadialGradient(cx, cy, 0, cx, cy, R*0.35);
    coreGrad.addColorStop(0.00, "rgba(255,255,255,0.4)");
    coreGrad.addColorStop(0.35, "rgba(0,255,255,0.35)");
    coreGrad.addColorStop(1.00, "rgba(0,0,0,0)");
    _neonGradCache.set(coreKey, coreGrad);
  }

  c.fillStyle = coreGrad;
  c.beginPath();
  c.arc(cx, cy, R*0.35, 0, TAU);
  c.fill();

  c.restore();
}

/* =========================================================
   VOIDWALKER FX ‚Äî CLEAN / SAFE / PERF
   ‚úî VISUEL IDENTIQUE
   ‚úî FIX CRITIQUE : aucun return apr√®s save()
   ‚úî time UNIFI√â (t = fxTime en ms)
========================================================= */
/* =========================================================
   üï≥Ô∏è VOIDWALKER FX ‚Äî COSMIC SINGULARITY (LEGENDARY MATCH)
   - Remplace le style "Glitch" par un style "Trou Noir"
   - Disque d'accr√©tion g√©ant
   - Rayons de lumi√®re aspir√©s (Lensing)
========================================================= */

const _voidCosmicCache = new Map();

// Helper gradient pour le vide
function _vCosmicGrad(ctx, key, r){
  let g = _voidCosmicCache.get(key);
  if(!g){
    // Violet profond vers noir
    g = ctx.createRadialGradient(0, 0, r*0.4, 0, 0, r*1.5);
    g.addColorStop(0, "rgba(0,0,0,1)");           // Centre noir pur (masque le corps)
    g.addColorStop(0.4, "rgba(75,0,130,0.4)");    // Indigo
    g.addColorStop(0.7, "rgba(138,43,226,0.2)");  // Violet
    g.addColorStop(1, "rgba(0,0,0,0)");
    
    if(_voidCosmicCache.size > 20) _voidCosmicCache.clear();
    _voidCosmicCache.set(key, g);
  }
  return g;
}

// FX AVANT (L√©ger voile devant le joueur pour l'immerger)
function drawVoidwalkerFrontFX(c, bx, by, bw, bh, t){
  if (skipHeavyFX) return;

  const cx = bx + bw/2;
  const cy = by + bh/2;
  const R  = Math.min(bw,bh) * 0.5;

  c.save();
  c.translate(cx, cy);

  // Quelques √©toiles filantes qui passent DEVANT (Aspiration)
  const time = t * 0.002;
  c.fillStyle = "rgba(255,255,255,0.8)";
  
  for(let i=0; i<3; i++){
      const offset = i * 2000;
      const progress = ((t + offset) % 1500) / 1500; // 0..1
      if(progress > 0.8) continue; // Disparait au centre

      const dist = R * 2 * (1 - progress); // Vient de loin vers le centre
      const angle = (t * 0.001) + i * 2;
      
      const px = Math.cos(angle) * dist;
      const py = Math.sin(angle) * dist;
      const size = 2 * (1 - progress);

      c.beginPath(); 
      c.arc(px, py, size, 0, Math.PI*2); 
      c.fill();
  }
  c.restore();
}

// FX ARRI√àRE (Le disque d'accr√©tion majestueux)
function drawVoidwalkerFX(c, bx, by, bw, bh, t, isPreview = false){
  if (skipHeavyFX) return;

  const time = t * 0.001; // Secondes
  const cx = bx + bw/2;
  const cy = by + bh/2;
  const R  = Math.min(bw, bh);

  c.save();
  c.translate(cx, cy);

  // 1. HORIZON SOMBRE (Fondation)
  // Masque ce qui est derri√®re pour donner de la profondeur
  const gradKey = `void_bg_${bw|0}`;
  const bgGrad = _vCosmicGrad(c, gradKey, R);
  c.fillStyle = bgGrad;
  c.beginPath(); c.arc(0,0, R*1.4, 0, Math.PI*2); c.fill();

  // 2. DISQUE D'ACCR√âTION (Particules en spirale)
  // On dessine des traits courbes qui sont "aspir√©s"
  c.globalCompositeOperation = "screen"; // Mode lumineux
  c.lineWidth = (isPreview ? 1.5 : 2.5);
  const strands = isPreview ? 8 : 16;
  
  for(let i=0; i<strands; i++){
      const angleBase = (i / strands) * Math.PI * 2;
      const speed = 0.5 + (i%3)*0.2;
      const rotation = time * speed;
      
      // Couleur changeante (Violet -> Cyan -> Magenta)
      const hue = (t * 0.05 + i * 20) % 360;
      c.strokeStyle = `hsla(${260 + (i*10)%60}, 80%, 70%, ${isPreview?0.4:0.6})`;

      c.beginPath();
      // Spirale logarithmique simplifi√©e
      for(let j=0; j<10; j++){
          const dist = R * (0.4 + j*0.12); // Du centre vers l'ext√©rieur
          const spiralAngle = angleBase + rotation + (j * 0.2); // Courbure
          
          const px = Math.cos(spiralAngle) * dist;
          const py = Math.sin(spiralAngle) * dist * 0.85; // Perspective l√©g√®re (ovale)
          
          if(j===0) c.moveTo(px, py);
          else c.lineTo(px, py);
      }
      c.stroke();
  }

  // 3. JETS D'√âNERGIE (Quasars - Vertical)
  // Fines lignes verticales qui sortent des p√¥les
  c.globalAlpha = 0.3 + 0.2 * Math.sin(time * 5);
  c.fillStyle = "rgba(200, 220, 255, 0.2)";
  c.fillRect(-1, -R*1.5, 2, R*3); // Rayon central
  
  c.globalAlpha = 0.1;
  c.fillRect(-4, -R*1.2, 8, R*2.4); // Glow large

  c.restore();
}


/* =========================
   FAR RIGHT CACHE (SPAWN SAFE)
========================= */
let farRightCache = 0;
let farRightFrame = -1;


/* =========================
   COLLISION ‚Äî AABB vs OBB
========================= */
function aabbVsOBB(ax,ay,aw,ah, cx,cy, halfW, halfH, angle){
  const c = Math.cos(angle);
  const s = Math.sin(angle);

  const dax = (ax + aw * 0.5) - cx;
  const day = (ay + ah * 0.5) - cy;

  const lx =  dax * c + day * s;
  const ly = -dax * s + day * c;

  const ex = Math.abs(aw * 0.5 * c) + Math.abs(ah * 0.5 * s);
  const ey = Math.abs(aw * 0.5 * s) + Math.abs(ah * 0.5 * c);

  const skin = 1.5;

  return (
    Math.abs(lx) <= (halfW - skin) + ex &&
    Math.abs(ly) <= (halfH - skin) + ey
  );
}
/* =========================================================
   üöú MOTEUR DE SPAWN & S√âCURIT√â (VERSION FINALE)
========================================================= */

// --- VARIABLES D'√âTAT ---
let lastSafeY = BASE_H / 2; 

// --- 1. LOGIQUE DE CHEMIN S√õR (SMART Y) ---
function getSmartY() {
  const maxDelta = 120; // Variation max douce
  let minY = lastSafeY - maxDelta;
  let maxY = lastSafeY + maxDelta;

  const margin = 80; 
  if (minY < margin) minY = margin;
  if (maxY > WORLD_H - margin) maxY = WORLD_H - margin;

  const newY = Math.floor(minY + Math.random() * (maxY - minY));
  lastSafeY = newY; // M√©morise pour le suivant
  return newY;
}

function setSafeY(y) {
    lastSafeY = y; // Force la position (pour les couloirs)
}

// --- 2. CALCUL DE L'ESPACE PHYSIQUE (FAR RIGHT) ---
function farRightX(){
  if (farRightFrame === frameCount) return farRightCache;

  let mx = -1e9;
  for (const ob of obstacles){
    let rightEdge;
    // S√âCURIT√â ROTBAR : On prend l'extr√©mit√© du bras, pas le centre
    if (ob.kind === 'rotbar') rightEdge = ob.cx + ob.len; 
    // S√âCURIT√â LASER : On prend toute la largeur
    else if (ob.kind === 'laserScan') rightEdge = ob.x + ob.width;
    // CAS G√âN√âRAL
    else rightEdge = (ob.x || 0) + (ob.width || ob.r || 0);

    if (rightEdge > mx) mx = rightEdge;
  }
  farRightCache = mx + 80; // Marge de s√©curit√©
  farRightFrame = frameCount;
  return farRightCache;
}

/* =========================
   üõ†Ô∏è HELPERS (UTILITAIRES)
========================= */
function spawnCoinLine(startX, startY, count, stepX, stepY) {
  for(let i=0; i<count; i++){
    coins.push({ x: startX + (i * stepX), y: startY + (i * stepY), r: 7 });
  }
}

function pushCoinsAround(cx, cy, radius, count){
  const dist = radius + 30;
  for(let i=0; i<count; i++){
    const angle = (Math.PI * 2 * i) / count;
    coins.push({
      x: cx + Math.cos(angle) * dist,
      y: cy + Math.sin(angle) * dist,
      r: 7
    });
  }
}

/* =========================================================
   üè≠ SPAWNERS (CORRECTION TAILLES & PASSAGES SERR√âS)
   (Retour aux obstacles fins et passages √©troits)
========================================================= */

// --- 1. GAP (MUR SIMPLE AVEC TROU) ---
// Celui-l√† reste dynamique car c'est le trou LUI-M√äME qui change
function spawnGap(ph, passedY, gapOverride){
  const safeY = passedY || getSmartY();
  const gapH = gapOverride || getBaseGap(score); 
  const w = 32; 
  const x = WORLD_W + SPAWN_MARGIN_X;
  
  const topH = safeY - (gapH / 2);
  const botY = safeY + (gapH / 2);
  
  obstacles.push({ kind: "rect", x, y: 0, width: w, height: topH });
  obstacles.push({ kind: "rect", x, y: botY, width: w, height: WORLD_H - botY });
  
  spawnCoinLine(x - 10, safeY, 3, 35, 0); 
}

// --- 2. CIRCLE (MINE) ---
function spawnCircle(ph, centerY, gapOverride){
  const safeY = centerY || getSmartY();
  const gap = gapOverride || getBaseGap(score);
  // On garde un petit offset al√©atoire
  const offset = (Math.random() < 0.5 ? -1 : 1) * 40; 
  
  const cx = WORLD_W + SPAWN_MARGIN_X;
  const cy = clamp(safeY + offset, 50, WORLD_H - 50);
  
  obstacles.push({ kind: "circle", x: cx, y: cy, r: 30, rot: 0 });
  pushCoinsAround(cx, cy, 30, 3); 
}

// --- 3. MOVER (MUR QUI BOUGE) ---
function spawnMover(ph, centerY, gapOverride){
  const safeY = centerY || getSmartY();
  const x = WORLD_W + SPAWN_MARGIN_X;

  // CORRECTION : On remet une taille FIXE et FINE !
  // Avant : height: gap (200px = √©norme) -> Maintenant : 100px (Standard)
  const fixedHeight = 100; 

  obstacles.push({
    kind: "movingRect", x: x, y: safeY, width: 32, height: fixedHeight, 
    baseY: safeY, t: Math.random() * Math.PI * 2, 
    amp: 80, // Amplitude standard
    speed: 1.5 + (ph * 0.1)
  });
  spawnCoinLine(x + 50, safeY - 40, 3, 0, 40);
}

// --- 4. ROTBAR (BARRE TOURNANTE) ---
function spawnRotbar(ph, centerY, gapOverride){
  const safeY = centerY || getSmartY();
  
  // CORRECTION : On remet une longueur FIXE !
  // Avant : gap * 0.7 (variable) -> Maintenant : 110px (Comme au d√©but)
  const len = 110; 
  
  const cx = WORLD_W + SPAWN_MARGIN_X + len + 50; 
  
  obstacles.push({
    kind: "rotbar", cx: cx, cy: safeY, len: len,
    angle: Math.random() * Math.PI, speed: 0.04 + (ph * 0.01), half: 7
  });

  coins.push({ x: cx - 60, y: safeY, r: 7 });
  coins.push({ x: cx + 60, y: safeY, r: 7 });
}

// --- 5. SWEEPER (MUR VIOLET) ---
function spawnSweeper(ph, centerY, gapOverride){
  const safeY = centerY || getSmartY();
  const x = WORLD_W + SPAWN_MARGIN_X;
  
  // CORRECTION : Taille FIXE !
  // Avant : height: gap -> Maintenant : 120px
  const fixedHeight = 120;

  obstacles.push({
    kind: "sweeper", x: x, y: safeY - (fixedHeight/2), width: 28, height: fixedHeight, vy: 1.5
  });

  const isTop = Math.random() < 0.5;
  spawnCoinLine(x + 40, isTop ? safeY - 80 : safeY + 80, 3, 30, 0);
}

// --- 8. LASER SCAN ---
function spawnLaserScan(ph, centerY){
  const x = WORLD_W + SPAWN_MARGIN_X;
  const startY = (centerY < WORLD_H/2) ? WORLD_H - 40 : 40;
  const vy = (centerY < WORLD_H/2) ? -1 : 1; 

  // Taille fine conserv√©e
  obstacles.push({
    kind: "laserScan", x: x, y: startY, width: 40, height: 14,
    vy: vy * (0.8 + ph * 0.1)
  });
  const coinY = (startY > WORLD_H/2) ? 60 : WORLD_H - 60;
  spawnCoinLine(x + 20, coinY, 4, 0, 0);
}

// --- 9. PISTON (OSCILLANT) ---
function spawnPiston(ph, centerY, gapOverride){
  const safeY = centerY || getSmartY();
  const x = WORLD_W + SPAWN_MARGIN_X;
  
  // CORRECTION : Taille FIXE !
  const fixedHeight = 140;

  obstacles.push({
    kind: "piston", x: x, y: safeY, width: 50, height: fixedHeight,
    t: 0, speed: 0.04 + (ph * 0.01)
  });
  const isTop = Math.random() < 0.5;
  spawnCoinLine(x + 20, isTop ? safeY - 110 : safeY + 110, 2, 40, 0); 
}

// --- 10. COULOIR (CORRIDOR) ---
function spawnCorridor(ph, centerY){
  const x = WORLD_W + SPAWN_MARGIN_X;
  
  // CORRECTION : PASSAGE SERR√â
  // Avant : 160px (Autoroute) -> Maintenant : 120px (Challenge)
  const safeZone = 120; 
  
  setSafeY(centerY); 

  for(let i=0; i<3; i++){
      obstacles.push({ kind: "circle", x: x + i*60, y: centerY - safeZone/2 - 20, r: 20 });
      obstacles.push({ kind: "circle", x: x + i*60, y: centerY + safeZone/2 + 20, r: 20 });
  }
  spawnCoinLine(x, centerY, 3, 50, 0);
}

// --- 11. TUNNEL (MUR PLEIN) ---
function spawnTunnel(ph, centerY){
  const x = WORLD_W + SPAWN_MARGIN_X;
  
  // CORRECTION : PASSAGE SERR√â
  // Avant : 165px -> Maintenant : 130px (Il faut √™tre pr√©cis)
  const h = 130; 
  
  setSafeY(centerY); 

  const tunW = 350; // Longueur standard

  obstacles.push({ kind:"rect", x: x, y: 0, width: tunW, height: centerY - h/2 });
  obstacles.push({ kind:"rect", x: x, y: centerY + h/2, width: tunW, height: WORLD_H - (centerY + h/2) });
  spawnCoinLine(x + 50, centerY, 4, 40, 0);
}

/* =========================
   üß† M√âMOIRE DU DANGER (PATTERN AWARE)
========================= */
let recentHazards = []; // Historique des 3 derniers obstacles

// Note de dangerosit√© (0 = Repos, 2.5 = Mortel)
function getHazardWeight(type){
  switch(type){
    case "gap":       return 0;
    case "circle":    return 0.5;
    case "sweeper":   return 1.0;
    case "rotbar":    return 1.5; // Impr√©visible
    case "mover":     return 1.5; // R√©flexe requis
    case "piston":    return 2.0; // Rapide
    case "laserScan": return 2.0; // Zone denial
    case "corridor":  return 2.5; // Long
    case "tunnel":    return 2.5; // Long + Sombre
    default: return 1;
  }
}

// Helper pour respecter tes pourcentages (FREQ)
function pickWeighted(options) {
  const keys = Object.keys(options);
  const r = Math.random();
  let cumulative = 0;
  
  // Normalisation des poids
  let totalWeight = 0;
  for (let k of keys) totalWeight += options[k];

  const randomValue = r * totalWeight;

  for (let key of keys) {
    cumulative += options[key];
    if (randomValue <= cumulative) return key;
  }
  return keys[keys.length - 1];
}
/* =========================================================
   üö¶ DISPATCHER v4.1 (NERVOUS & TIGHT)
   (Plus de trous immenses, √ßa encha√Æne vite)
========================================================= */
function spawn(){
  const now = renderTime;
  
  // 1. D√âLAIS R√âDUITS (On divise par 3 !)
  // On veut juste √©viter que √ßa spawn PENDANT l'obstacle, pas 3h apr√®s.
  let extraDelay = 0;
  if (lastType === "tunnel")     extraDelay = 600;  // Avant 1800
  if (lastType === "corridor")   extraDelay = 400;  // Avant 1200
  if (lastType === "laserScan")  extraDelay = 500;  // Avant 1500
  if (lastType === "rotbar")     extraDelay = 200;  // Avant 500

  const baseInterval = currentSpawnInterval(score); 
  const safetyDelay = Math.max(350, baseInterval) + extraDelay; // Min 350ms
  
  if (now - lastSpawnTime < safetyDelay) return;

  // 2. CHECK DISTANCE PHYSIQUE (C'est lui le vrai chef)
  const distToLast = farRightX() - (WORLD_W + SPAWN_MARGIN_X);
  // On autorise un spawn d√®s que l'obstacle pr√©c√©dent a laiss√© 60px de marge
  if (distToLast > -60) return; 

  // 3. S√âLECTION INTELLIGENTE
  const safeY = getSmartY();
  let pick = "gap";
  const ph = phase(score);

  const isAfterHeavy = (lastType === "corridor" || lastType === "tunnel" || lastType === "laserScan");

  if (isAfterHeavy) {
      // On encha√Æne plus vite apr√®s un gros obstacle
      pick = (Math.random() < 0.6) ? "gap" : "circle";
  } 
  else {
      const currentProbas = currentFreq(score);
      pick = pickWeighted(currentProbas); 
      
      if (Math.random() < 0.15) {
          let specials = ["laserScan", "piston", "corridor", "tunnel"];
          if (lastType === "piston") specials = ["corridor", "tunnel"];
          pick = specials[Math.floor(Math.random() * specials.length)];
      }
  }

  if (pick === lastType && ["corridor", "piston", "tunnel", "laserScan"].includes(pick)) {
      pick = "gap";
  }

// 4. CALCUL GAP & S√âCURIT√â (AJUST√â SERR√â)
  let finalGap = getBaseGap(score);
  
  const currentWeight = getHazardWeight(pick);
  recentHazards.push(currentWeight);
  if (recentHazards.length > 3) recentHazards.shift();
  
  const hazardSum = recentHazards.reduce((a,b)=>a+b, 0);

  // S√âCURIT√â R√âDUITE : On n'ouvre pas trop grand m√™me si c'est dur
  // Avant : 215/230/245 -> C'√©tait trop facile
  // Maintenant : 170/190/200 -> √áa reste un challenge
  if (score > 20000 && hazardSum >= 3.5) finalGap = Math.max(finalGap, 170);
  if (score > 60000 && hazardSum >= 5.0) finalGap = Math.max(finalGap, 190);

  lastType = pick;
  lastSpawnTime = now;

  // 5. EX√âCUTION
  switch (pick){
    case "gap":       spawnGap(ph, safeY, finalGap); break;
    case "circle":    spawnCircle(ph, safeY, finalGap); break;
    case "mover":     spawnMover(ph, safeY, finalGap); break;
    case "rotbar":    spawnRotbar(ph, safeY, finalGap); break;
    case "sweeper":   spawnSweeper(ph, safeY, finalGap); break;
    case "laserScan": spawnLaserScan(ph, safeY); break; 
    case "piston":    spawnPiston(ph, safeY, finalGap); break;
    case "corridor":  spawnCorridor(ph, safeY); break; 
    case "tunnel":    spawnTunnel(ph, safeY); break;
    default:          spawnGap(ph, safeY, finalGap);
  }
}
// death / FX
function startDeath(fromCircle, circle, typeTag=null){
  if (gameState === 'dying' || gameState === 'gameover') return;

  gameState = 'dying';
  dyingTimer = 520;
  gameOverTriggered = false;

  // ‚úÖ origine FIXE (ne suivra plus les modifs de player.x/y/scale pendant dying)
  const px = player.x + player.width/2;
  const py = player.y + player.height/2;
  deathOrigin = { x:px, y:py };

  // ‚úÖ SAFE : si circle est null, on √©vite le crash
  dyingFromCircle = (fromCircle && circle) ? { x: circle.x, y: circle.y } : null;

// --- AUDIO MORT (CORRIG√â) ---
  if (typeof musicGame !== "undefined" && musicGame) {
    // On baisse juste le volume de la musique, pas de fade compliqu√©
    musicGame.volume = (audioSettings.mute ? 0 : clamp01(audioSettings.music / 100)) * 0.3;
  }
  
  // ‚úÖ On utilise UNIQUEMENT la nouvelle fonction safe
  playSFX(sfxDeath);

  // ‚ùå SUPPRIME TOUT LE BLOC "if (typeof sfxDeath ...)" qui √©tait ici avant

  // --- PARTICULES ---
  particles.length = 0;
  const n = 26;
  for(let i=0;i<n;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = fromCircle ? randomRange(1.2,2.1) : randomRange(1.8,3.2);
    const life = randomRange(420,700);
    const col = typeTag==='bullet'
      ? 'rgba(255,255,255,0.9)'
      : (fromCircle ? 'rgba(255,128,96,0.9)' : 'rgba(255,200,80,0.9)');

    particles.push({
      x:px,y:py,
      vx:Math.cos(ang)*spd,
      vy:Math.sin(ang)*spd,
      life,age:0,col,
      sz:randomRange(2,4)
    });
  }

  // --- SHOCKWAVE / BLOOM ---
  shockwave = { x:px, y:py, r:0, alpha:1, max:180 };
  bloom = { x:px, y:py, a:0.6 };
}
/* =====================================================
   üé® 1. SYST√àME DE CACHE (CLEAN: NO HUNTER)
===================================================== */
const obstacleCache = {
  rect: null,    // Murs Cyan
  circle: null,  // Mines Plasma
  sweeper: null, // Monolithes Violets
  emitter: null, // Base Laser
  hazard: null,  // Texture ray√©e (Danger)
  // Hunter supprim√©
  initialized: false
};

function initObstacleCaches() {
  // --- A. TEXTURE HAZARD ---
  const hazCanvas = document.createElement('canvas');
  hazCanvas.width = 20; hazCanvas.height = 20;
  const hCtx = hazCanvas.getContext('2d');
  hCtx.fillStyle = "#111"; hCtx.fillRect(0,0,20,20);
  hCtx.fillStyle = "#eebb00"; 
  hCtx.beginPath(); hCtx.moveTo(0,20); hCtx.lineTo(20,0); hCtx.lineTo(20,10); hCtx.lineTo(10,20); hCtx.fill();
  hCtx.beginPath(); hCtx.moveTo(0,0); hCtx.lineTo(10,0); hCtx.lineTo(0,10); hCtx.fill();
  obstacleCache.hazard = hCtx.createPattern(hazCanvas, "repeat");

  // --- B. MUR N√âON ---
  const rCanvas = document.createElement('canvas');
  rCanvas.width = 100; rCanvas.height = 400; 
  const rCtx = rCanvas.getContext('2d');
  
  const rGrad = rCtx.createLinearGradient(0,0,100,0);
  rGrad.addColorStop(0, "#0a101a"); rGrad.addColorStop(0.5, "#152030"); rGrad.addColorStop(1, "#0a101a");
  rCtx.fillStyle = rGrad; rCtx.fillRect(0, 0, 100, 400);
  
  rCtx.shadowColor = "#00f0ff"; rCtx.shadowBlur = 15;
  rCtx.strokeStyle = "#00f0ff"; rCtx.lineWidth = 3;
  rCtx.strokeRect(4, 4, 92, 392);
  rCtx.shadowBlur = 0;

  rCtx.fillStyle = obstacleCache.hazard;
  rCtx.fillRect(6, 6, 88, 20);
  rCtx.fillRect(6, 374, 88, 20);
  
  rCtx.strokeStyle = "rgba(0, 240, 255, 0.2)"; rCtx.lineWidth = 2;
  rCtx.beginPath();
  rCtx.moveTo(20, 40); rCtx.lineTo(20, 360);
  rCtx.moveTo(80, 40); rCtx.lineTo(80, 360);
  rCtx.stroke();
  
  obstacleCache.rect = rCanvas;

  // --- C. MINE VORTEX ---
  const cCanvas = document.createElement('canvas');
  cCanvas.width = 120; cCanvas.height = 120;
  const cCtx = cCanvas.getContext('2d');
  const cc = 60; 
  
  cCtx.fillStyle = "#222"; 
  cCtx.beginPath(); cCtx.arc(cc, cc, 40, 0, Math.PI*2); cCtx.fill();
  
  const cGrad = cCtx.createRadialGradient(cc, cc, 10, cc, cc, 35);
  cGrad.addColorStop(0, "#ffdddd");
  cGrad.addColorStop(0.4, "#ff3300");
  cGrad.addColorStop(1, "#550000");
  cCtx.fillStyle = cGrad;
  cCtx.beginPath(); cCtx.arc(cc, cc, 35, 0, Math.PI*2); cCtx.fill();

  cCtx.strokeStyle = "#000"; cCtx.lineWidth = 3;
  cCtx.beginPath();
  cCtx.moveTo(cc-35, cc); cCtx.lineTo(cc+35, cc);
  cCtx.moveTo(cc, cc-35); cCtx.lineTo(cc, cc+35);
  cCtx.stroke();
  
  obstacleCache.circle = cCanvas;

  // --- D. SWEEPER ---
  const sCanvas = document.createElement('canvas');
  sCanvas.width = 100; sCanvas.height = 400;
  const sCtx = sCanvas.getContext('2d');
  
  const sGrad = sCtx.createLinearGradient(0,0,0,400);
  sGrad.addColorStop(0, "#2a003b"); sGrad.addColorStop(0.5, "#100015"); sGrad.addColorStop(1, "#2a003b");
  sCtx.fillStyle = sGrad; sCtx.fillRect(0, 0, 100, 400);

  sCtx.fillStyle = "rgba(200, 0, 255, 0.3)";
  for(let i=20; i<380; i+=40) {
      sCtx.fillRect(30, i, 40, 5); 
  }
  
  sCtx.strokeStyle = "#d000ff"; sCtx.lineWidth = 4;
  sCtx.strokeRect(0,0,100,400);
  obstacleCache.sweeper = sCanvas;

  // (HUNTER CANVAS SUPPRIM√â ICI)

  // --- F. EMITTER ---
  const eCanvas = document.createElement('canvas');
  eCanvas.width = 40; eCanvas.height = 40;
  const eCtx = eCanvas.getContext('2d');
  
  const eGrad = eCtx.createRadialGradient(20,20,5, 20,20,20);
  eGrad.addColorStop(0, "#888"); eGrad.addColorStop(1, "#222");
  eCtx.fillStyle = eGrad; eCtx.beginPath(); eCtx.arc(20,20,18,0,Math.PI*2); eCtx.fill();
  
  eCtx.fillStyle = "#f00"; eCtx.beginPath(); eCtx.arc(20,20,8,0,Math.PI*2); eCtx.fill();
  
  obstacleCache.emitter = eCanvas;

  obstacleCache.initialized = true;
}

/* =====================================================
   üéÆ 2. MOTEUR DE RENDU OBSTACLES (CLEAN: NO HUNTER)
===================================================== */
function drawObstacles(now){
  if (!obstacleCache.initialized) initObstacleCaches();
  
  // Utilisation de renderTime (global) ou du parametre pass√©
  const tNow = (typeof renderTime !== 'undefined') ? renderTime : performance.now();
  
  const isOverdrive = document.body.classList.contains("overdriveActive");
  const blink = isOverdrive ? 0.8 + Math.sin(tNow * 0.02) * 0.4 : 1.0;
  const viewLeft = -OFF_X - 250;
  const viewRight = WORLD_W + OFF_X + 250;

  for (let i = 0, l = obstacles.length; i < l; i++){
    const ob = obstacles[i];
    const right = ob.x + (ob.width || ob.r || 600); 
    if (right < viewLeft || ob.x > viewRight) continue;

    ctx.save();
    if (isOverdrive) ctx.globalAlpha = blink;

    // ----------------------------------------------------
    // TYPE 1: STRUCTURES (Rect, Piston, Gate)
    // ----------------------------------------------------
    if (ob.kind === "rect" || ob.kind === "movingRect" || ob.kind === "piston" || ob.kind === "gate"){
      ctx.translate(ob.x | 0, ob.y | 0);

      if (ob.kind === "gate") {
         ctx.drawImage(obstacleCache.emitter, ob.width/2 - 20, -10); 
         ctx.drawImage(obstacleCache.emitter, ob.width/2 - 20, ob.height - 30); 

         if (ob.active) {
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = `rgba(255, 0, 80, ${0.6 + Math.sin(tNow*0.2)*0.3})`;
            ctx.fillRect(ob.width/2 - 6, 10, 12, ob.height-20);
            ctx.fillStyle = "#fff";
            ctx.fillRect(ob.width/2 - 2, 10, 4, ob.height-20);
            ctx.globalCompositeOperation = "source-over";
         } else {
            ctx.strokeStyle = "rgba(255,0,0,0.3)"; ctx.setLineDash([5,5]);
            ctx.beginPath(); ctx.moveTo(ob.width/2, 10); ctx.lineTo(ob.width/2, ob.height-10); ctx.stroke();
         }
      } 
      else {
         ctx.drawImage(obstacleCache.rect, 0, 0, ob.width, ob.height);
         ctx.globalCompositeOperation = "overlay";
         ctx.fillStyle = `rgba(0, 255, 255, ${0.1 + Math.sin(tNow*0.005)*0.1})`;
         ctx.fillRect(0,0, ob.width, ob.height);
         ctx.globalCompositeOperation = "source-over";
      }
    }

    // ----------------------------------------------------
    // TYPE 2: SWEEPER (Monolithe)
    // ----------------------------------------------------
    else if (ob.kind === "sweeper"){
      ctx.translate(ob.x | 0, ob.y | 0);
      ctx.drawImage(obstacleCache.sweeper, 0, 0, ob.width, ob.height);
      if (Math.random() < 0.1) {
          ctx.fillStyle = "rgba(255,255,255,0.5)";
          ctx.fillRect(0, Math.random()*ob.height, ob.width, 2);
      }
    }

    // ----------------------------------------------------
    // TYPE 3: ORBES
    // ----------------------------------------------------
    else if (ob.kind === "circle" || ob.kind === "pulsar"){
      ctx.translate(ob.x | 0, ob.y | 0);
      const pulse = 1 + 0.1 * Math.sin(tNow * 0.008);
      ctx.rotate(tNow * 0.002); 

      if(obstacleCache.circle) {
          const s = ob.r / 40; 
          ctx.drawImage(obstacleCache.circle, -40*s, -40*s, 80*s, 80*s);
      } else {
          ctx.fillStyle = "#f00"; ctx.beginPath(); ctx.arc(0,0,ob.r,0,Math.PI*2); ctx.fill();
      }

      ctx.globalCompositeOperation = "lighter";
      ctx.fillStyle = ob.kind === "pulsar" ? "rgba(255, 200, 0, 0.3)" : "rgba(255, 50, 0, 0.3)";
      ctx.beginPath(); ctx.arc(0, 0, ob.r * 1.5 * pulse, 0, Math.PI * 2); ctx.fill();
      ctx.globalCompositeOperation = "source-over";
    }

    // ----------------------------------------------------
    // TYPE 4: LASER SCAN
    // ----------------------------------------------------
    else if (ob.kind === "laserScan"){
      ctx.translate(ob.x | 0, ob.y | 0);
      ctx.drawImage(obstacleCache.emitter, -15, -15);

      ctx.globalCompositeOperation = "lighter";
      const beamW = 10 + Math.sin(tNow * 0.5) * 5;
      ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
      ctx.fillRect(10, -beamW/2, ob.width, beamW);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(10, -2, ob.width, 4);
      ctx.globalCompositeOperation = "source-over";
    }

    // (HUNTER SUPPRIM√â ICI)

    // ----------------------------------------------------
    // TYPE 5: ANCIENS (Rotbar / Turret)
    // ----------------------------------------------------
    else if (ob.kind === "rotbar"){
      ctx.translate(ob.cx | 0, ob.cy | 0);
      ctx.rotate(ob.angle);
      ctx.fillStyle = "#222"; ctx.fillRect(-7, -ob.len, 14, ob.len*2);
      ctx.fillStyle = "#0ff"; ctx.fillRect(-2, -ob.len, 4, ob.len*2);
      ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill();
    }


    ctx.restore();
  }

  // --- PROJECTILES (G√©n√©riques) ---
  ctx.globalCompositeOperation = "lighter"; 
  
  for (const b of bullets){
    if (b.x < viewLeft || b.x > viewRight) continue;
    
    ctx.translate(b.x, b.y);
    
    ctx.shadowColor = "#ff0000"; 
    ctx.shadowBlur = 10;
    ctx.fillStyle = "#ff5500"; 
    
    ctx.beginPath(); 
    ctx.arc(0,0, b.r+1, 0, Math.PI*2); 
    ctx.fill();
    
    ctx.fillStyle = "#ffffff";
    ctx.beginPath(); 
    ctx.arc(0,0, b.r/2, 0, Math.PI*2); 
    ctx.fill();

    ctx.translate(-b.x, -b.y);
  }
  ctx.shadowBlur = 0;
  ctx.globalCompositeOperation = "source-over";
}
/* =====================================================
   ‚ú® AAA PARTICLES : VECTOR SPARKS (MOTION BLUR)
===================================================== */
function drawParticles(){
  // On groupe le rendu pour la performance
  ctx.save();
  // Fusion additive : Les superpositions cr√©ent de la lumi√®re intense (Blanc)
  ctx.globalCompositeOperation = "lighter";

  for (let i = 0; i < particles.length; i++){
    const p = particles[i];

    const lifeRatio = 1 - (p.age / p.life);
    if (lifeRatio <= 0) continue;

    // Vitesse actuelle
    const speed = Math.hypot(p.vx, p.vy);

    // Alpha bas√© sur la vie
    ctx.globalAlpha = lifeRatio;
    
    // Couleur
    ctx.fillStyle = p.col;
    ctx.strokeStyle = p.col;

    if (speed > 1.5) {
        // --- MODE √âTINCELLE (VITESSE) ---
        // On dessine une ligne dans le sens du mouvement (Motion Blur)
        ctx.lineWidth = p.sz * 0.6;
        ctx.lineCap = "round";
        
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        // La queue de l'√©tincelle
        ctx.lineTo(p.x - p.vx * 1.5, p.y - p.vy * 1.5); 
        ctx.stroke();
    } else {
        // --- MODE POUSSI√àRE (LENT) ---
        // Petit carr√© net (plus rapide que arc et style vectoriel)
        const s = p.sz * lifeRatio;
        ctx.fillRect(p.x - s/2, p.y - s/2, s, s);
    }
  }

  ctx.restore();
}


/* =====================================================
   üí• AAA EXPLOSION : IMPACT & SHOCKWAVE
===================================================== */
function drawExplosionFX(){
  // R√©cup√©ration de l'origine de l'explosion
  const ox = deathOrigin ? deathOrigin.x : (player.x + player.width / 2);
  const oy = deathOrigin ? deathOrigin.y : (player.y + player.height / 2);

  ctx.save();
  ctx.globalCompositeOperation = "lighter"; // Lumi√®re pure

  // 1. ONDE DE CHOC (SHOCKWAVE)
  if (shockwave && shockwave.alpha > 0.01){
    const swR = shockwave.r;
    
    // Cercle principal
    ctx.shadowColor = "white";
    ctx.shadowBlur = 10;
    ctx.strokeStyle = `rgba(255, 255, 255, ${shockwave.alpha})`;
    // L'anneau s'affine en s'√©loignant
    ctx.lineWidth = 4 + (1 - (swR / shockwave.max)) * 8; 
    
    ctx.beginPath();
    ctx.arc(ox, oy, swR, 0, Math.PI * 2);
    ctx.stroke();
    
    // √âcho rapide (deuxi√®me anneau plus fin)
    ctx.shadowBlur = 0;
    ctx.strokeStyle = `rgba(200, 240, 255, ${shockwave.alpha * 0.5})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(ox, oy, swR * 0.7, 0, Math.PI * 2);
    ctx.stroke();
  }

  // 2. BLOOM (FLASH LUMINEUX CENTRAL)
  if (bloom && bloom.a > 0.01){
    const r = 180; 
    
    // Pas de cache ici car l'alpha change chaque frame
    // C'est rare (une fois par mort), donc n√©gligeable pour la perf
    const g = ctx.createRadialGradient(ox, oy, 0, ox, oy, r);
    g.addColorStop(0,   `rgba(255, 255, 255, ${bloom.a})`); // Coeur blanc
    g.addColorStop(0.3, `rgba(255, 200, 50, ${bloom.a * 0.6})`); // Halo dor√©
    g.addColorStop(1,   "rgba(0, 0, 0, 0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(ox, oy, r, 0, Math.PI * 2);
    ctx.fill();
  }

  ctx.restore();
}


  

/* ================= BACKGROUND NOISE (GPU SAFE) ================= */
function drawBackgroundNoise(){
  if (!noiseCanvas) return;

  const a = fps >= 58 ? 0.04 : fps >= 52 ? 0.025 : 0;
  if (a <= 0) return;

  const sw = canvas.width  / currentDPR;
  const sh = canvas.height / currentDPR;

  ctx.save();
  ctx.globalCompositeOperation = "overlay";
  ctx.globalAlpha = a;

  ctx.drawImage(
    noiseCanvas,
    0, 0, noiseCanvas.width, noiseCanvas.height,
    0, 0, sw, sh
  );

  ctx.restore();
}


/* =========================
   GRADIENT CACHES (GLOBAL)
========================== */
let hazeGradientCache = null;
let hazeH = 0;

let fadeGradientCache = null;
let fadeH = 0;

let coinGradientCache = null;
let coinGradR = 0;
function draw() {

  /* =================================================
     1Ô∏è‚É£ RESET ABSOLU & NETTOYAGE
  ================================================= */
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
  
  // Remplissage total du canvas physique (fond noir de s√©curit√©)
  ctx.fillStyle = "#05060a";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  /* =================================================
     2Ô∏è‚É£ APPLICATION DU DPR & CENTRAGE (UNIT√âS LOGIQUES)
  ================================================= */
  // On place l'origine au centre de l'√©cran en tenant compte du shake
  const camX = cameraOffsetX + (shakeX || 0);
  const camY = cameraOffsetY + (shakeY || 0);

  // setTransform(DPR_scaleX, 0, 0, DPR_scaleY, posX_physique, posY_physique)
  // On multiplie camX par currentDPR pour convertir l'offset logique en pixels physiques
  ctx.setTransform(currentDPR, 0, 0, currentDPR, camX * currentDPR, camY * currentDPR);

  /* =================================================
     3Ô∏è‚É£ RENDU DU D√âCOR (BACKGROUND)
  ================================================= */
  ctx.save();
  // Mise √† l'√©chelle pour faire tenir BASE_W dans la largeur disponible
  ctx.scale(cameraScale, cameraScale);
  
  // drawBG() utilise d√©sormais -OFF_X pour dessiner depuis le bord r√©el de l'√©cran
  drawBG(bgScroll);
  ctx.restore();

  /* =================================================
     4Ô∏è‚É£ RENDU DU GAMEPLAY
  ================================================= */
  ctx.save();
  ctx.scale(cameraScale, cameraScale);

  const now = renderTime;

  /* üå´Ô∏è EFFETS ATMOSPH√âRIQUES (HAZE & FADE) */
  // On utilise VIEW_W et OFF_X pour couvrir TOUTE la largeur de l'√©cran
  if (!hazeGradientCache || hazeH !== BASE_H) {
    hazeH = BASE_H;
    const g = ctx.createLinearGradient(0, BASE_H * 0.72, 0, BASE_H);
    g.addColorStop(0, "rgba(0,0,0,0)");
    g.addColorStop(1, "rgba(0,0,0,0.32)");
    hazeGradientCache = g;
  }
  ctx.fillStyle = hazeGradientCache;
  // On dessine de -OFF_X (bord gauche) √† +VIEW_W (bord droit)
  ctx.fillRect(-OFF_X - 100, BASE_H * 0.72, VIEW_W + 200, BASE_H * 2);

  if (!fadeGradientCache || fadeH !== BASE_H) {
    fadeH = BASE_H;
    const g = ctx.createLinearGradient(0, BASE_H * 0.45, 0, BASE_H);
    g.addColorStop(0, "rgba(10,18,40,0)");
    g.addColorStop(1, "rgba(10,18,40,0.22)");
    fadeGradientCache = g;
  }
  ctx.fillStyle = fadeGradientCache;
  ctx.fillRect(-OFF_X - 100, BASE_H * 0.45, VIEW_W + 200, BASE_H * 2);

  /* ü™ô COINS & OBJETS */
  if (coins.length) {
    const baseR = Math.round(coins[0].r * 1.15 * 2) / 2;
    if (!coinGradientCache || coinGradR !== baseR) {
      coinGradR = baseR;
      const g = ctx.createRadialGradient(-baseR * 0.4, -baseR * 0.4, baseR * 0.3, 0, 0, baseR);
      g.addColorStop(0.0, "rgba(255,245,180,1)");
      g.addColorStop(0.4, "rgba(255,210,90,1)");
      g.addColorStop(0.75, "rgba(230,165,30,1)");
      g.addColorStop(1.0, "rgba(160,110,20,1)");
      coinGradientCache = g;
    }

    // Culling intelligent bas√© sur la vue r√©elle
    const VIEW_L = -OFF_X - 160;
    const VIEW_R = WORLD_W + OFF_X + 160;
    const coinBudget = (fps < 58) ? 12 : 9999;
    let drawn = 0;

    for (const c of coins) {
      if (c.x < VIEW_L || c.x > VIEW_R) continue;
      if (++drawn > coinBudget) break;

      ctx.save();
      ctx.translate(c.x | 0, c.y | 0);
      const r = c.r * 1.15;
      ctx.fillStyle = coinGradientCache;
      ctx.beginPath();
      ctx.arc(0, 0, r, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.beginPath();
      ctx.arc(-r * 0.35, -r * 0.35, r * 0.25, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.globalAlpha = 1;
      ctx.strokeStyle = "rgba(255,200,80,0.55)";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    }
  }

  /* üéÆ RENDER DES OBJETS ACTIFS */
  drawObstacles(now);
  drawPlayerParticles(ctx);
  drawPlayer();
  drawParticles();
  drawExplosionFX();

  /* üîì SORTIE DU MODE GAMEPLAY */
  ctx.restore();

  /* =================================================
     5Ô∏è‚É£ RESET FINAL POUR L'UI
  ================================================= */
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
}
// ================= LOOP (AAA STABLE / MOBILE SAFE) =================


// ================= FPS TRACKING =================
let fps = 60;

// temps moteur (UNIQUE SOURCE)
let renderTime = 0;

// constantes
const STEP    = 1000 / 60;   // logique fixe
const DRAW_60 = 1000 / 60;
const DRAW_30 = 1000 / 30;
const MAX_DRAWS_PER_FRAME = 2; // üîí anti-freeze mobile


function loop(ts) {
  if (!loopStarted) return;

  if (lastTS === null || lastTS === 0) {
    lastTS = ts;
    requestAnimationFrame(loop);
    return;
  }

  let delta = ts - lastTS;
  lastTS = ts;

  // 1. PROTECTION CRITIQUE : Cap sur le Delta
  // Si Android freeze 1 seconde, on ne veut pas calculer 60 frames d'un coup (Crash assur√©)
  if (delta > 64) delta = 16.6; // On force une frame normale si gros lag
  if (delta < 0)  delta = 0;

  // 2. FPS TRACKING
  if (delta > 0) {
    fps = Math.min(60, 1000 / delta);
  }

  renderTime += delta;
  fxTime = renderTime * 0.001;

  // 3. UPDATE LOGIQUE AVEC "SAFETY CAP"
  accTime += delta;
  let updates = 0;
  // On limite √† 3 updates max par cycle. Si le tel rame, le jeu ralentit 
  // au lieu d'essayer de rattraper le temps et de chauffer/crasher.
  while (accTime >= STEP && updates < 3) {
    update(STEP, renderTime);
    accTime -= STEP;
    updates++;
  }
  // Si on a trop de retard accumul√©, on vide la poubelle pour lib√©rer le CPU
  if (accTime > STEP * 2) accTime = 0;

  // 4. FX QUALITY (Throttled)
  fxTick += delta;
  if (fxTick >= 120) {
    if (typeof FXQuality !== 'undefined') {
        FXQuality.update(renderTime);
        updateFXState();
    }
    fxTick = 0;
  }

  // 5. DRAW SAFE (Rendu)
  drawAcc += delta;
  const drawStep = (fps < 54) ? DRAW_30 : DRAW_60; // Seuil un peu plus bas pour plus de stabilit√©
  let draws = 0;

  while (drawAcc >= drawStep && draws < MAX_DRAWS_PER_FRAME) {
    drawAcc -= drawStep;
    draw();
    draws++;
  }

  if (draws === MAX_DRAWS_PER_FRAME) {
    drawAcc = 0;
  }

  requestAnimationFrame(loop);
}

// ================= START / STOP =================

// ================= START LOOP (CORRIG√â) =================
function startLoop(){
  if (loopStarted) return;

  // üîí mobile = tier forc√©
  if (typeof FXQuality !== 'undefined' && FXQuality.isMobile){
    FXQuality.setForceTier(0);
  }

  loopStarted = true;
  lastTS      = 0; // On reset le timestamp frame pour √©viter un delta √©norme
  
  // ‚ùå ON NE TOUCHE PAS AUX TIMERS DE JEU ICI !
  // accTime = 0;    <-- On garde l'accu logique
  // renderTime = 0; <-- SUPPRIM√â ! Sinon le revive repart du d√©but du temps
  
  // On reset juste l'accumulateur graphique pour √©viter un fast-forward visuel
  drawAcc = 0; 

  requestAnimationFrame(loop);
}
function stopLoop(){
  loopStarted = false;
}


// ================= PAUSE / RESUME (ZERO JITTER) =================

function pauseLoop(){
  gameRunning = false;
  stopLoop(); // RAF OFF COMPLET
}

function resumeLoop(){
  gameRunning = true;
  startLoop(); // RAF ON PROPRE
}




// ================= INPUT JET =================
function jetStart(){
  if (gameState !== "playing") return;
  jetOn = true;
}
function jetStop(){
  jetOn = false;
}


// ================= RUN RESET (VERSION FINALE) =================
function resetRun(){
  // --- 1. PLAYER PHYSICS ---
  player.x = 100;
  player.y = BASE_H / 2;
  player.width  = BASE_PLAYER_W;
  player.height = BASE_PLAYER_H;
  player.vy = 0;

  jetOn = false;
  
  // --- 2. SYST√àME DE PARTICULES ---
  if (playerParticles) playerParticles.length = 0;
  if (particles) particles.length = 0;
  
  poolIndex = 0; 
  if (typeof particlePool !== 'undefined') {
    for (let i = 0; i < particlePool.length; i++) {
      particlePool[i].active = false;
      particlePool[i]._inList = false;
    }
  }

  // --- 3. OBJETS DU JEU ---
  obstacles.length = 0;
  coins.length = 0;
  bullets.length = 0;

  // --- 4. SCORE & STATS ---
  score = 0;
  coinsCollected = 0;
  combo = 1;
  lastCoinTime = 0;

  // üî• FIX OVERDRIVE COMPLET üî•
  overdriveActive = false;
  overdriveTimer = 0; 
  // Si tu utilises une variable 'overdriveGauge' pour le remplissage, mets-la √† 0 ici aussi :
  // overdriveGauge = 0; 

  // --- 5. SPAWN & DIFFICULT√â ---
  lastSpawn = -5000; 
  lastSpawnTime = -5000; 
  lastTrailSpawn = 0;

  // Reset Cache Position
  farRightCache = 0;
  farRightFrame = -1;

  obstacleSpeed = 3.8; // Vitesse initiale (ou utilise paceMultiplier(0))
  lastType = null;
  
  // üî• IMPORTANT v4.0 : On oublie l'historique de danger !
  // Sinon le jeu peut commencer avec des trous immenses.
  recentHazards = []; 

// --- 6. FX & VISUELS ---
  shake = 0;
  shakeTime = 0;
  shockwave = null;
  bloom = null;
  
  lastBarTime = 0;
  dyingTimer = 0;
  dyingFromCircle = null;

  // üëâ AJOUTE CETTE LIGNE ICI :
  if (typeof initSpaceJourney === "function") initSpaceJourney();

  // --- 7. NEW RECORD RESET ---
  newRecordThisRun = false;
  
  const nrEl = document.getElementById("newRecord");
  if (nrEl) {
      nrEl.style.display = "none"; 
      nrEl.style.opacity = "0";
      nrEl.style.transform = "scale(0.6)";
  }

  // --- 8. UI RESET (SAFE) ---
  if (UI) {
      if (UI.score) UI.score.textContent = "0";
      if (UI.coins) UI.coins.textContent = "0";
      if (UI.combo) UI.combo.textContent = "1";
      
      // FIX BARRE OVERDRIVE
      if (UI.overFill) {
          // Astuce : on coupe la transition pour que la barre se vide INSTANTAN√âMENT
          UI.overFill.style.transition = "none"; 
          UI.overFill.style.height = "0%";
          
          // Force le navigateur √† appliquer le changement tout de suite
          void UI.overFill.offsetWidth; 
          
          // On remet la transition pour la prochaine fois
          UI.overFill.style.transition = ""; 
      }
      
      // Retire l'effet "glow" si la barre √©tait active
      if (UI.overBar) UI.overBar.classList.remove("active");
  }

  // --- 9. MULTIPLIER RESET (NOUVEAU) ---
  if (typeof hasMultiplied !== "undefined") {
      hasMultiplied = false;
  }
  
  const finalCoinsEl = document.getElementById("finalCoins");
  if (finalCoinsEl) {
      // On retire toutes les surcouches de style de l'animation de gain x15
      finalCoinsEl.style.color = "";
      finalCoinsEl.style.textShadow = "none";
      finalCoinsEl.style.fontSize = "";
      finalCoinsEl.style.fontWeight = "";
  }
}
/* =========================================
   START RUN (HYBRIDE : VISUEL + LOGIQUE)
========================================= */

let _startRunLock = false;

function startRun(e){
  // üîí VERROU : On emp√™che le double-tap
  if (_startRunLock) return;

  // ‚è±Ô∏è ANTI-REBOND : Si on vient d'arriver sur le menu (<300ms)
  if (performance.now() - lastMenuEnterTS < 300) return;

  if (uiState === "playing" || gameState === "playing") return;

  _startRunLock = true; 

  if (e){
    e.preventDefault();
    e.stopPropagation();
  }

  // 1. NETTOYAGE VISUEL FORC√â (Anti-BlackScreen)
  const intro = document.getElementById("overlayIntro");
  if (intro){
    intro.style.display = "none";
    intro.style.opacity = "0";
    intro.style.pointerEvents = "none";
  }
  const transFX = document.getElementById("transitionFX");
  if (transFX) {
      transFX.classList.remove("flash");
      transFX.style.opacity = "0";
  }
  const nr = document.getElementById("newRecord");
  if (nr) nr.style.display = "none";

  // 2. LOGIQUE JEU
  gameOverTriggered = false;
  canContinueThisRun = true;
  if (typeof hideContinuePopup === "function") hideContinuePopup();
  if (typeof stopShopPreviewLoop === "function") stopShopPreviewLoop();
  if (typeof stopMenuVideo === "function") stopMenuVideo();

  if (!UI?.score && typeof bindUI === "function") bindUI();
  if (!noiseCanvas && typeof initNoise === "function") initNoise();
  
  // üî• ESSENTIEL : Resize imm√©diat pour √©viter le canvas 0x0
  if (typeof resizeCanvas === "function") resizeCanvas();

  // 3. LANCEMENT
  setUIState("playing");
  document.body.classList.add("playing");

  if (typeof resetRun === "function") resetRun();
  
  // On reset les timers techniques mais PAS le temps global si pas n√©cessaire
  if (typeof resetLoopTimers === "function") resetLoopTimers(true);

  fxCalm = 1;
  gameRunning = true;

  if (typeof startLoop === "function") startLoop();
  
  // Note : On ne d√©verrouille PAS _startRunLock ici via timer.
  // Il sera d√©verrouill√© quand on retournera au Menu ou au GameOver.
}

// ================= LOOP TIMERS RESET (UNIFI√â) =================
// ‚ö†Ô∏è IMPORTANT : on ne touche pas au "renderTime" sauf quand on d√©marre un NOUVEAU run.
function resetLoopTimers(hard = false){
  lastTS  = 0;
  accTime = 0;
  drawAcc = 0;
  fxTick  = 0;

  if (hard){
    renderTime = 0; // ‚úÖ seulement au lancement d‚Äôun run neuf
  }
}



// ================= GAME OVER / MENU =================
function goToMenu(){
  _startRunLock = false;          // üîì R√âARMEMENT CRITIQUE
  setUIState("menu");
  document.body.classList.remove("playing");
  gameOverTriggered = false;
}


function onGameOverCleanup(){
  gameRunning = false;
  stopLoop();               // ‚úÖ coupe RAF
  resetLoopTimers(false);   // ‚úÖ pas de reset renderTime ici (sinon jitter menu/fx)
  fxCalm = 0;
}


// ================= NOISE INIT =================
function initNoise(){
  noiseCanvas = document.createElement("canvas");
  noiseCanvas.width = 256;
  noiseCanvas.height = 256;

  const nctx = noiseCanvas.getContext("2d", { alpha: true });
  const img = nctx.createImageData(noiseCanvas.width, noiseCanvas.height);

  for(let i = 0; i < img.data.length; i += 4){
    const v = (Math.random() * 255) | 0;
    img.data[i]   = v;
    img.data[i+1] = v;
    img.data[i+2] = v;
    img.data[i+3] = 40; // alpha l√©ger
  }

  nctx.putImageData(img, 0, 0);
}


// ================= MENU VIDEO (GPU SAFE) =================
const MENU_VIDEO_SRC = menuVideo?.dataset?.src || "";

function startMenuVideo(){
  if (!menuVideo || !MENU_VIDEO_SRC) return;

  if (!menuVideo.src){
    menuVideo.src = MENU_VIDEO_SRC;
    menuVideo.load();
  }

  menuVideo.currentTime = 0;
  const p = menuVideo.play();
  if (p && p.catch) p.catch(()=>{});
}

// Remplace ta fonction √† la ligne 1162 par celle-ci :
function stopMenuVideo(){
  if (!menuVideo) return;

  try {
    menuVideo.pause();
    // üõ°Ô∏è On attend 100ms que le moteur vid√©o ait fini de pauser 
    // avant de vider le SRC, pour √©viter le crash Android.
    setTimeout(() => {
        if (uiState === "playing") { // On v√©rifie qu'on est toujours en jeu
            menuVideo.removeAttribute("src");
            menuVideo.load(); 
        }
    }, 100);
  } catch(e) {
    console.error("Video Stop Error Safe", e);
  }
}



// ================= STOP GAME LOOP (GPU FRIENDLY) =================
function stopGameLoop(){
  gameRunning = false;
  stopLoop();
  resetLoopTimers(false);

  // lib√®re le canvas
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  fxCalm = 0.6;
}


// ================= MENU ENTRY (CORRIG√â : AUDIO & SYNC) =================
function startMenu(){
  // üõ°Ô∏è FIX CRITIQUE : On utilise la fonction centrale au lieu de uiState = "menu"
  // Cela garantit l'appel √† playMusic("menu") et l'arr√™t des √©l√©ments de jeu.
  if (typeof setUIState === "function") {
    setUIState("menu"); 
  } else {
    uiState = "menu";
    gameState = "menu";
  }

  gameRunning = false;
  document.body.classList.remove("playing");

  // Arr√™t moteur et vid√©o
  stopGameLoop();
  startMenuVideo();

  // ‚úÖ 1. Stats : Affiche les vrais scores
  if (typeof updateMenuStats === "function") updateMenuStats();

  // ‚úÖ 2. Pubs : Reset journalier
  if (typeof checkDailyAdReset === "function") checkDailyAdReset();

  // ‚úÖ 3. UI : Nettoyage popup
  if (typeof hideMenuAdPopup === "function") hideMenuAdPopup();

  // ‚úÖ 4. Timer Popup (S√©curit√© Android)
  setTimeout(() => {
    // On v√©rifie qu'on est toujours sur le menu avant d'afficher
    if (uiState === "menu" && typeof showMenuAdPopup === "function") {
      showMenuAdPopup();
    }
  }, 900);
}
// ================= FX FLAGS =================
let skipHeavyFX = false;

// ================= SHOP NAV (CORRIG√â V2) =================
function switchSkin(dir){
  // On utilise la nouvelle navigation du moteur V2
  shopNav(dir);
}

/* =========================================================
   MENU + SHOP + OPTIONS (UI ONLY)
   - NO AUDIO
   - NO GAME LOOP
   - SHOP = RAF UNIQUE
========================================================= */

const menuOverlayEl  = document.getElementById("menuOverlay");
const menuButtonsEl2 = document.getElementById("menuButtons");
const shopPanelEl2   = document.getElementById("shopPanel");
const shopBackBtnEl2 = document.getElementById("shopBackBtn");

// üîí SAFETY CHECK
if (!menuOverlayEl)  console.warn("[UI] menuOverlayEl manquant");
if (!menuButtonsEl2) console.warn("[UI] menuButtonsEl2 manquant");
if (!shopPanelEl2)   console.warn("[UI] shopPanelEl2 manquant");
if (!shopBackBtnEl2) console.warn("[UI] shopBackBtnEl2 manquant");


/* ================= MENU STATS ================= */
function updateMenuStats(){
  const best  = Number(localStorage.getItem("bestScore")  || 0);
  const coins = Number(localStorage.getItem("coinsBank") || 0);

  const sb = document.getElementById("shopBest");
  const sc = document.getElementById("shopCoins");
  const mb = document.getElementById("menuBest");
  const mc = document.getElementById("menuCoins");

  if (sb) sb.textContent = best.toLocaleString();
  if (sc) sc.textContent = coins.toLocaleString();
  if (mb) mb.textContent = best.toLocaleString();
  if (mc) mc.textContent = coins.toLocaleString();
}


/* =========================================================
   üöÄ SHOP SYSTEM V7 ‚Äî FINAL LOGIC (Dynamic, HD, Zoom, Locked FX)
========================================================= */

// Variables Globales Shop
let shopPreviewIdx = 0;
let shopCanvasCtx  = null;
let shopRafId      = 0;

// --- 1. FONCTIONS PRINCIPALES ---

function openShop(){
  if (typeof Player !== "undefined") Player.load(); 

  // üî• FIX : On initialise l'√©tat r√©el de la roulette AVANT d'afficher le shop
  if (typeof initRoulette === "function") {
      initRoulette(); 
  }

  // 1. Change l'√©tat global (Menu -> Shop)
  setUIState("shop");
  
  // 2. Construit le HTML si n√©cessaire (Une seule fois)
  if (!document.getElementById("shopHeroCanvas")) {
      initShopUI();
  }
  
  // 3. Met √† jour les infos (Prix, Nom, Fond)
  updateShopDisplay();
  
  // 4. Lance la boucle d'animation
  loopShopPreview(); 
}

function closeShop(){
  // 1. Arr√™te l'animation (Batterie)
  stopShopPreviewLoop();
  
  // 2. Retour au menu
  setUIState("menu");
}

function stopShopPreviewLoop(){
  if (shopRafId){
    cancelAnimationFrame(shopRafId);
    shopRafId = 0;
  }
}

// --- 3. NAVIGATION & UPDATE ---

function shopNav(dir){
  shopPreviewIdx = (shopPreviewIdx + dir + SKIN_KEYS.length) % SKIN_KEYS.length;
  updateShopDisplay();
}
// ================================
// MISE √Ä JOUR DE L'AFFICHAGE SHOP
// ================================
function updateShopDisplay(){
  const totalCoinsEl = document.getElementById("shopTotalCoins");
  if (totalCoinsEl && typeof Player !== "undefined") {
      totalCoinsEl.textContent = Player.coins.toLocaleString();
  }

  const skinId = SKIN_KEYS[shopPreviewIdx];
  const skin   = SKINS_DB[skinId];
  
  const elName  = document.getElementById("shopSkinName");
  const elPrice = document.getElementById("shopSkinPrice");
  const btn     = document.getElementById("shopActionBtn");
  const panel   = document.getElementById("shopPanel");
  const adBlock = document.getElementById("shopAdBlock");
  
  if (!elName || !skin) return;

  // Textes
  elName.textContent = skin.name;

  // Logique Achat
  const isOwned = Player.unlocked.includes(skinId);
  const isEquipped = (Player.equipped === skinId);
  const canAfford = Player.coins >= skin.price;

  btn.className = "skinButton";
  btn.onclick = null;
  btn.style.opacity = 1;
  btn.style.cursor = "pointer";

  if (isEquipped){
    // CAS : D√âJ√Ä √âQUIP√â
    elPrice.textContent = "EQUIPPED";
    elPrice.style.color = "#8aff8a";
    elPrice.classList.remove("price-paid");
    
    btn.textContent = "SELECTED";
    btn.classList.add("equipped");
    
  } else if (isOwned){
    // CAS : ACHET√â MAIS PAS √âQUIP√â
    elPrice.textContent = "OWNED";
    elPrice.style.color = "#a0c0ff";
    elPrice.classList.remove("price-paid");

    btn.textContent = "EQUIP";
    btn.classList.add("owned");
    btn.onclick = () => { 
        Player.equip(skinId); 
        currentSkin = skinId; 
        updateShopDisplay(); 
    };

  } else {
    // CAS : PAS ENCORE ACHET√â (LOCKED)
    elPrice.textContent = skin.price.toLocaleString() + " COINS";
    elPrice.style.color = canAfford ? "#fff" : "#ff5555";
    elPrice.classList.remove("price-paid"); 

    btn.classList.add(skin.category || "common");

    if (canAfford){
      // Peut acheter
      btn.textContent = "UNLOCK";
      
      // üî• LE D√âCLENCHEUR D'ANIMATION EST ICI üî•
      btn.onclick = () => { 
        if (Player.buy(skinId)){ 
            // 1. D√©clencher l'animation CSS sur le Canvas
            const heroCanvas = document.getElementById("shopHeroCanvas");
            if (heroCanvas) {
                heroCanvas.classList.remove("unlock-success");
                void heroCanvas.offsetWidth; 
                heroCanvas.classList.add("unlock-success");
                
                setTimeout(() => {
                    heroCanvas.classList.remove("unlock-success");
                }, 1000);
            }

            // 2. Feedback texte imm√©diat
            elPrice.textContent = "UNLOCKED !";
            elPrice.classList.add("price-paid");
            
            // 3. On met √† jour le skin s√©lectionn√©
            currentSkin = skinId; 

            // 4. On attend la fin du flash avant de rafra√Æchir
            setTimeout(() => { 
                updateShopDisplay(); 
            }, 600); 
        } 
      };
      
    } else {
      // ‚ö†Ô∏è NOUVEAU : Pas assez d'argent -> On force le joueur √† utiliser la Roulette
      btn.textContent = "NEED COINS";
      btn.style.opacity = 0.5;
      btn.style.cursor = "not-allowed";
      btn.onclick = null;
    }
  }

  // ‚ö†Ô∏è NOUVEAU : Le bouton Roulette est TOUJOURS visible dans le shop
  if (adBlock) {
      adBlock.style.display = "flex";
  }
  
  // Met √† jour le texte du bouton Roulette (ex: "3 SPINS LEFT")
  if (typeof updateRouletteUI === "function") {
      updateRouletteUI();
  }

  // Fond dynamique
  if (panel) {
      let bgGradient = "";
      const cat = skin.category || "common";
      const name = skin.name.toUpperCase();
      const overlay = isOwned ? 0 : 0.4; 

      if (cat === "common")    bgGradient = "rgba(100,100,100,0.25)";
      if (cat === "rare")      bgGradient = "rgba(0, 150, 255, 0.35)";
      if (cat === "epic")      bgGradient = "rgba(180, 0, 255, 0.35)";
      if (cat === "legendary") bgGradient = "rgba(255, 200, 0, 0.4)";

      if (name.includes("INFERNO")) bgGradient = "rgba(255, 60, 0, 0.45)";
      if (name.includes("NEON"))    bgGradient = "rgba(0, 255, 200, 0.35)";
      if (name.includes("NATURE"))  bgGradient = "rgba(50, 255, 50, 0.3)";
      if (name.includes("VOID"))    bgGradient = "rgba(100, 0, 255, 0.4)";

      panel.style.background = `radial-gradient(circle at 50% 50%, ${bgGradient}, rgba(0,0,0,${0.7 + overlay}) 80%), linear-gradient(180deg, #050810 0%, #000000 100%)`;
  }
}

// ==========================================
// üöÄ FIX LAG SHOP : Remplacer "filter" par "overlay"
// ==========================================

function loopShopPreview(){
  if (shopRafId) cancelAnimationFrame(shopRafId);
  if (uiState !== "shop") return;
  
  if (shopCanvasCtx){
    const skinId = SKIN_KEYS[shopPreviewIdx];
    const isOwned = Player.unlocked.includes(skinId);

    const w = shopCanvasCtx.canvas.width;
    const h = shopCanvasCtx.canvas.height;

    // 1. Nettoyage
    shopCanvasCtx.clearRect(0, 0, w, h);
    
    const t = performance.now(); 
    fxTime = t * 0.001; 

    shopCanvasCtx.save();
    
    // 2. Centrage & Zoom
    shopCanvasCtx.translate(w/2, h/2);
    const ZOOM_LEVEL = 12.0;
    shopCanvasCtx.scale(ZOOM_LEVEL, ZOOM_LEVEL);
    shopCanvasCtx.translate(-w/2, -h/2);

    // ‚õî SUPPRESSION DU FILTRE TUEUR DE PERFS
    // shopCanvasCtx.filter = ... (ON ENLEVE √áA)
    shopCanvasCtx.filter = "none"; 

    // 3. DESSIN DU PERSO (Normal)
    if (typeof drawPlayerPreview === "function") {
        drawPlayerPreview(shopCanvasCtx, skinId, t);
    }

    // 4. FX AVANT
    if (skinId === "voidwalker" && typeof drawVoidwalkerFrontFX === "function"){
        drawVoidwalkerFrontFX(shopCanvasCtx, 0, 0, w, h, t);
    }
    
    // ‚úÖ 5. EFFET "LOCKED" OPTIMIS√â (METHODE RAPIDE)
    // Au lieu de calculer des pixels gris, on pose juste un voile noir dessus.
    if (!isOwned) {
        shopCanvasCtx.save();
        // On repasse en coordonn√©es normales pour couvrir tout le canvas
        shopCanvasCtx.setTransform(1,0,0,1,0,0); 
        
        shopCanvasCtx.fillStyle = "rgba(0, 0, 0, 0.85)"; // Noir tr√®s opaque
        shopCanvasCtx.fillRect(0, 0, w, h);
        
        // Optionnel : On peut ajouter un cadenas dessin√© simplement
        shopCanvasCtx.fillStyle = "rgba(255, 255, 255, 0.2)";
        shopCanvasCtx.font = "bold 40px monospace";
        shopCanvasCtx.textAlign = "center";
        shopCanvasCtx.textBaseline = "middle";
        shopCanvasCtx.fillText("üîí", w/2, h/2);
        
        shopCanvasCtx.restore();
    }
    
    shopCanvasCtx.restore();
  }
  
  shopRafId = requestAnimationFrame(loopShopPreview);
}



/* =========================================================
   UI STATE CENTRAL ‚Äî FINAL (OPTIMIS√â AUDIO V15)
========================================================= */
let _menuAdTimer = 0;
let uiState = "menu"; 

function setUIState(state){

  // üîí ID√âMPOTENCE (On ne fait rien si on est d√©j√† dans cet √©tat)
  if (uiState === state) return;

  uiState = state;
  if (state === "playing") gameState = "playing";
  else if (state === "gameover") gameState = "gameover";
  else gameState = "menu";

  // === R√âF√âRENCES DOM ===
  const uiLayer         = document.getElementById("uiLayer");
  const touchZone       = document.getElementById("touchZone");
  const overlayMenuEl   = document.getElementById("menuOverlay");
  const menuStats       = document.getElementById("menuStats");
  const gc              = document.getElementById("gameContainer");
  const shopPanel       = document.getElementById("shopPanel");
  const overlayGameOver = document.getElementById("overlayGameOver");
  const optionsPanelEl  = document.getElementById("optionsPanel");
  const intro           = document.getElementById("overlayIntro");

  // === üì∫ GESTION PUBS (Banni√®re) ===
  if (state === "menu") {
    if (typeof showBanner === "function") showBanner();
  } else {
    if (typeof hideBanner === "function") hideBanner();
  }

  // === RESET VISUEL GLOBAL ===
  if (uiLayer) uiLayer.classList.remove("allow-input");
  if (touchZone) touchZone.style.pointerEvents = "auto";
  if (gc)        gc.style.pointerEvents = "auto";
  if (shopPanel) shopPanel.classList.remove("visible");

  if (optionsPanelEl){
    optionsPanelEl.style.display = "none";
    optionsPanelEl.style.pointerEvents = "none";
  }

  if (overlayGameOver){
    overlayGameOver.classList.remove("visible");
    overlayGameOver.style.display = "none";
    overlayGameOver.style.pointerEvents = "none";
  }

  jetOn = false;

  // === LOGIQUE DES √âTATS ===
  switch(state){

    case "menu": {
      _startRunLock = false; // üîì D√©verrouille le jeu
      lastMenuEnterTS = performance.now();
      
      stopShopPreviewLoop();
      startMenuVideo();

      // Nettoyage Intro (Au cas o√π)
      if (intro){
        intro.style.display = "none";
        intro.style.pointerEvents = "none";
      }

      if (overlayMenuEl){
        overlayMenuEl.style.display = "flex";
        overlayMenuEl.style.visibility = "visible";
        overlayMenuEl.style.pointerEvents = "auto";
      }

      if (menuStats) menuStats.style.display = "flex";
      if (typeof updateMenuStats === "function") updateMenuStats();

      // Pub Popup Menu
      setTimeout(() => {
        if (typeof showMenuAdPopup === "function") showMenuAdPopup();
      }, 100);

      playMusic("menu");
      break;
    }

    case "shop": {
      startMenuVideo();
      if (typeof hideMenuAdPopup === "function") hideMenuAdPopup();

      if (overlayMenuEl) overlayMenuEl.style.display = "flex"; // Garde le fond menu

      if (shopPanel){
        shopPanel.classList.add("visible");
        shopPanel.style.pointerEvents = "auto";
      }

      playMusic("menu"); // V15 saura qu'il ne faut pas reset si √ßa joue d√©j√†
      break;
    }

    case "options": {
      stopShopPreviewLoop();
      if (typeof hideMenuAdPopup === "function") hideMenuAdPopup();

      if (overlayMenuEl) overlayMenuEl.style.display = "flex";

      if (optionsPanelEl){
        optionsPanelEl.style.display = "flex";
        optionsPanelEl.style.visibility = "visible";
        optionsPanelEl.style.pointerEvents = "auto";
      }

      playMusic("menu");
      break;
    }

   case "playing": {
  stopShopPreviewLoop();
  stopMenuVideo();
  if (typeof hideMenuAdPopup === "function") hideMenuAdPopup();

  if (overlayMenuEl){
    overlayMenuEl.style.display = "none";
    overlayMenuEl.style.pointerEvents = "none";
  }

  playMusic("game"); // DIRECT
  break;
}


    case "gameover": {
      _startRunLock = false; // üîì D√©verrouille pour permettre le replay
      stopShopPreviewLoop();
      // stopMenuVideo(); 
      
      if (typeof hideMenuAdPopup === "function") hideMenuAdPopup();
      if (uiLayer) uiLayer.classList.add("allow-input");

      if (overlayGameOver){
        overlayGameOver.style.display = "flex";
        overlayGameOver.classList.add("visible");
        overlayGameOver.style.pointerEvents = "auto";
      }

      if (touchZone) touchZone.style.pointerEvents = "none";

      // üîá Silence √† la mort (V15 g√®re √ßa proprement)
      playMusic("none"); 
      break;
    }
  }
}

/* =========================================================
   üí∞ GAME OVER MULTIPLIER WHEEL SYSTEM (NEON EDITION)
========================================================= */

let isMultiSpinning = false;
let multiCurrentRotation = 0;

// Les segments doivent correspondre exactement √† ton CSS
const multiSegments = [
    { v: 2,  chance: 0.50, minDeg: 0, maxDeg: 180, color: "#ffffff" },
    { v: 4,  chance: 0.25, minDeg: 180, maxDeg: 270, color: "#00f0ff" },
    { v: 6,  chance: 0.15, minDeg: 270, maxDeg: 324, color: "#b400ff" },
    { v: 8,  chance: 0.07, minDeg: 324, maxDeg: 349, color: "#ff00ff" },
    { v: 10, chance: 0.02, minDeg: 349, maxDeg: 356, color: "#ffd700" },
    { v: 15, chance: 0.01, minDeg: 356, maxDeg: 360, color: "#ff3c00" }
];

function startMultiplierSpin() {
    if (isMultiSpinning) return;
    
    const btn = document.getElementById("multiplyBtn");
    if (btn) {
        btn.innerHTML = `
            <span style="display:block;">üé¨ LOADING AD...</span>
            <span style="display:block; font-size:10px; font-weight:400;">PLEASE WAIT</span>
        `;
        btn.disabled = true;
        btn.style.filter = "grayscale(1) brightness(0.7)";
    }

    if (typeof showRewardedAd === "function") {
        showRewardedAd(
            () => { 
                // SUCC√àS : On affiche le fond de la roulette, mais on attend le clic !
                const popup = document.getElementById("multiplierPopup");
                if (popup) popup.style.display = "flex";
                
                showTapToSpinOverlay(() => { 
                    executeMultiplierWheel(); 
                }); 
            },
            () => { 
                // √âCHEC / ANNULATION : On remet le bouton normal
                if (btn) {
                    btn.innerHTML = `
                        <span style="display:block;">üî• MULTIPLY COINS</span>
                        <span style="display:block; font-size:10px; font-weight:400;">( WATCH AD TO SPIN )</span>
                    `;
                    btn.disabled = false;
                    btn.style.filter = "none";
                }
            }
        );
    } else {
        // Mode Test (PC)
        const popup = document.getElementById("multiplierPopup");
        if (popup) popup.style.display = "flex";
        showTapToSpinOverlay(() => { executeMultiplierWheel(); });
    }
}

// On s'assure que les variables sont globales et ne se r√©initialisent pas
window.isMultiSpinning = false;
window.multiCurrentRotation = 0;

function executeMultiplierWheel() {
    if (window.isMultiSpinning) return;
    window.isMultiSpinning = true;
    
    const popup = document.getElementById("multiplierPopup");
    const wheel = document.getElementById("multiWheel");
    const resultText = document.getElementById("multiResult");

    if (!wheel) return; // S√©curit√©

    popup.style.display = "flex";
    resultText.textContent = "SPINNING...";
    resultText.style.color = "#fff";

// Les couleurs doivent correspondre au nouveau CSS Cyberpunk
    const segments = [
        { v: 2,  c: 0.50, deg: 90,    col: "#ffffff" }, // Texte blanc pour coller au fond carbone
        { v: 4,  c: 0.28, deg: 225,   col: "#00ffcc" },
        { v: 6,  c: 0.12, deg: 297,   col: "#7d2ae8" },
        { v: 8,  c: 0.06, deg: 336.5, col: "#ff007c" },
        { v: 10, c: 0.03, deg: 352.5, col: "#ffaa00" },
        { v: 15, c: 0.01, deg: 358,   col: "#ffdf00" }
    ];

    let rand = Math.random(), cumul = 0, win = segments[0];
    for (let s of segments) {
        cumul += s.c;
        if (rand <= cumul) { win = s; break; }
    }

    // Calcul rotation cible (8 tours complets + l'angle)
    const targetAngle = 360 - win.deg;
    window.multiCurrentRotation += (360 * 8) + targetAngle - (window.multiCurrentRotation % 360);
    
    // üî• FIX ROTATION : On force l'application de la transition ici !
    wheel.style.transition = "transform 5s cubic-bezier(0.15, 0, 0.15, 1)";
    
    // Petit hack (void) pour forcer le navigateur √† prendre en compte la transition avant de tourner
    void wheel.offsetWidth; 
    
    // On lance la rotation
    wheel.style.transform = `rotate(${window.multiCurrentRotation}deg)`;

    // Effet sonore / vibration simul√© (Optionnel)
    let clickInterval = setInterval(() => {
        if(navigator.vibrate) navigator.vibrate(5);
    }, 150);
    setTimeout(() => clearInterval(clickInterval), 4000);

    // R√©sultat apr√®s 5 secondes
    setTimeout(() => {
        window.isMultiSpinning = false;
        hasMultiplied = true;
        
        // Impact final
        if(navigator.vibrate) navigator.vibrate([30, 50, 30]);
        
        // Gain des pi√®ces
        const bonus = (typeof coinsCollected !== 'undefined' ? coinsCollected : 0) * (win.v - 1);
        if (typeof coinsBank !== 'undefined') {
            coinsBank += bonus;
            if(typeof Player !== 'undefined') { Player.coins = coinsBank; Player.save(); }
        }

        // Affichage R√©sultat
        resultText.innerHTML = `<span style="color:${win.col}">x${win.v}</span> UNLOCKED!`;
        resultText.animate([
            { transform: 'scale(0.8)', opacity: 0 },
            { transform: 'scale(1.1)', opacity: 1 },
            { transform: 'scale(1)', opacity: 1 }
        ], { duration: 500 });

        // Mise √† jour sur l'√©cran de Game Over en arri√®re plan
        const finalCoinsEl = document.getElementById("finalCoins");
        if (finalCoinsEl) {
            finalCoinsEl.textContent = (coinsCollected * win.v).toLocaleString();
            finalCoinsEl.style.color = win.col;
            finalCoinsEl.style.textShadow = `0 0 15px ${win.col}`;
        }

        // Cache le bouton multiplier
        const multiplyBtn = document.getElementById("multiplyBtn");
        if (multiplyBtn) multiplyBtn.style.display = "none";

        // Fermeture automatique (2 secondes)
        setTimeout(() => { 
            popup.style.display = "none"; 
            resultText.textContent = ""; 
        }, 2000);

    }, 5000);
}
// --- NOTIFICATIONS LOCALES (FREE SPIN 24H) ---
const LocalNotifications = window.Capacitor && window.Capacitor.Plugins.LocalNotifications;

async function scheduleFreeSpinNotification() {
    if (!LocalNotifications) {
        console.log("Notifications non support√©es sur ce support (Web).");
        return;
    }

    try {
        // 1. Demander la permission
        let permStatus = await LocalNotifications.checkPermissions();
        if (permStatus.display !== 'granted') {
            permStatus = await LocalNotifications.requestPermissions();
        }
        
        if (permStatus.display !== 'granted') return; // L'utilisateur a refus√©

        // 2. Calculer l'heure : EXACTEMENT dans 24 heures
        // Date.now() donne le temps actuel en millisecondes. 
        // On ajoute 24 heures * 60 minutes * 60 secondes * 1000 ms
        const targetTime = new Date(Date.now() + 24 * 60 * 60 * 1000); 

        // 3. Programmer la notification
        await LocalNotifications.schedule({
            notifications: [
                {
                    title: "üéÅ FREE SPIN READY!",
                    body: "Your daily Lucky Spin is available. Come win up to 1000 Coins!üíé",
                    id: 1, // ID fixe : si on reprogramme, √ßa √©crase l'ancienne
                    schedule: { at: targetTime }, // D√©clenchement √† H+24
                    actionTypeId: "",
                    extra: null
                }
            ]
        });
        
        console.log("üîî Notification Free Spin programm√©e pour demain √† :", targetTime.toLocaleTimeString());

    } catch (e) {
        console.warn("Erreur Notification:", e);
    }
}
/* =========================================================
   üöÄ DOM READY FINAL (ANTI-GHOST CLICK + STARTRUN SAFE)
========================================================= */

let globalInputLock = false;

document.addEventListener("DOMContentLoaded", () => {
  console.log("üöÄ GALAXY RUSH: System Init...");

  // =========================
  // 1Ô∏è‚É£ INIT TECHNIQUE
  // =========================
  if (typeof bindCanvas === "function") bindCanvas();

  if (typeof resizeCanvas === "function") {
    resizeCanvas();
    setTimeout(resizeCanvas, 50); // S√©curit√© Android
  }

  if (typeof bindUI === "function") bindUI();
  if (typeof initNoise === "function") initNoise();

  // =========================
  // 2Ô∏è‚É£ CHARGEMENT DONN√âES
  // =========================
  if (typeof Player !== "undefined") Player.load();
  if (typeof initDailyAds === "function") initDailyAds();
  if (typeof updateMenuStats === "function") updateMenuStats();
  if (typeof startMenuVideo === "function") startMenuVideo();

 // =========================
  // 3Ô∏è‚É£ INTRO (D√âCLENCHEUR AUDIO MA√éTRE)
  // =========================
  const intro = document.getElementById("overlayIntro");

  if (intro) {
    intro.style.display = "flex";
    intro.style.opacity = "1";
    intro.style.pointerEvents = "auto";

    intro.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();

      if (globalInputLock) return;
      globalInputLock = true;

      // ‚ö° 1. D√âVERROUILLAGE FORCE DU MOTEUR AUDIO (CRITIQUE)
      if (typeof unlockAllAudio === "function") {
          unlockAllAudio(); // R√©veille le AudioContext
      }

      // üîä 2. SFX DE D√âPART
      if (typeof playSFX === "function" && sfxIntro) {
        playSFX(sfxIntro, 0.8);
      }

      // ‚ú® 3. EFFET VISUEL
      intro.classList.add("fx-impact");
      const fx = document.getElementById("transitionFX");
      if (fx) {
        fx.classList.remove("flash");
        void fx.offsetWidth;
        fx.classList.add("flash");
      }

      // üéµ 4. LANCEMENT MUSIQUE MENU IMM√âDIAT
      // On le fait ICI manuellement pour √™tre s√ªr que √ßa part au clic
      if (typeof playMusic === "function") {
          playMusic("menu");
      }

      // 5. CHANGEMENT D'√âTAT UI
      // (Le setTimeout permet √† l'animation CSS de se jouer)
      setTimeout(() => {
          setUIState("menu"); // Cela confirmera la musique
          intro.style.display = "none";
          intro.style.pointerEvents = "none";
          globalInputLock = false;
      }, 600);

    }, { passive: false });
  }

// =========================
// 4Ô∏è‚É£ BOUTON PLAY (ULTRA SAFE)
// =========================
const btnPlay = document.getElementById("btnPlay");

if (btnPlay) {
  btnPlay.addEventListener("click", (e) => {
    // üõ°Ô∏è Neutralisation totale de l‚Äôevent
    if (e) {
      e.preventDefault();
      e.stopPropagation();
    }

    // üîí Verrou global (intro / transition)
    if (globalInputLock) return;

    // üîí Verrou d‚Äô√©tat (anti ghost / anti reset musique)
    if (uiState === "playing" || gameState === "playing") {
      console.warn("‚õî PLAY bloqu√© : jeu d√©j√† en cours");
      return;
    }

    // üöÄ Lancement s√©curis√©
    startRun(e);
  });
}


  const btnShop = document.getElementById("btnShop");
  if (btnShop) {
    btnShop.addEventListener("click", () => {
      if (!globalInputLock && typeof openShop === "function") {
        openShop();
      }
    });
  }

  const btnOptions = document.getElementById("btnOptions");
  if (btnOptions) {
    btnOptions.addEventListener("click", () => {
      if (!globalInputLock) setUIState("options");
    });
  }

  // =========================
  // 5Ô∏è‚É£ BINDING UTILITAIRE
  // =========================
  const bindBtn = (id, handler) => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener("click", handler);
    }
  };

  bindBtn("optBack", () => setUIState("menu"));
  bindBtn("menuBtn", () => goToMenu());

  // =========================
  // 6Ô∏è‚É£ RESTART (ANTI-SPAM)
  // =========================
  bindBtn("restartBtn", (e) => {
    if (uiState === "playing" || gameState === "playing") return;
    startRun(e);
  });





    // 5. PUBS & CADEAUX
    const menuAdBtn = document.getElementById("menuAdBtn");
    if (menuAdBtn) {
        menuAdBtn.onclick = (e) => {
            e.preventDefault();
            if (typeof watchAdForCoins === "function") watchAdForCoins("menu");
        };
    }

    const btnRevive = document.getElementById("continueAdBtn");
    if (btnRevive) btnRevive.addEventListener("click", () => { if(typeof handleContinueAd === "function") handleContinueAd(); });

    const btnSkip = document.getElementById("btnSkip");
    if (btnSkip) btnSkip.addEventListener("click", () => { if(typeof hideContinuePopup === "function") hideContinuePopup(); });

    const btnShopAd = document.getElementById("shopAdBlock");
    if (btnShopAd) {
         btnShopAd.onclick = () => { 
             if (typeof canWatchAd === "function" && canWatchAd() && typeof watchAdForCoins === "function") {
                 watchAdForCoins("shop"); 
             }
         };
    }

    // 6. INPUTS JEU (S√âCURIS√âS)
    // On emp√™che de lancer le jetpack si le verrou est actif
    
    // Swipe Shop
    let touchX = 0;
    const shopP = document.getElementById("shopPanel");
    if (shopP) {
        shopP.addEventListener("touchstart", (e) => { 
            if (e.touches.length) touchX = e.touches[0].clientX; 
        }, { passive: true });
        
        shopP.addEventListener("touchend", (e) => {
            if (!e.changedTouches.length) return;
            const dx = e.changedTouches[0].clientX - touchX;
            if (Math.abs(dx) > 50 && typeof shopNav === "function") shopNav(dx < 0 ? 1 : -1);
        }, { passive: true });
    }

    // Touch & Souris
    const handleInput = (e) => {
        // üõ°Ô∏è CHECK VERROU
        if (typeof uiState !== "undefined" && uiState === "playing" && !globalInputLock) {
            if (e.cancelable) e.preventDefault();
            if (typeof jetStart === "function") jetStart();
        }
    };
    const handleRelease = () => {
        if (typeof uiState !== "undefined" && uiState === "playing") {
            if (typeof jetStop === "function") jetStop();
        }
    };

    window.addEventListener("touchstart", handleInput, { passive: false });
    window.addEventListener("touchend", handleRelease);
    window.addEventListener("mousedown", (e) => { 
        if(typeof uiState !== "undefined" && uiState === "playing" && !e.target.closest("button") && !globalInputLock) jetStart(); 
    });
    window.addEventListener("mouseup", handleRelease);

    // Clavier
    window.addEventListener("keydown", (e) => {
        if (e.repeat) return;
        if (typeof uiState !== "undefined" && uiState === "playing" && ["Space", "ArrowUp", "KeyZ"].includes(e.code) && !globalInputLock) {
            e.preventDefault();
            if (typeof jetStart === "function") jetStart();
        }
    });
    window.addEventListener("keyup", (e) => {
        if (typeof uiState !== "undefined" && uiState === "playing" && ["Space", "ArrowUp", "KeyZ"].includes(e.code)) {
            if (typeof jetStop === "function") jetStop();
        }
    });

    // 7. FIN
    setTimeout(() => {
        if (typeof updateAdButtonState === "function") updateAdButtonState();
    }, 500);
});
/* =========================================
   D√âCLENCHEUR DE SECOURS (A METTRE TOUT EN BAS)
========================================= */
    const introZone = document.getElementById("overlayIntro");
    
    if (introZone) {
        // On nettoie les anciens √©couteurs pour √©viter les doublons
        const newIntro = introZone.cloneNode(true);
        introZone.parentNode.replaceChild(newIntro, introZone);
        
        // On attache le NOUVEL √©couteur
        newIntro.addEventListener("pointerdown", (e) => {
            // Emp√™che le clic de traverser
            e.preventDefault();
            e.stopPropagation();
            
            // LANCE LA TRANSITION
            playIntroTransition();
        });
        
        console.log("‚úÖ Intro Listener Attach√© avec succ√®s.");
    }

// Fallbacks Globaux
if (typeof FXQuality !== "undefined") FXQuality.setForceTier(0);
if (typeof obstacleCache !== "undefined") obstacleCache.initialized = false;

/* =========================================
   üîß HARD REFRESH CANVAS (Fix GPU Android SAFE)
========================================= */
function hardRefreshCanvas() {
    console.log("üîß HARD REFRESH CANVAS (Android Surface rebuild SAFE)");
    const c = document.getElementById("game");
    if (!c) return;

    // üî• FIX : On ne met PLUS JAMAIS la largeur ou la hauteur √† 0.
    // On appelle directement ta fonction resizeCanvas qui recalcule tout proprement
    // et recr√©e le contexte sans le d√©truire d√©finitivement.
    if (typeof resizeCanvas === "function") {
        resizeCanvas();
    }
}
/* =========================================================
   üì∫ ADMOB MANAGER V3 (CONSOLIDATED & SECURE)
========================================================= */
const AdMob = window.Capacitor && window.Capacitor.Plugins.AdMob;

const AD_IDS = {
    // Tes vrais IDs
    interstitial: 'ca-app-pub-2409581870901167/2901010676', 
    reward:       'ca-app-pub-2409581870901167/2170712506 ', 
    
    // ‚ö†Ô∏è IMPORTANT : Mets 'false' uniquement pour la PROD (Play Store)
    // Mets 'true' pour tester chez toi sans risque de ban
    isTesting:    false 
};

// --- 1. INITIALISATION ---
async function initAds() {
    if (!AdMob) { console.log("AdMob: Mode Web (Pas de pubs)"); return; }

    try {
        await AdMob.initialize({ requestTrackingAuthorization: true });

        // Pr√©pare les pubs en avance
        await AdMob.prepareInterstitial({ adId: AD_IDS.interstitial, isTesting: AD_IDS.isTesting });
        await AdMob.prepareRewardVideoAd({ adId: AD_IDS.reward, isTesting: AD_IDS.isTesting });

        // üí∞ √âcouteur : R√©compense (Reward)
        AdMob.addListener('onRewardedVideoAdReward', (item) => {
            console.log("üí∞ R√©compense AdMob re√ßue !");
            if (window.pendingRewardSuccess) {
                window.pendingRewardSuccess(); 
                window.pendingRewardSuccess = null;
            }
        });

        // üì∫ √âcouteur : Pub R√©compens√©e FERM√âE (LE FIX EST L√Ä)
        AdMob.addListener('onRewardedVideoAdDismissed', () => {
            console.log("üì∫ Reward Ad closed -> repairing GPU");
            hardRefreshCanvas();
            // On recharge la pub pour la prochaine fois
            AdMob.prepareRewardVideoAd({ adId: AD_IDS.reward, isTesting: AD_IDS.isTesting });
        });

        // üì∫ √âcouteur : Interstitiel FERM√â
        AdMob.addListener('onInterstitialAdDismissed', () => {
            console.log("üì∫ Interstitial Ad closed -> repairing GPU");
            hardRefreshCanvas();
            // On recharge la pub pour la prochaine fois
            AdMob.prepareInterstitial({ adId: AD_IDS.interstitial, isTesting: AD_IDS.isTesting });
        });

    } catch (e) { 
        console.warn("AdMob Init Fail:", e); 
    }
}

// --- VIDE LES BANNI√àRES (Tu n'en veux pas) ---
async function showBanner() { 
    console.log("AdMob: Banni√®re d√©sactiv√©e par choix du d√©veloppeur.");
    return; 
}
async function hideBanner() { return; }

// --- 3. INTERSTITIAL (GAME OVER) ---
async function showGameOverAd() {
    if (!AdMob) return;
    try {
        // Affiche la pub
        await AdMob.showInterstitial();
        // Le rechargement est g√©r√© par le listener 'onInterstitialAdDismissed'
    } catch (e) {
        console.warn("Interstital Fail:", e);
        // Si √©chec (pas pr√™t), on tente de recharger pour la prochaine fois
        AdMob.prepareInterstitial({ adId: AD_IDS.interstitial, isTesting: AD_IDS.isTesting });
    }
}

// --- 4. REWARD (REVIVE & SHOP) ---
async function showRewardedAd(onSuccess, onFail) {
    if (!AdMob) { 
        // Mode PC : Succ√®s direct pour tester la logique du jeu
        console.log("üíª Mode Web: Simulation Pub R√©compense");
        if(onSuccess) onSuccess(); 
        return; 
    }

    try {
        window.pendingRewardSuccess = onSuccess;
        await AdMob.showRewardVideoAd();
        // Recharge la prochaine pub vid√©o
        setTimeout(() => {
            AdMob.prepareRewardVideoAd({ adId: AD_IDS.reward, isTesting: AD_IDS.isTesting });
        }, 1000);
    } catch (e) {
        console.warn("Reward Fail:", e);
        if(onFail) onFail();
        // Tente de recharger
        AdMob.prepareRewardVideoAd({ adId: AD_IDS.reward, isTesting: AD_IDS.isTesting });
    }
}

// Override s√©curit√©
window.isAdSystemReady = function() { return true; };

// Lancement
document.addEventListener('deviceready', initAds);
if (window.Capacitor) initAds();
</script>
</body>
</html>   